<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>COVESA VISS version 3.0 - Core</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
    <script class='remove'>
      var respecConfig = {
        latestVersion: null,
        github: "https://github.com/COVESA/vehicle-information-service-specification",
        specStatus: "base",
	logos: [{
	  src: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/images/covesa.jpg",
          url: "https://covesa.global",
          alt: "COVESA",
          height: 70,
	  width: 100,
          id: "covesa-logo",
        },],
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Ford Motor Company",
          companyURL: "https://www.ford.com",
        },
        {
          name: "이원석(Wonsuk Lee)",
          company: "한국전자통신연구원(ETRI)",
          url: "mailto:wonsuk.lee@etri.re.kr",
          companyURL: "https://etri.re.kr/eng/main/main.etri",
          w3cid: 34457
        }],
        edDraftURI: "https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html",
        shortName: "viss3.0-core",
        localBiblio: {
          "PAYLOAD ENCODING": {
            title: "COVESA VISS version 3.0-Payload Encoding",
            href: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_PayloadEncoding.html",
            publisher: "Ulf Bjorkengren"
          },
          "TRANSPORT": {
            title: "COVESA VISS version 3.0-Transport",
            href: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html",
            publisher: "Ulf Bjorkengren"
          }
        }
      };
    </script>
    <style>
      table.parameters, table.exceptions {
          border-spacing: 0;
          border-collapse:    collapse;
          margin: 0.5em 0;
          width:  100%;
      }
      table.parameters { border-bottom:  1px solid #90b8de; }
      table.exceptions { border-bottom:  1px solid #deb890; }

      .parameters th, .exceptions th {
          color:  inherit;
          padding:    3px 5px;
          text-align: left;
          font-weight:    normal;
      }
      .parameters th { color: #fff; background: #005a9c; }
      .exceptions th { background: #deb890; }

      .parameters td, .exceptions td {
          padding:    3px 10px;
          border-top: 1px solid #ddd;
          vertical-align: top;
      }

      .parameters tr:first-child td, .exceptions tr:first-child td {
          border-top: none;
      }

      .parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
          width:  100px;
      }

      .parameters td.prmType {
          width:  120px;
      }

      table.exceptions table {
          border-spacing: 0;
          border-collapse:    collapse;
          width:  100%;
      }

      .simple {
        width:100%;
      }

      thead th{
        border-bottom: 1px solid black;
      }

      .simple tbody th{
        width:33%;
        background: white;
        color: black;
      }
      pre { white-space: pre-wrap;}
  </style>
  </head>
  <body>
    <p class="copyright">Copyright © 2024 COVESA®. This document
    includes material derived from <a href="https://www.w3.org/TR/viss2-core/">W3C VISS version 2 - Core</a>.</p>
    <section id='abstract'>
      <p>
        The Vehicle Information Service Specification (VISS) is a
        service for accessing vehicle information, including signals from sensors
        on control units within a vehicle's network. This information is exposed through a hierarchical, 
        tree-like taxonomy as defined in the COVESA Vehicle Signal Specification (VSS), 
        and is provided in JSON format. The VISS service may be hosted within the vehicle or on external servers, 
        using data that has already been off-boarded.
      </p>
  
      <p>
        This specification describes the third version of VISS, which
        has been implemented and deployed in production vehicles.
        The first version of VISS supported only WebSocket as a
        transport protocol, the second version is generalized to work
        across different protocols as some are better suited for
        different use cases.
        The second version added support for the HTTP and MQTT transport
        protocols, improved subscription capabilities and added an
        access control mechanism.
      </p>

      <p>
        There are three parts to this specification, CORE, [[TRANSPORT]], and [[PAYLOAD ENCODING]]. This document, the VISS version 3.0 CORE specification,
        describes the VISSv3.0 messaging layer.<br>
        The VISSv3.0 transport protocol specification describes the deviations from the CORE definitions that are used in some transport protocols.
        It also examplifies the JSON primary payload format using the Websocket payloads.
        The VISSv3.0 payload encoding specification describes payload encoding designs that may be applied e. g. for payloads in transit.
      </p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        This specification describes the messaging API for the VISS protocol.
        This includes the messaging layer and set of rules for structuring data.<br>
        The specification is agnostic to which transport protocol that is used as long as it conforms to this messaging API and data rule set.
        Transport protocols that cannot conform to the entire CORE specification can still be conformant by describing their deviations in the
        [[TRANSPORT]] specification.<br>
        The primary payload data format is JSON. The JSON schema (<a href="#json-schema"></a>) defines all of the payloads.
        If a transport protocol uses a different payload encoding, such as gRPC,
        or a more bandwidth efficient data representation is desired, then this encoding may be defined in the [[PAYLOAD ENCODING]] specification.
        This encoding must contain a solution for both encoding of the JSON payloads and decoding back to the JSON format.
        A client MUST be able to access the message payload in the JSON format.
      </p>
      <p>
        The messages are exchanged between a server implementation holding the representation of data
        and a client using the data as shown in the figure below, where the payload also is encoded when in transit over the transport protocol.
      </p>
        <figure id="fig-payload-encoding">
          <img src="images/VISSv3-payload-encoding.jpg" alt="VISSv3 paylod encoding overview.">
          <figcaption> <span class="fig-title">VISSv3 payload encoding overview.</span></figcaption>
        </figure>
      <p>
        The VISSv3.0 messaging layer builds on RESTful principles for the method exchange via the interface (Refer to the <a href="#interface">chapter 5. Interface</a>).
      </p>
      <p>
        The VISSv3.0 data structuring rules (<a href="https://covesa.github.io/vehicle_signal_specification/rule_set/">VSS Rule set</a>)
        are the same through all transport protocols.
        The basis for structuring data held by a server is a tree structure.
      </p>
    </section>

    <section id="conformance"></section>

    <section id="terms">
      <h2>Terminology</h2>
      <p>
      The acronym 'VISSv3.0' is used to refer to this document, the VISS version 3.0 specification.
      The acronym 'VSS' is used to refer to the <a href="https://github.com/COVESA/vehicle_signal_specification">'Vehicle Signal Specification'</a>
      which is hosted by COVESA.
      The term 'WebSocket' when used in this specification, is as defined in the
      <a href="https://www.w3.org/TR/websockets/">W3C WebSocket API</a> and [[RFC6455]], the WebSocket Protocol.
      </p>

        <section id="definitions">
          <h2>Definitions</h2>
        <p></p>

        <dl title="enum Defs" class="idl">
          <dt><b>client</b></dt>
          <dd>An entity that interacts with data managed by a server.</dd>
          <dt><b>server</b></dt>
          <dd>An entity that manages and provides access to data.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-success-response">success response</dfn></dt>
          <dd>The message returned by the server to the client when no error is encountered. These are specific per request type.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-error-message">error message</dfn></dt>
          <dd>The message returned by the server to the client when an error is encountered. It can be a synchronous response message,
          or an asynchronous event message.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-data-point">data point</dfn></dt>
          <dd>A structure containing one or more value-timestamp tuples.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-value">value</dfn></dt>
          <dd>The data that is associated with one or more VSS nodes. Regardless of its data type,
          a single data item is always represented as a string in message payloads.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-timestamp">timestamp</dfn></dt>
          <dd>A date and time representation. See chapter <a href="#timestamp"></a>.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-filter">filter</dfn></dt>
          <dd>Additional information to help the server in the selection of data for the client.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-authorization">authorization</dfn></dt>
          <dd>A token providing a verifiable proof that the client may be authorized access to the requested data.
          This may be represented by a token handle provided by the server.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-subscription-id">subscriptionId</dfn></dt>
          <dd>A handle identifying a subscription session.</dd>
          <dt><b>requestId</b></dt>
          <dd>Unique id value specified by the client.
          Returned by the server in the response and used by the client to link the request and response messages.
          The value MAY be an integer or a Universally Unique Identifier (UUID).</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-purpose">purpose</dfn></dt>
          <dd>A purpose is one of the short text entries from the <a href="#purpose-list"></a>.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-ecf">ECF</dfn></dt>
          <dd>External Consent Framework. An agent that is responsible for inquiring a data owner about consent for client access to data.</dd>
        </dl>
      </section>
    </section>

    <section id="data-model">
      <h2>Data Model</h2>
                <p>The service is designed to use with a tree-like logical taxonomy to represent the vehicle data.
                An illustrative example of such a tree structure is shown in <a href="#fig-example-vss-tree">Figure 2</a>.
                While it is meant to support conforming taxonomies it was created principally with the
                <a href="https://github.com/COVESA/vehicle_signal_specification">Vehicle Signal Specification</a> (VSS) in mind.
                For more details, see the <a href="http://covesa.github.io/vehicle_signal_specification/">VSS documentation</a>.<br>
                An implementation of a VISS compliant server can be deployed either in-vehicle or off-vehicle.
                In the off-vehicle case it would typically reside in the cloud, serving data that has already been off-boarded.
                </p>
        <figure id="fig-example-vss-tree">
          <img src="images/vss-tree.jpg" alt="example-vss-tree">
          <figcaption> <span class="fig-title">Example VSS 2.0 tree.</span></figcaption>
        </figure>

      <section id="address">
        <h2>Addressing</h2>
        <p>Resource addressing is performed using URIs as defined in [[RFC3987]].<br>
        <blockquote><a>scheme</a>://<a>authority</a>/<a>path</a>?<a>query</a></blockquote>
        The <dfn>scheme</dfn> describes the protocol to use to reach the addressed resource.
        For supported protocols, refer to the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#transport-protocols">chapter 5. Transport Protocols</a> in [[TRANSPORT]] specification.<br>
        The <dfn>authority</dfn> describes where to reach the resource, for more details see <a href="#authority-component"></a>.<br>
        The <dfn>path</dfn> addresses a specific service within the resource, for more details see <a href="#path-component"></a>.<br>
        The <dfn>query</dfn> contains further information related to the addressed service, see <a href="#filter-request"></a>.<br>
        There are potentially three resources for which a client needs a URI, see <a href="#architecture"></a>:<br>
        <ul>
            <li>VISSv3 Server.</li>
            <li>Access Grant Token Server.</li>
            <li>Access Token Server.</li>
        </ul>
        </p>

      <section id="authority-component">
        <h2>Authority URI Component</h2>
        <p>
          The authority component of the URI consists of an IP address or a domain name followed by a colon and a port number.
        </p>

        <section id="ip-address-domain-name">
          <h2>IP address / domain name</h2>
          <p>
          Depending on the deployment of a resource, either in the cloud or in a vehicle, they will have a domain name or an IP address, respectively.
          A client is expected to obtain this part of the authority component via an interaction with the
          <a href="#ecosystem-manager-def">ecosystem manager</a>. The details of this interaction are out of scope for this specification.
          </p>
        </section>

        <section id="port-number">
          <h2>Port number</h2>
          <em>This section is non-normative.</em>
          <p>
          The VISSv3 server shall use the following port numbers for the different transport protocols.
          <ul>
            <li>HTTP port number = 443</li>
            <li>Websocket port number = 6443</li>
            <li>MQTT port number = 8883</li>
            <li>gRPC port number: 5443</li>
          </ul>
          The Access Grant Token Server SHALL use the port number 7443.<br>
          The Access Token Server SHALL use the port number 8443.<br>
          A client may be provisioned with other port numbers than the above specified in its interaction
          to obtain the other parts of the authority component, see <a href="#ip-address-domain-name"></a>.
          </p>
        </section>
      </section>

      <section id="path-component">
        <h2>Path URI Component</h2>
        <p>
          The path URI component definition differs between the three resources.<br>
          For the <b>VISSv3 server</b> the definition is as follows.<br>
          The path consists of a sequence of VSS node names separated by a delimiter. VSS specifies the dot (.) as delimiter,
          which therefore is the recommended choice also in this specification.
          However, in HTTP URLs the conventional delimiter is slash (/), therefore also this delimiter is supported.
          To exemplify, the path expression from traversing the nodes Vehicle, Car, Engine, RPM can  be "Vehicle.Car.Engine.RPM",
          or "Vehicle/Car/Engine/RPM". Mixing delimiters in the same path expression SHOULD be avoided.<br>
          The path MUST not contain any wildcard characters ("*"), for such needs see <a href="#paths-filter-operation"></a>.<br>
          For the <b>Access Grant Token Server</b> the path is "agts".<br>
          For the <b>Access Token Server</b> the path is "ats".<br>
        </p>
      </section>
      </section>

      <section id="data-representation">
        <h2>Data representation</h2>
        <p>
          A single data point is in the message payload represented by a value and an associated timestamp,
          in JSON represented by two key-value pairs with the key names "value" and "ts".<br>
          The "ts" value MUST be a string as specified in <a href="#timestamp"></a>.<br>
          The "value" value MUST be represented as a string for simple datatypes.
          If the value is an array it MUST be represented as a JSON array of strings.
          In the case the value is a struct complex datatype it MUST be represented as a JSON object, see below.
          For supported datatypes see <a href="https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/data_types/">VSS Data Types</a>.<br>
          Number values MUST follow the number formats as specified in [[RFC8259]], but as stated above represented as a string.
          Boolean values MUST be represented by either of the strings "true" or "false".<br>
          The struct complex datatype MUST be represented as a JSON object as shown below.
          A struct with the following declaration
          <pre><code>
          struct {
              field1 datatype
              field2 datatype
          }
          </code></pre>
          is represented by the following JSON object
          <pre><code>
          {"field1":"X", "field2":"Y"}
          </code></pre>
          where X and Y are the actual values of respective datatype.
          The datatype of a field of the struct may be any datatype supported by VSS, including a struct.<br>
          For representation of multiple data points, see <a href="#response-syntax"></a>.<br>
          If data is represented incorrectly, then an error message with number 400, and reason "invalid_data" MUST be returned.
        </p>
      </section>
    </section>

    <section id="interface">
      <h2>Interface</h2>
      <p>
        This chapter describes the different methods and their arguments that govern the communication between a client and the server.
      </p>

      <section id="methods">
        <h2>Methods</h2>
        <p>
          Transport protocols used to implement these methods MUST support the Read and Update methods,
          and MAY support the Subscribe, Unsubscribe, and Subscription methods.
        </p>
        <section id="read">
          <h2>Read</h2>
          <p>Purpose: Get one or more values addressed by the given path.</p>
          <p>The client MAY have to obtain an <a>authorization</a> token before accessing the requested values.
             If the server successfully processes the request, it MUST return a <a>success response</a>.
             If the server fails to fulfill the request, then the server MUST return an <a href="#error-message">error message</a>.</p>
          <p>Arguments, of which path is mandatory:
          <ul>
            <li><a>path</a> The VSS-defined path to a node in the VSS tree.</li>
            <li><a>filter</a> Additional parameters to refine the requested data.</li>
            <li><a>authorization</a> The authorization token.</li>
            <li><a>data compression</a> The compression scheme(s) used for transmitted data.</li>
          </ul>
          </p>
          <p>Success response, of which authorization is optional:
            <ul>
              <li><a>data</a> A structure containing one or more sets of a path and data point.</li>
              <li style="margin-left: 40px"><a>path</a> The VSS-defined path for the associated data point.</li>
              <li style="margin-left: 40px"><a>data point</a> A structure containing one or more value-timestamp tuples.</li>
              <li style="margin-left: 80px"><a>value</a> The latest available value.
              Please note that also for actuators this returns the current value, and not a target value that might have been set.</li>
              <li style="margin-left: 80px"><a>timestamp</a> The capture time of the value.</li>
              <li><a>authorization</a> A handle representing the authorization token.</li>
              <li><a>timestamp</a> The server execution time of the request.</li>
            </ul>
          </p>
        </section>

        <section id="update">
          <h2>Update</h2>
          <p>Purpose: Provide an altered value to the vehicle signal addressed by the <a>path</a>.</p>
          <p>The client MAY have to obtain an authorization token before updating a vehicle signal.
          If the server successfully processes the request, it MUST return a <a>success response</a>. If it cannot, it MUST return an <a>error message</a>.
          Only actuator type signals can be updated.
          Please note that a success response does not guarantee that the actuation attempt to change to the updated target value has, or will, succeed.
          A client may monitor the actuation progress through subsequent reads of the actuator value.
          </p>
          <p>Arguments, of which path and value are mandatory:
            <ul>
              <li><a>path</a> The VSS-defined path to a leaf node in the VSS tree.</li>
              <li><a>value</a> The new value to update the vehicle signal at the specified path.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response, of which authorization is optional:
            <ul>
              <li><a>authorization</a> A handle representing the authorization token.</li>
              <li><a>timestamp</a> The server execution time of the request. This may not be the same as the final update time of the signal.</li>
            </ul>
          </p>
        </section>

        <section id="subscribe">
          <h2>Subscribe</h2>
          <p>Purpose: Get asynchronous messages containing the value(s) addressed by the path.
          The triggering conditions for these events are determined by the filter rules.</p>
          <p>The client MAY have to obtain an authorization token before subscribing to vehicle signal(s).
             The server MUST issue an event message if a trigger rule is met.
             If the server successfully processes the request, it MUST return a <a>success response</a>.
             If the server fails to fulfill the request, then the server MUST return an <a href="#error-message">error message</a>.
             If an error occurs during the subscription period, the server SHOULD return an <a href="#error-message">error message</a>.</p>
          <p>Arguments, of which path and filter are mandatory:
            <ul>
              <li><a>path</a> The VSS-defined path to a node in the VSS tree.</li>
              <li><a>filter</a> A rule set defining the triggering criteria for asynchronous event messages.</li>
              <li><a>authorization</a> The authorization token.</li>
              <li><a>data compression</a> The compression scheme(s) used for transmitted data.</li>
            </ul>
          </p>
          <p>Success response, of which authorization is optional:
            <ul>
              <li><a>authorization</a> A handle representing the authorization token.</li>
              <li><a>subscriptionId</a> A unique identifier for the subscription session.</li>
              <li><a>timestamp</a> The start time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section id="unsubscribe">
          <h2>Unsubscribe</h2>
          <p>Purpose: Terminates a subscription that was previously established through a subscribe request.</p>
          <p>If the server successfully processes the request, it MUST return a <a>success response</a>,
          and it MUST stop issuing event messages associated to the subscription handle.
          If the server fails to fulfill the request, then the server MUST return an <a href="#error-message">error message</a>.</p>
          <p>Arguments, of which subscriptionId is mandatory:
            <ul>
              <li><a>subscriptionId</a> A unique identifier for the subscription session.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>
              <li><a>timestamp</a> The time at which the subscription was terminated.</li>
            </ul>
          </p>
        </section>
        <section id="subscription">
          <h2>Subscription</h2>
          <p>Purpose: Sends asynchronous event messages to the client when a subscribe request trigger rule is met.
          </p>
          <p>The server MUST issue an event message when a triggering rule associated with the subscription is met.
             If the server cannot fulfill the triggering rules it MUST issue an error message and terminate the subscription.
          </p>
          <p>Arguments, of which all are mandatory:
            <ul>
              <li><a>subscriptionId</a> A unique identifier for the subscription session.</li>
              <li><a>data</a> A structure containing one or more sets of a path and data point.</li>
              <li style="margin-left: 40px"><a>path</a> The VSS-defined path for the associated data point.</li>
              <li style="margin-left: 40px"><a>data point</a> A structure containing one or more value-timestamp tuples.</li>
              <li style="margin-left: 80px"><a>value</a> The current value associated with the filter expression.</li>
              <li style="margin-left: 80px"><a>timestamp</a> The capture time of the value.</li>
              <li><a>timestamp</a> The server execution time of the subscription event.</li>
            </ul>
          </p>
        </section>
      </section>

      <section id="error-message">
        <h2>Error Message</h2>
        <p>The server MUST notify the client of any errors that occur during their interaction, whether as a synchronous error response 
          or an asynchronous error event resulting from a previous subscription request.
        The error message has three arguments, of which subscriptionId is mandatory only for error events.
        In the case of an error event being issued by the server, the associated subscription session SHALL thereafter be terminated by the server.
        </p>
          <p>Arguments:
            <ul>
              <li><a href="#error-information"></a></li>
              <li><a>subscriptionId</a> The reference to the subscribe session.</li>
              <li><a>timestamp</a> The server execution time when the error occurred.</li>
            </ul>
          </p>

        <section id="error-information">
          <h2>Error Information</h2>
          <p>The error information consists of three components: number, reason, and description.
          All the three components MUST be part of the error information.
            <ul>
              <li><b>number</b> Refer to the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#status-codes">chapter 4.1 Status Codes</a> defined in [[TRANSPORT]].</li>
              <li><b>reason</b> Refer to the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#status-codes">chapter 4.1 Status Codes</a> defined in [[TRANSPORT]].</li>
              <li><b>description</b> Refer to the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#status-codes">chapter 4.1 Status Codes</a> defined in [[TRANSPORT]].</li>
            </ul>
          </p>
          </section>
      </section>

      <section id="timestamp">
        <h2>Timestamps</h2>
        <p>
           Timestamps in transport payloads MUST conform to the [[ISO8601]] standard, using the UTC format with a trailing Z.
           Time resolution SHALL at least be seconds, with subsecond resolution as an optional degree of precision when desired.
           The time and date format shall be as shown below, where the sub-second data and delimiter is optional.<br>
           YYYY-MM-DDTHH:MM:SS.ssssssZ<br>
           The exceptions to this are timestamps within tokens which MUST conform to Unix time,
           or if timestamp data compression is applied.
        </p>
      </section>
    </section>

      <section id="security">
        <h2>Security Considerations</h2>

      <section id="transport-security">
        <h2>Transport security</h2>
        <p>
        Transport protocols supported by this specification MUST make use of TLS v1.2 as defined in [[RFC5246]].
        </p>
      </section>

      <section id="data-security">
        <h2>Data security</h2>
        <p>
        The <a href="#access-control-model"></a> enables the enforcement of data access restrictions 
        for clients that have been granted access at the transport protocol level.
        </p>
      </section>

      <section id="privacy">
        <h2>Privacy Considerations</h2>
        <p>
        In addition to some privacy provisions within the specification itself, COVESA and W3C have activities seeking
	to establish systems and guidelines to provide further considerations for handling of sensitive information.
        </p>

        <p>
          For certain use cases, such as when data is referenced only within the vehicle, is not transmitted externally, 
          and does not persist across restarts, privacy concerns should be minimal or nonexistent.
        </p>

        <p>
        This specification has granular access control capabilities, allowing restrictions on the information an application may access.
        Additionally, all data transmitted from a VISS service to a client application MUST be transported 
        over an encrypted protocol to ensure privacy protection.
        </p>

        <p>
        A client accessing vehicle data may require consent from an authorized entity, which varies based on jurisdiction and ownership.
        This specification supports integration with an External Consent Framework (ECF) to enable consent management within a VISS server,
        see <a href="#consent-support"></a>.
        Consent SHOULD be revocable; however, the process for revocation is out of scope for this specification.
        It is expected to be handled out of band and may be governed by regulations or contractual agreements.
        </p>

      </section>
      </section>

    <section id="filter-request">
      <h2>Filter Request</h2>
          <p>
          Filtering is a mechanism that refines client requests to provide more precise control over the returned response data.
          Filtering can be applied in both read requests and subscribe requests.<br>
          A request with filtering follows this structure:
          <ul>
          <li>For HTTP protocol:
          <ul>
          <li>GET /&lt;vsspath&gt;?filter=&lt;filter-expression&gt;</li>
          </ul></li>
          <li>For any protocol using the primary JSON payload format:
          <ul>
          <li>{"action":"get", "path":"&lt;vsspath&gt;", "filter":"&lt;filter-expression&gt;"}</li>
          </ul></li>
          </ul>
          where<br>
          <ul>
          <li>get: the transport protocol method.</li>
          <li>vsspath: The VSS path, starting from the tree root.</li>
          <li>filter: The key name for the filter expression.</li>
          <li>filter-expression: The filter instructions.</li>
          </ul>
          </ul>
          The filter expression has the object format as shown below. For the case of an optional second object of this type,
          these are enclosed in an array expression.<br>
          <ul>
          <li>{"variant":"&lt;x&gt;", "parameter":"&lt;y&gt;"}</li>
          </ul>
          where<br>
          <ul>
          <li><b>variant</b>: The key name for the filter operation variant, which can have one of the following values:
          <ul>
          <li><u>paths</u>:
          <ul>
          <li>One or more relative paths. If multiple paths are used, an array expression SHALL be applied.</li>
          </ul></li>
          <li><u>timebased</u>:
          <ul>
          <li>Data is captured at fixed time intervals.</li>
          </ul></li>
          <li><u>range</u>:
          <ul>
          <li>Data is captured when values are in the given range.</li>
          </ul></li>
          <li><u>change</u>:
          <ul>
          <li>Data is captured when the value since last capture has changed more than a fixed value.</li>
          </ul></li>
          <li><u>curvelog</u>:
          <ul>
          <li>Captured data is processed according to the
          <a data-link-type="dfn" href="https://www.geotab.com/blog/gps-logging-curve-algorithm/">curve logging</a> algorithm before being sent to client.</li>
          </ul></li>
          <li><u>history</u>:
          <ul>
          <li>Captured data from a time period from current time and backwards in time.</li>
          </ul></li>
          <li><u>metadata</u>:
          <ul>
          <li>The response contains the VSS metadata of the addressed sub-tree.</li>
          </ul></li>
          </ul></li>
          <li><b>parameter</b>: The key name for optional configuration data required by the filter operation.
          The parameter data varies depending on the variant. It must be enclosed in an object or, optionally, an array of two objects.
          Detailed descriptions of parameter values are provided in the following sections.</li>
          </ul>
          The server MUST support the timebased and change variants, the other variants are optional.<br>
          In the JSON object, the key-value pairs "variant" and "parameter" MUST always be present.
          The JSON expression may consist of maximum one object with variant "paths", plus maximum one object with any other supported variant,
          which are then logically combined as with an AND operator.<br>
          The variants timebased, range, change, and curvelog can only be used in subscription requests.
          Subscription requests are NOT supported by the HTTP transport protocol.<br>
          The restriction on how many objects that can be combined is also set by the URL size restriction on 1k characters (*).<br>
          (*) 1k is the "conservative limit, which should always be supported, a more liberal limit is 2k, which is supported in most cases.
          </p>

     <section id="paths-filter-operation">
        <h2>Paths Filter Operation</h2>
                <p>
                The paths filter operation allows a single request to retrieve signal data from multiple data points in the VSS tree.
                The vsspath SHALL point to the last node in the tree that is common for the relative paths in the filter parameter object,
                that start off from this node.
                If a path endpoint in the filter value is a branch, all leaf nodes in the sub-tree below that branch SHALL be included.
                A path in the filter value MAY contain the wildcard character (*), which represents a single path segment.<br>
                Every path element in a value array must address at least one node in the tree. If no matching node is found, the server SHALL return an error message.<br>
                Different elements of the value array MAY address the same node,
                in which case it is the responsibility of the server to resolve this to a singleton in the event messages.<br>
                Examples can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#wss-search-read">chapter 5.1.2.1.2 Search Read</a> and
                <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#https-search-read">chapter 5.2.2.1.2 Search Read</a> in [[TRANSPORT]] specification.
                </p>
        </section>

     <section id="history-filter-operation">
        <h2>History Filter Operation</h2>
                <p>
                By default, the server typically have access only to the latest, most fresh data point representing a signal.
                However, under certain conditions, it MAY temporarily store and provide access to historical data points.
                One such scenario occurs when a vehicle temporarily loses connectivity, for example, when entering a tunnel. 
                If the vehicle detects this loss of connectivity, it MAY begin recording data. 
                If recorded, this data MAY be accessed using the history variant of the filter operation.
                The vehicle system makes its own decision whether to record any data, and for how long this data will be kept in storage.
                The history period in the filter expression MUST extend backward in time from the current time, excluding the current value.
                The number of data points in the response depends on the history period size, and the sampling frequency.
                Since the sampling frequency is server-defined, the client SHOULD estimate the potential data volume before making a request.
                If no historical data is available, the request SHALL return a "404 Not Found" error.
                The period MUST conform to the [[ISO8601]] duration format, expressed in days, hours, minutes, and seconds. 
                For example: "parameter": "PdddDThhHmmMssS".
                The number of days MUST be less than 999. Only a single period can be specified.<br>
                Examples can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#https-history-read">chapter 5.1.2.1.3 History Read</a> and
                <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#https-history-read">chapter 5.2.2.1.3 History Read</a> in [[TRANSPORT]] specification.
                </p>
        </section>

     <section id="timebased-filter-operation">
          <h2>Time-Based Filter Operation</h2>
                <p>
                The parameter object contains the period time X in between captures, {"period":"X"}.
                X is an integer and represents the period time in milliseconds.
                Example can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#subscribe">chapter 5.1.2.3 Subscribe</a> in [[TRANSPORT]] specification.
               </p>
        </section>

     <section id="range-filter-operation">
          <h2>Range Filter Operation</h2>
                <p>
                The range filter operation supports two types of ranges, as described in the following subchapters<br>
                The values MUST be of a numeric data type.
                </p>
                <section id="single-boundary-range">
                  <h2>Single Boundary Range</h2>
                  <p>
                  A single "boundary operator" evaluates the current signal value relative to a single boundary.
                  If the condition evaluates to true, the server MUST issue an event message containing the signal value to the subscribing client.
                  The boundary operator MUST be one of the values listed in the footer (**).<br>
                  Examples<br>
                  {"logic-op":"gt", "boundary": "5"}   // x > 5<br>
                  {"logic-op":"eq", "boundary": "5"}   // x == 5
                  </p>
                </section>
                <section id="multi-boundary-range">
                  <h2>Multi Boundary Range</h2>
                  <p>
                  A multi boundary range evaluates the current signal value relative to two boundaries.
                  The logical outcome of the two evaluations are applied as input to a logical AND/OR operation.
                  If the condition evaluates to true, the server MUST issue an event message containing the signal value to the subscribing client.
                  In addition to the mandatory "logic-op" and "boundary" key-value pairs in each JSON object, 
                  the first object MAY include an optional "combination-op" key-value pair, which MUST have either the value "AND" or "OR".
                  If omitted, the result of the two boundary evaluations SHALL default to an AND operation.
                  The JSON array MUST contain two objects.
                  The boundary operator MUST be one of the values listed in the footer (**).<br>
                  Examples<br>
                  [{"logic-op":"gt", "boundary": "5"},{"logic-op":"lt", "boundary": "10"}]   // x > 5 AND x < 10<br>
                  [{"logic-op":"lt", "boundary": "5", "combination-op":"OR"},{"logic-op":"gt", "boundary": "10"}]   // x < 5 OR x > 10
                  </p>
                </section>
                (**)The supported boundary operators are ["eq", "ne", "gt", "gte", "lt", "lte"],
                where "eq" is "equal", "ne" is "not equal", "gt" is "greater than", "gte" is "greater than or equal", "lt" is "less than",
                "lte" is "less than or equal".<br>
                Examples can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#authorized-subscribe">chapter 5.1.2.3.1 Authorized Subscribe</a> and
                <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#range-subscribe">chapter 5.1.2.3.3 Range Subscribe</a> in [[TRANSPORT]] specification.
               </p>
        </section>

     <section id="change-filter-operation">
          <h2>Change Filter Operation</h2>
                <p>
                The change filter operation detects differences between previous and current values based on a specified condition.
                The diff values MUST be of numeric or boolean data types.<br>
                The parameter object contains the logical operator for comparison of previous and current values, {"logic-op":"X", "diff":"Y"},
                where X is one of the supported logical operators (**), and Y is the value of the required change.<br>
                For boolean values the following expressions SHALL be supported:<br>
                <ul>
                <li>{"logic-op":"gt", "diff": "0"}: Triggers an event when the value changes from false->true.</li>
                <li>{"logic-op":"lt", "diff": "0"}: Triggers an event when the value changes from true->false.</li>
                <li>{"logic-op":"ne", "diff": "0"}: Triggers an event when the value changes from true->false OR false->true.</li>
                </ul>
                The "not equal" (ne) logic operator with a zero (0) diff can also be used to track changes in string data types, 
                where other diff values may not be applicable.
                <br><br>
                (**)The supported logic operators are ["eq", "ne", "gt", "gte", "lt", "lte"],
                where "eq" is "equal", "ne" is "not equal", "gt" is "greater than", "gte" is "greater than or equal",
                "lt" is "less than", "lte" is "less than or equal".<br>
                Example can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#change-subscribe">chapter 5.1.2.3.4 Change Subscribe</a>
                 in [[TRANSPORT]] specification.
               </p>
        </section>

     <section id="curvelog-filter-operation">
          <h2>Curve logging Filter Operation</h2>
                <p>
                The curve logging filter operation compresses data by simplifying a time-series signal while maintaining its essential characteristics.
                The parameter object contains the maximum error limit, and the buffer size, {"maxerr": "X", "bufsize":"Y"},
                where X is a floating-point value representing the maximum allowable error between any sampled data point and the simplified curve,
                and Y is the number of buffer elements. The data is processed when the buffer becomes full, 
                and only the essential data points are returned as a time series per signal.<br>
                Example can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#curve-logging-subscribe">chapter 5.1.2.3.2 Curve Logging Subscribe</a>
                 in [[TRANSPORT]] specification.
               </p>
        </section>

   <section id="metadata-request">
     <h2>Metadata Filter Operation</h2>
        <p>
        A metadata request allows a client to retrieve metadata associated with VSS node(s), 
        rather than the actual signal data.<br>
        The metadata is retrieved from the VSS tree that is deployed in the vehicle.
        This request variant is sometimes referred to as a signal discovery request.<br>
        The path in the request MAY point to either a leaf node or a branch node.
        The "parameter" value in the filter expression sets the number of descendant generations that
        metadata will maximally be returned from. If it is set to zero then there is no limit set and the
        entire sub-tree that has the addressed node as root will be returned.
        If it is set to two then the metadata from the subtree root and its immediate children will be returned.
        A metadata request can be combined with a paths filter operation to address multiple nodes.
        If it is combined with any other filter variant an error message is returned.<br>
        The response is a JSON formatted object containing key-value pairs for each addressed node.
        The server MAY support the metadata request.<br>
        Example can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#https-service-discovery-read">chapter 5.2.2.1.4 Signal Discovery Read</a> in [[TRANSPORT]] specification.
        </p>
    </section>

     <section id="multiple-signals-request">
          <h2>Multiple Signals Request</h2>
            <p>
            Filtering operations MAY be used to address multiple nodes in the VSS tree within a single request.
            However, this MAY lead to specific issues in certain situations, as described below.
            </p>

     <section id="error-handling">
          <h2>Error Handling</h2>
            <p>
            Error messages for multiple-signal requests are handled the same way as for single-signal requests, 
            except when one or more signals are temporarily unavailable.
            In such cases, the server MAY use in-line error reporting, see
            <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#in-line-error-reporting">chapter 4.1.1 In-line Error Reporting</a> in [[TRANSPORT]] specification.
            </p>
     </section>

     <section id="response-syntax">
          <h2>Response syntax</h2>
            <p>
            A response MAY contain multiple values, due to either that multiple nodes were addressed or that multiple values for one signal are returned.<br>
            These two reasons can be combined, leading to four different cases.
                <ul>
                <li>Request for a single value from a single node.</li>
                <li>Request for multiple values from a single node.</li>
                <li>Request for a single value from multiple nodes.</li>
                <li>Request for multiple values from multiple nodes.</li>
                </ul>
                The syntax to accomodate these four cases have a common structure where a data point ("dp") consists of one or more objects
                containing a "value" and a timestamp ("ts"), and the complete aggregation ("data"),
                consists of one or more objects containing a "path" and a data point (dp"). The syntax of the four cases are shown below.
                <p>Response for a single value from a single node:
        <pre class="highlight hljs javascript" aria-busy="false">
  "data": {
    "dp": {
      "ts": "Z",
      "value": "Y"
    },
    "path": "X"
  }
                   </pre></p>
                   <p>Response for multiple values from a single node:
                <pre class="highlight hljs javascript" aria-busy="false">
  "data": {
    "dp": [
      {
        "ts": "Z1",
        "value": "Y1"
      },
      {
        "ts": "Zn",
        "value": "Yn"
      }
    ],
    "path": "X"
  }
                </pre></p>
                <p>Response for a single value from multiple nodes:
                <pre class="highlight hljs javascript" aria-busy="false">
  "data": [
    {
      "dp": {
        "ts": "Z1",
        "value": "Y1"
      },
      "path": "X1"
    },
    {
      "dp": {
        "ts": "Zm",
        "value": "Ym"
      },
      "path": "Xm"
    }
  ]
                </pre></p>
                <p>Response for multiple values from multiple nodes:
                <pre class="highlight hljs javascript" aria-busy="false">
  "data": [
    {
      "dp": [
        {
          "ts": "Z11",
          "value": "Y11"
        },
        {
          "ts": "Z1n",
          "value": "Y1n"
        }
      ],
      "path": "X1"
    },
    {
      "dp": [
        {
          "ts": "Zm1",
          "value": "Ym1"
        },
        {
          "ts": "Zmn",
          "value": "Ymn"
        }
      ],
      "path": "Xm"
    }
  ]
        </pre></p>
               In the case of a request for multiple values from multiple nodes, the data point for different paths MAY contain single or multiple objects,
               as the vehicle system MAY not have multiple values recorded for all requested signals.
            </p>
     </section>

     <section id="subscription-event-triggering">
          <h2>Subscription Event Triggering</h2>
            <p>
            A subscription request MUST include a filter operation that defines the trigger event 
            causing the server to dispatch an asynchronous event message.
            For "range" and "change" filter variants, triggering depends on the signal value.
            When a request addresses multiple signals, the triggering condition SHALL be evaluated for only one signal, 
            specifically the first signal in the paths parameter array.
            The first path in the array MUST NOT contain wildcards, as it determines the triggering signal.
            If a wildcard expression is used, one of the resolved path addresses MUST be explicitly selected 
            as the first array element, followed by the wildcard expression.
            If this results in a duplicate reference to the same signal, the server SHALL resolve it into a singleton in the event messages.
            </p>
     </section>
     </section>
   </section>

    <section id="access-control-model">
      <h2>Access Control Model</h2>
      <p>
      This chapter defines an access control model aligned with the <a href="https://gdpr-info.eu">General Data Protection Regulation (GDPR)</a>.
      The general process begins with a client authenticating for a specific role with the Access Grant Token Server.
      If this is successful it receives an access grant token. This token can then be used one or more times when making access requests to the Access Token Server.
      These requests contain the AGT and a purpose. It is assumed that the Ecosystem Manager has published a list of approved purposes that the ecosystem serves, 
      and any other purpose must be denied access. If the request to the ATS is successful, the client receives an access token, 
      which can then be used in requests to the VISSv3 server to access one or more signals associated with the approved purpose.<br>
      Access control MUST be supported. However, in this chapter only the sections that describe interactions between the
      <a href="#client-def">client</a> and the VISSv3 server are mandatory.<br>
      Access control SHALL NOT be applied to the VSS nodes containing the VSS version data, nor to client requests 
      for dynamic metadata about server capabilities or access control selection tags applied to the VSS tree.
      </p>

      <section id="architecture">
        <h2>Architecture</h2>
        <em>This section is non-normative.</em>
        <p>
        The VISSv3 access control model is inspired by OAuth2.0 [[RFC6749]],
        but includes some deviations, which are described in the following chapters.<br><br>
        The architecture defines four primary actors:<br>
        <ul>
        <li><b>Client: </b>
        An <a href="#application-roles-def">application </a>making protected and authorized resource requests on behalf of its
        <a href="#user-roles-def">user</a>.<br>
        <li><b>Access Grant Token (AGT) Server:</b>
        The server issuing the access grant token after successfully authenticating the <a href="#client-def">client</a>.<br>
        <li><b>Access Token Server (ATS):</b>
        The server issuing the <a href="#access-token-def">access token</a> to the <a href="#client-def">client</a>
        after successfully validating the request and obtaining authorization.<br>
        <li><b>VISSv3 Server:</b>
        The server hosting the protected resources, capable of accepting and responding to protected resource requests using
        <a href="#access-token-def">access tokens</a>.<br><br>
        </ul>
        The abstract protocol flow illustrated in the figure below describes the interaction between the four actors.<br>
        <figure id="fig-oauth2.0-flow">
          <img src="images/VISSv3-abstract-flow.jpg" alt="VISSv3 abstract protocol flow.">
          <figcaption> <span class="fig-title">The abstract protocol flow.</span></figcaption>
        </figure>
        In addition to the four core actors, two additional actors participate in the ecosystem:<br>
        <ul>
        <li><b>Resource Owner:</b>
        This is typically the driver of the vehicle, who may be required to provide consent before access is granted.<br>
        <li><b>Ecosystem Manager:</b>
        The entity manages the access control ecosystem. It controls the Policy documents,
        and manages the PKI ecosystem that the other actors may utilize.<br><br>
        </ul>
        The abstract protocol flow is implemented through two different flows, which are described in the following chapters.<br>
        The process of obtaining credentials for <a href="#client-def">client</a> authentication is out-of-scope, 
        along with the installation procedures for the <a href="#application-roles-def">applications</a>.
        </p>
      </section>

      <section id="access-control-flows">
        <h2>Protocol Flows</h2>
        <em>This section is non-normative.</em>
        <p>
        Two different flows are described, and the choice of flow depends on the <a href="#client-def">client</a>'s capabilities.<br>
        If a <a href="#client-def">client</a> supports public key cryptographic operations,
        such as key pair generation and digital signatures,
        and has access to a trusted execution environment (TEE) that protects private keys from the regular execution environment,
        then it can use the long-term flow. <a href="#client-def">Clients</a> that lack these capabilities 
        or choose not to use them MUST select the short-term flow.<br>
        The advantage of the long-term flow is that the <a href="#client-def">client</a> can be trusted with longer expiry times of
        <a href="#access-grant-token-def">access grant tokens</a>.
        In the short-term flow, due to a shorter expiry time, the <a href="#client-def">client</a> must contact the
        <a href="#access-grant-server-def">Access Grant Token Server</a> more often to obtain a new
        <a href="#access-grant-token-def">access grant token</a>.<br>
        A <a href="#client-def">client</a> selects the type of flow by either submitting a public key in the
        <a href="#access-grant-request-def">access grant request</a>, or not. 
        If a public key is submitted, the long-term flow is used; otherwise, the short-term flow applies.
        </p>
      </section>

      <section id="protocol-messages">
        <h2>Protocol Messages</h2>
        <em>This section is non-normative.</em>
        <p>
        This chapter describes the payload structures of the messages used in the protocol flow.
        </p>

        <dfn id="access-grant-request-def"></dfn>
        <section id="access-grant-request">
          <h2>Access Grant Request</h2>
          <p>
          The request SHALL contain the Context and Proof parameters listed below. The other parameters are optional:
          <ul>
            <li>VIN: The vehicle identification number. Instead of the assigned VIN, a generated hash may be used as a pseudo-VIN, 
            or any other unique identifier that links the vehicle within the access control ecosystem.</li>
            <li><a href="#client-context-def">Context</a>: The context associated with the <a href="#client-def">client</a>, 
            consisting of three key roles: <a href="#user-roles-def">user roles</a>, <a href="#application-roles-def">application roles</a>,
            and <a href="#device-roles-def">device roles</a>.</li>
            <li><a href="#proof-of-possession-def">Proof</a>: A verification mechanism used by the <a href="#client-def">client</a>
            to prove its context to the <a href="#access-grant-server-def">Access Grant Token Server</a>.
            This is a composite proof that includes <a href="#user-roles-def">user roles</a>, <a href="#application-roles-def">application roles</a>,
            and <a href="#device-roles-def">device roles</a>.</li>
            <li>Public Key: If this parameter is present, the client will receive a long-term
            <a href="#access-grant-token-def">access grant token</a> in return.</li>
          </ul>
          </p>
          <p>
            Depending on the type of <a href="#proof-of-possession-def">proofs</a> included in the request,
            the client and the server MAY need to run an interactive protocol to verify them.
            The protocol MAY also involve third parties, such as the <a href="#ecosystem-manager-def">ecosystem manager</a> or the
            <a href="#resource-owner-def">resource owner</a>. The verification protocol itself is out of scope for this specification.<br>
            In scenarios where both the client and the <a href="#access-grant-server-def">Access Grant Token Server</a>
            are deployed inside the vehicle, the VIN parameter MAY be omitted. In all other deployment scenarios, the VIN parameter SHALL be included.<br>
          </p>
        </section>

        <section id="access-grant-response">
          <h2>Access Grant Response</h2>
          <p>
          The response SHALL contain the parameter below:
          <ul>
            <li><a href="#access-grant-token-def">Access Grant Token</a>: A signed token that includes claims required to validate the
            <a href="#client-def">client</a> request.</li>
          </ul>
          The response to a successful <a href="#access-grant-request-def">access grant request</a> MAY be either a short-term or long-term
          <a href="#access-grant-token-def">access grant token</a>, depending on the input in the request message.
          The only difference between these token types is that a long-term <a href="#access-grant-token-def">access grant token</a>
          SHALL include the public key used in the request.
          <br>
          The <a href="#access-grant-token-def">access grant token</a> is a digitally signed document, issued by the
          <a href="#access-grant-server-def">Access Grant Token Server</a>, containing all relevant information required to issue
          <a href="#access-token-def">access tokens</a>.
        </p>
        <p>
          If the request fails, the response SHALL contain the following parameter:
          <ul>
            <li>Error code: A error code that provides the <a href="#client-def">client</a>
            with clear guidance on what must be corrected for the request to succeed.</li>
          </ul>
        </p>

        </section>



        <section id="access-token-request">
          <h2>Access Token Request</h2>
          <p>
          The client may need to send multiple requests before receiving an access token, even when a valid access grant token is available.
          This is because, if consent is required, the Access Token Server (ATS) will forward the consent request to the External Consent Framework (ECF),
          and an immediate response from the <a>ECF</a> may not be available.
          In such cases, the ATS will respond to the initial access token request with a session handle, which the client MUST use in subsequent requests for the access token.
          Once the ATS receives a response from the <a>ECF</a>, it will process the client’s follow-up request in one of two ways:
          <ul>
            <li>If consent is granted, the ATS will return the access token.</li>
            <li>If consent is denied, the ATS will return a response indicating the negative consent result only.</li>
          </ul>

        <section id="initial-access-token-request">
          <h2>Initial Access Token Request</h2>
          <p>
          The request SHALL contain at least the following two parameters:
          <ul>
            <li><a href="#access-grant-token-def">Access Grant Token</a>: A signed token that includes the claims required to validate the
            <a href="#client-def">client</a> request.</li>
            <li><a>Purpose</a>: The intended use of the requested data by the client.</li>
          </ul>
            Short-term <a href="#access-grant-token-def">access grant tokens</a> can be used directly as input to the
            <a href="#access-token-server-def">Access Token Server</a>. However, when using a long-term <a href="#access-grant-token-def">access grant tokens</a>,
            the client SHOULD provide a <a href="#proof-of-possession-def">Proof of Possession</a> (PoP)
            for the private key corresponding to the public key embedded in the token.
          </p>
          <p>
            The <a href="#access-token-server-def">Access Token Server</a> acts as a Policy Enforcement Point (PEP),
            making access control decisions based on the submitted
            <a href="#access-grant-token-def">access grant token</a> and declared <a>purpose</a>.
          </p>
        </section>

        <section id="inquiry-access-token-request">
          <h2>Inquiry Access Token Request</h2>
          <p>
          This request MAY be issued by the client after receiving a session handle in response to an initial access token request.<br>
          The request SHALL contain at least the following parameter:
          <ul>
            <li>Session Handle: A reference identifier that logically links this request to the previously issued initial access token request.</li>
          </ul>
          </p>
        </section>
        </section>

        <section id="access-token-response">
          <h2>Access Token Response</h2>

        <section id="access-token-response-consent-not-required">
          <h2>Access Token Response — Consent Not Required</h2>
          <p>
          If access control does not require consent from the data owner, an immediate response is possible.<br>
          In the case of a successful response, it SHALL contain the following parameter:
          <ul>
            <li><a href="#access-token-def">Access Token</a>: The token to be used in <a href="#client-def">client</a>
            requests to the VISSv3 server for accessing Protected Resources.</li>
          </ul>
          In the case of an error, the response SHALL contain the following parameter:
          <ul>
            <li>Error Code: A error code that provides the client with clear guidance on 
              what must be corrected to successfully complete the request.</li>
          </ul>
          </p>
        </section>

        <section id="access-token-response-consent-required">
          <h2>Access Token Response — Consent Required</h2>

        <section id="access-token-response-to-initial-access-token-request">
          <h2>Access Token Response To Initial Access Token Request</h2>
          <p>
          If access control requires consent from the data owner, an immediate response is not possible.<br>
          In this case, the response to the initial access token request SHALL contain the following parameters:
          <ul>
            <li>Session Handle: A reference identifier for the initial access token request, which the client can use in subsequent inquiry requests.</li>
            <li>Consent Status: There is at this point not any consent status received from the <a>ECF</a>, so the consent status is set to NOT_SET.</li>
          </ul>
          </p>
        </section>

        <section id="access-token-response-to-inquiry-access-token-request">
          <h2>Access Token Response To Inquiry Access Token Request</h2>
          <p>
          There are three responses possible to an inquiry access token request.
          <ol>
            <li>Consent reply not yet received from <a>ECF</a></li>
            If the External Consent Framework (ECF) has not yet provided a consent response, the reply is identical to the initial access token response(see <a href="#access-token-response-to-initial-access-token-request">section 8.3.4.2.1</a>).       
            <li>Negative consent reply from <a>ECF</a></li>
            If the consent reply is negative, the response SHALL contain the following parameter:
              <ul><li>Consent status: The consent was denied, so the consent status is set to NO.</li></ul>
            <li>Positive consent reply from <a>ECF</a></li>
            If the consent reply is positive, the response SHALL contain the following parameters:
              <ul>
                <li><a href="#access-token-def">Access Token</a>: The token to be used in <a href="#client-def">client</a>
                requests to the VISSv3 server for accessing Protected Resources.</li>
                <li>Consent status: The consent was granted, so the consent status is set to YES.</li>
              </ul>
          </ol>
          </p>
        </section>
        </section>
        </section>

        <section id="protected-resource-request">
          <h2>Protected Resource Request</h2>
          <p>
          This is a VISSv3 request including an <a href="#access-token-def">access token</a> as described in general in the
          <a href="#methods">Chapter 5.1 Methods</a>,
          and in detail for various <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#transport-protocols">
          transport protocols</a> in the [[TRANSPORT]] specification.
          The first time a token is submitted in a request, it MUST be included in full. 
          If the server supports access token caching and returns a token handle to the client, 
          then subsequent requests MAY use the token handle instead of the complete access token.
          </p>
        </section>

        <section id="protected-resource-response">
          <h2>Protected Resource Response</h2>
          <p>
          This is a VISSv3 response as described in general in the <a href="#methods">Chapter 5.1 Methods</a>,
          and in detail for various <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#transport-protocols">
          transport protocols</a> in the [[TRANSPORT]] specification.
          It is identical to the response for an unprotected resource request, with no differences in structure or content.
          </p>
        </section>
      </section>

      <section id="actors">
        <h2>Actors</h2>

      <dfn id="client-def"></dfn>
      <section id="client">
        <h2>Client</h2>
        <em>This section is non-normative.</em>
        <p>
          The client is an abstract representation of three sub-actors:
          <ul>
            <li><a href="#device-roles-def">Device</a>: It is responsible for running the applications that make requests to the VISSv3 server.</li>
            <li><a href="#application-roles-def">Application</a>: It runs requests on behalf of the user.</li>
            <li><a href="#user-roles-def">User</a>: It delegates access rights to the application.</li>
          </ul>
          All information related to the client is encoded in the <a href="#client-context-def">context</a> of the request.
        </p>
      </section>

      <dfn id="access-grant-server-def"></dfn>
      <section id="access-grant-server">
        <h2>Access Grant Token Server</h2>
        <em>This section is non-normative.</em>
        <p>
          The Access Grant Token Server is responsible for issuing <a href="#access-grant-token-def">access grant tokens</a> to
          <a href="#client-def">clients</a>.<br>
          Depending on the capabilities of the <a href="#client-def">client</a>, the specification supports two types of
          <a href="#access-grant-token-def">access grant tokens</a> as short-term and long-term <a href="#access-grant-token-def">access grant tokens</a>.<br>
          Long-term <a href="#access-grant-token-def">access grant tokens</a>,
          are recommended for <a href="#client-def">clients</a> that support public key cryptographic primitives (e.g., key pair generation and digital signatures),
          and that have access to a trusted execution environment (TEE) where private keys are securely protected from the regular execution environment.
          Short-term <a href="#access-grant-token-def">access grant tokens</a> are intended for clients without such cryptographic capabilities.
          However, due to their shorter expiry times, they require the client to contact the Access Grant Token Server more frequently
          when requesting an <a href="#access-token-def">access token</a> from the <a href="#access-token-server-def">Access Token Server</a>.<br>
          <br>A <a href="#client-def">client</a> request to the Access Grant Token Server SHALL contain:
          <ul>
            <li>A <a href="#client-context-def">client context</a>.</li>
            <li>A set of <a href="#proof-of-possession-def">proofs</a>.</li>
            <li>A VIN(Vehicle Identification Number).</li>
            <ul>
              <li>If the <a href="#client-def">client</a> and the <a href="#access-grant-server-def">Access Grant Token Server</a> are both deployed in-vehicle, the VIN MAY be omitted.</li>
              <li>In all other cases, the VIN SHALL be included.</li>
              <li>When the VIN is included in the request, the vehicle identity (vin) claim SHALL be present in the resulting <a href="#access-grant-token-def">access grant token</a>.</li>
            </ul>

          </ul>
          If the <a href="#client-def">client</a> requires a long-term <a href="#access-grant-token-def">access grant token</a>,
          then the request shall also contain:
          <ul>
            <li>A public key.</li>
              <ul><li>The public key MUST be generated by <a href="#client-def">client</a>,
                and the associated private key MUST be securely controlled by the <a href="#client-def">client</a>.</li></ul>
          </ul>
          The VIN provided must identify the vehicle that the <a href="#client-def">client</a> intends to access.<br>
          The <a href="#client-context-def">client context</a> contains all relevant information about the client,
          i.e. for each of the three sub-actors that the <a href="#client-def">client</a> represents.<br>
          The <a href="#proof-of-possession-def">proofs</a> are used by the server to validate the <a href="#client-context-def">client context</a>.<br><br>

          The <a href="#access-grant-server-def">Access Grant Token Server</a> is responsible for:
          <ul>
            <li>Verifying the <a href="#client-context-def"> client context</a>, and determining if the requested roles can be granted.</li>
            <li>Validating that the vehicle identified by the VIN belongs to the ecosystem and is accessible.</li>
            <li>Issuing the <a href="#access-grant-token-def">access grant token</a>.</li>
          </ul>
          The <a href="#proof-of-possession-def">proofs</a> may include certificates issued by a trusted Certificate Authority (CA) known to the <a href="#access-grant-server-def">Access Grant Token Server</a>.
          For example, users may authenticate themselves using X.509 identity certificates and roles may be issued using attribute certificates.
          In such cases, as part of the authentication protocol,
          the <a href="#access-grant-server-def">Access Grant Token Server</a> SHALL also validate the certificates signatures.<br>
          The <a href="#access-grant-server-def">Access Grant Token Server</a> may contact the <a href="#ecosystem-manager-def">ecosystem manager</a> to validate the VIN.<br>
          Details regarding <a href="#access-grant-token-def">access grant token</a> generation are defined in the corresponding chapter.          .
        </p>
          </p>
        </section>

      <dfn id="access-token-server-def"></dfn>
      <section id="access-token-server">
        <h2>Access Token Server</h2>
        <em>This section is non-normative.</em>
        <p>
        After a successful interaction with the <a href="#access-grant-server-def">Access Grant Token Server</a>, the <a href="#client-def">client</a>
        SHALL request an <a href="#access-token-def">access token</a> from the Access Token Server.
        The <a href="#client-def">client</a> request SHALL include at least the following two parameters:
          <ul>
            <li><a href="#access-grant-token-def">Access Grant Token</a>.</li>
            <li><a>Purpose</a>.</li>
          </ul>
        If the <a href="#client-def">client</a> uses a long-term <a href="#access-grant-token-def">access grant tokens</a>(i.e., one that includes a public key), 
        it MUST also include a <a href="#proof-of-possession-def">proof of possession</a> for the corresponding private key in the request.<br>
        The <a>purpose</a> specified in the request MUST be supported by the <a href="#ecosystem-manager-def">ecosystem manager</a>, 
        and therefore listed in the official <a href="#purpose-list-def">purpose list</a>.
        The <a href="#purpose-list-def">purpose list</a> defines the set of accessible signals associated with each <a>purpose</a>,
        thereby enforcing the principle of least privilege.<br><br>
        The <a href="#access-token-server">Access Token Server</a> is responsible for:
          <ul>
            <li>Validating the the <a href="#access-grant-token-def">access grant token</a>.</li>
            <li>Verifying that the <a href="#client-context-def">client context</a> is authorized for the requested <a>purpose</a>.</li>
            <li>Creating and issuing the <a href="#access-token-def">access token</a>.</li>
          </ul>
        The validation of the <a href="#access-grant-token-def">access grant token</a> consists of at least the following:
          <ul>
            <li>Signature verification (using the public key of the <a href="#access-grant-server-def">Access Grant Token Server</a>).</li>
            <li>Expiry time check.</li>
          </ul>
        For long-term <a href="#access-grant-token-def">access grant tokens</a>, the server MUST additionally verify the
        <a href="#proof-of-possession-def">proof of possession</a>, using the public key contained in the token.<br>
        The <a href="#access-grant-token-def">access grant token</a> signature validation is done with the
        <a href="#access-grant-server-def">Access Grant Token Server</a> public key.
        <br>
        To accommodate minor clock drift and network latency,
        the expiry time SHOULD include a reasonable margin, possibly up to tens of seconds.<br>
        If a vehicle identity (VIN) claim is present in the <a href="#access-grant-token-def">access grant token</a>,
        it SHALL also be included in the access token.<br>
        If the <a href="#client-context-def">client context</a>, as defined in the <a href="#access-grant-token-def">access grant token</a>,
        does not match any of the roles permitted for the specified <a>purpose</a> in the <a href="#purpose-list-def">purpose list</a>,
        then the <a href="#client-def">client</a> request for an <a href="#access-token-def">access token</a> MUST be denied.<br>
        </p>
      </section>

      <section id="access-control-server">
        <h2>Access Control Server</h2>
        <p>
        The VISSv3 server MUST support validation of <a href="#access-token-def">access tokens</a>.
        The functionality required for this validation is described in this chapter.
        This includes, at a minimum, validation of the following elements:
          <ul>
            <li>Token Signature.</li>
            <li>Token Expiry Time.</li>
          </ul>
          If a vehicle identity claim (vin) is present in the token, then it MUST be validated to match the identity of this vehicle.<br>
          If any of these validations fail, the server MUST reject the access request.<br>
          Token signature validation MAY be delegated to the <a href="#access-token-server-def">Access Token Server</a>,
          provided that a secure communication link can be established.
          If delegation is not possible, then a pre-provisioned common secret may be shared with the <a href="#access-token-server-def">Access Token Server</a>,
          or PKI-based solutions MAY be used.<br>
          The VISSv3 server SHALL have access to a secure system time, which cannot be modified by actors without system acknowledged credentials.
          Time validation MAY allow for synchronization inaccuracies, typically within a range of tens of seconds.<br>
          After a successful token validation, the server MUST verify that the scope of the token is compatible with the request:<br>
          <ul>
            <li>If the scope claim of the <a href="#access-token-def">access token</a> contains a <a>purpose</a> short-name,
          successful validation requires that all the nodes addressed by the path in the request MUST
          be matched by the paths associated with the <a>purpose</a> in the <a href="#purpose-list-def">purpose list</a> .</li>
            <li>If the scope claim of the <a href="#access-token-def">access token</a> contains a explicit list of signals,
          successful validation requires that all the nodes addressed by the path in the request MUST
          be matched by the one of the signals included in the token.<br></li>
          </ul>
          Validation of the <a href="#device-roles-def">device</a> and <a href="#application-roles-def">application</a> roles MAY include techniques such as:
          <ul>
            <li>MAC Address Checks.</li>
            <li>message Round-trip Measurements.</li>
          </ul>
          The result of access permission validation MUST have the outcome shown in the table below,
          when comparing the type of the <a href="#client-def">client</a> request with the access control mode either in the
          <a href="#purpose-list-def">purpose list</a> or the explicit signals that are associated to the scope claim in the <a href="#access-token-def">access token</a>.
          If the <a href="#client-def">client</a> request contains multiple signals, and any one of them fails the validation,
          then the entire request MUST be rejected.<br><br>
          <table class="simple">
          <thead>
            <tr><th>Permission</th><th>read-only</th><th>read-write</th></tr>
          </thead>
          <tbody>
            <tr>
              <th rowspan="4">get<br>set<br>subscribe</th>
            </tr>
            <tr><td>Ok</td><td>Ok</td></tr>
            <tr><td>Nok</td><td>Ok</td></tr>
            <tr><td>Ok</td><td>Ok</td></tr>
          </tbody>
          </table>
        </p>
        <p>
          The <a href="#access-token-def">access token</a> needs to be refreshed periodically, which is determined by the expiry time.
          If the <a href="#access-grant-token-def">access grant token</a> that the <a href="#client-def">client</a> originally used to obtain the now-expired
          <a href="#access-token-def">access token</a> is still valid,
          then the <a href="#client-def">client</a> can revisit the <a href="#access-token-server-def">Access Token Server</a> with this
          <a href="#access-grant-token-def">access grant token</a> to obtain a new <a href="#access-token-def">access token</a>.<br>
          However, if the <a href="#access-grant-token-def">access grant token</a> is also expired, then the <a href="#client-def">client</a> MUST obtain a new
          <a href="#access-grant-token-def">access grant token</a> first,
          before revisiting the <a href="#access-token-server-def">Access Token Server</a>.<br>
          The server SHOULD support caching of a limited number of <a href="#access-token-def">access tokens</a>.
          The <a href="#access-token-def">access token</a> MUST be added to the cache after a first successful request and
          it MUST be removed once they expire.
          If an access token is cached then the server SHALL return a token handle of at least 24 bytes long.
          The client MAY then use this instead of the complete access token in following requests that require this access token.
          If the client decides to include the access token handle in a request, the server must then fetch the corresponding access token from the cache,
          and verify its validity before deciding to grant the request.<br>
          The server MAY decide to remove any token from the cache at any time. If the client later references a removed token using its handle, the server WILL return
          a "401, invalid_token" error, and the client MUST resend the whole <a href="#access-token-def">access token</a>.<br>
          For any <a href="#client-def">client</a> request denied due to access control,
          the VISSv3 server MUST return a "401, invalid_token" error message.
        </p>
      </section>

      <dfn id="resource-owner-def"></dfn>
      <section id="resource-owner">
        <h2>Resource Owner</h2>
        <em>This section is non-normative.</em>
        <p>
        The resource owner is typically the owner and/or driver of the vehicle. If consent is required to grant access to the protected resource,
        then the request SHOULD be directed to the resource owner. The process of obtaining consent is out of scope for this specification.
        </p>
      </section>

      <dfn id="ecosystem-manager-def"></dfn>
      <section id="ecosystem-manager">
        <h2>Ecosystem Manager</h2>
        <em>This section is non-normative.</em>
        <p>
        The Ecosystem manager is the entity responsible for managing the access control system.
        This typically includes managing the <a href="#access-grant-server-def">Access Grant Token Server</a>,
        and the <a href="#access-token-server-def">Access Token Server</a>, maintaining the Policy documents,
        and ensuring that a PKI domain is available for use by other actors in the ecosystem.

        .
        </p>
      </section>
      </section>

      <section id="credentials">
        <h2>Credentials</h2>
        <p>
        </p>

        <section id="client-authentication">
          <h2>Client Authentication</h2>
          <em>This section is non-normative.</em>
          <p>
          The three <a href="#client-def">client</a> sub-actors must provide authentication credentials to the
          <a href="#access-grant-server-def">Access Grant Token Server</a>.
          These credentials MAY be certificates issued by a Certificate Authority (CA) recognized by
          <a href="#access-grant-server-def">Access Grant Token Server</a>.<br>
          The details of these interactions are out of scope for this specification.
        </section>

        <dfn id="access-grant-token-def"></dfn>
        <section id="access-grant-token">
          <h2>Access Grant Token</h2>
          <em>This section is non-normative.</em>

          <section id="ags-signed-agtoken">
            <h2>Short-Term Access Grant Token</h2>
            <p>
          The short-term access grant token SHALL include the following claims in both the header and the payload.
          All claims are mandatory, except for the vehicle identity (vin) claim, which is optional.<br>
          <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>
          {
            "alg": "ES256",
            "typ": "JWT"
          },
          {
            "vin": "vehicle-id",
            "iat": 1609452095,
            "exp": 1609459199,
            "clx": "user+app+dev",
            "aud": "covesa.global/VISSv3",
            "jti": "5967e92e-40e8-5f39-892d-cc0da890db1d"
          }
          </pre>
          <ul>
            <li>The alg (algorithm) claim SHALL be set to a valid RSA or ECDSA algorithms according to [[RFC7518]].</li>
            <li>The typ (type) claim SHALL be set to "JWT".</li>
            <li>The vin (vehicle identity) claim MAY be present or not, depending on input to the
              <a href="#access-grant-server-def">Access Grant Token Server</a>.</li>
            <li>The iat (issued at) claim SHALL be set to the Unix timestamp representing the token’s issuance time.</li>
            <li>The exp (expiry) claim SHALL be set to the Unix timestamp when the token expires.</li>
            <li>The clx (<a href="#client-context-def">Client context</a>) SHALL be set to the client’s assigned role triplet 
              (user, app, device), with each role separated by a plus sign (+).</li>
            <li>The aud (audience) claim SHALL be set to the URL: "covesa.global/VISSv3".</li>
            <li>The jti (JSON Web Token identity) claim SHALL be set to a UUID that is unique within the domain controlled by the
              <a href="#ecosystem-manager-def">ecosystem manager</a>.</li>
          </ul>
            </p>
          </section>

          <section id="client-signed-agtoken">
            <h2>Long Term Access Grant Token</h2>
            <p>
          Except for the vehicle identity (vin) claim, which is optional,
          the long term access grant token SHALL include the following claims in both the header and the payload.<br>
          <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>
          {
            "alg": "ES256",
            "typ": "JWT"
          },
          {
            "vin": "vehicle-id",
            "iat": 1609452095,
            "exp": 1609459199,
            "clx": "user+app+dev",
            "pub": client_pub_key,
            "aud": "covesa.global/VISSv3",
            "jti": "5967e92e-40e8-5f39-892d-cc0da890db1d"
          }
          </pre>
          <ul>
            <li>The alg (algorithm) claim SHALL be set to a valid RSA or ECDSA algorithms according to [[RFC7518]].</li>
            <li>The typ (type) claim SHALL be set to "JWT".</li>
            <li>The vin (vehicle identity) claim MAY be present or not, depending on input to the
              <a href="#access-grant-server-def">Access Grant Token Server</a>.</li>
            <li>The iat (issued at) claim SHALL be set to the Unix timestamp representing the token’s issuance time.</li>
            <li>The exp (expiry) claim SHALL be set to the Unix timestamp when the token expires.</li>
            <li>The clx (<a href="#client-context-def">Client context</a>) SHALL be set to the client’s assigned role triplet 
              (user, app, device), with each role separated by a plus sign (+).</li>
            <li>The pub (public key) claim SHALL be set to the <a href="#client-def">client</a>'s public key provided in the
              <a href="#access-grant-request-def">access grant request</a>, using the JSON Web Key (JWK) data structure [[RFC7517]].</li>
            <li>The aud (audience) claim SHALL be set to the URL: "covesa.global/VISSv3".</li>
            <li>The jti (JSON Web Token identity) claim SHALL be set to a UUID that is unique within the domain controlled by the
              <a href="#ecosystem-manager-def">ecosystem manager</a>.</li>
          </ul>
            </p>
          </section>
        </section>

        <dfn id="access-token-def"></dfn>
        <section id="access-token">
          <h2>Access Token</h2>
          <p>
          Except for the vehicle identity (vin), and client context (clx) claims, which are optional,
          the access token SHALL include the following claims in both the header and the payload.<br>
          <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>
          {
            "alg": "HS256",
            "typ": "JWT"
          },
          {
            "vin": "vehicle-id",
            "iat": 1609452095,
            "exp": 1609459199,
            "scp": "PurposeX" || signal-set,
            "clx": "user+app+dev",
            "aud": "covesa.global/VISSv3",
            "jti": "5967e93f-40f9-5f39-893e-cc0da890db2e"
          }
          </pre>
          <ul>
            <li>The alg (algorithm) claim SHALL be set to a valid algorithms according to [[RFC7518]].</li>
            <li>The typ (type) claim SHALL be set to "JWT".</li>
            <li>The vin (vehicle identity) claim MAY be present or not, depending on input to the
              <a href="#access-grant-server-def">Access Grant Token Server</a>.</li>
            <li>The iat (issued at) claim SHALL be set to the Unix timestamp representing the token’s issuance time.</li>
            <li>The exp (expiry) claim SHALL be set to the Unix timestamp when the token expires.</li>
            <li>The scp (scope) claim SHALL be set to either a <a href="#purpose-list-def">purpose list</a> short name,
              which logically links to the signal scope as defined in the <a href="#purpose-list-def">purpose list</a>,
              or to a set of signals that the token permits access to.
              Each signal is defined as a JSON object containing the signal path, and the signal permission as shown below.<br>
              {"path":"vss-path", "access_permission":"permission"}<br>
              If the scope claim is set to a purpose, the client context claim MUST be present in the token.</li>
            <li>The clx (<a href="#client-context-def">Client context</a>) SHALL be set to the client’s assigned role triplet 
              (user, app, device), with each role separated by a plus sign (+).</li>
            <li>The aud (audience) claim SHALL be set to the URL: "covesa.global/VISSv3".</li>
            <li>The jti (JSON Web Token identity) claim SHALL be set to an unguessable UUID that is unique within the domain controlled by the
              <a href="#ecosystem-manager-def">ecosystem manager</a>.</li>
          </ul>
          </p>
        </section>

        <dfn id="proof-of-possession-def"></dfn>
        <section id="proof-of-possession">
          <h2>Proof of Possession</h2>
          <em>This section is non-normative.</em>
          <p>
            Long-term <a href="#access-grant-token-def">access grant tokens</a> MUST to be accompanied by a Proof of Possession (PoP)
            for the private key corresponding to the public key included in the <a href="#access-grant-token-def">access grant token</a>.
            This requirement enables a longer validity for this kind of tokens, ranging from a several days to a even a year.
            By adding the PoP, an eavesdropper is prevented to reuse an <a href="#access-token-def">access token</a> request,
            impersonating the client. Without a PoP, the longer the validity of an <a href="#access-grant-token-def">access grant token</a>,
            the higher the risk an attacker could intercept and reuse it.
            PoP for JWT are defined in [[RFC7800]]. In essence, PoP enables the requester to proof to the server that it has access to a private key, without disclosing it.
            Traditionally, this is done by the server generating a random challenge, or nonce, and ask the client to sign it with its private key.
            Along with the public key, the server would be able to verify the PoP.
            This scheme would require an extra step in the protocols, where the client ask for the nonce.
          </p><p>
            To avoid this extra step, the client MAY generate the nonce itself. In this case, the server must ensure that nonces are not reused.
            While logging previously used nonces on the server may work in small-scale environments,
            a more scalable approach is to use an incremental nonce based on a timestamp.
            One of the drawbacks of this proposal is that the server has no means to check whether the PoP has been precomputed or not.
            However, this is irrelevant from the eavesdropper point of view.
          </p><p>
            If PoP freshness is a critical requirement, the nonce could be derived from a public source of randomness,
            such as the <a href="https://www.cloudflare.com/leagueofentropy/">Leage of Entropy</a> or
            <a href="https://csrc.nist.gov/projects/interoperable-randomness-beacons">Interoperable Randomness Beacons</a>.
            That would provide the server a mean to check freshness of the PoP but on the other hand,
            it would require the client to access the public source of randomness every time it needs to create a PoP
            which is against the main design goals for the long term <a href="#access-grant-token-def">access grant token</a>.
              </li>
            </ul>
          </p>
        </section>
      </section>

      <dfn id="client-context-def"></dfn>
      <section id="client-context">
        <h2>Client Context</h2>
        <em>This section is non-normative.</em>
        <p>
        The client context contains a <a href="#client-def">client</a> actor that is characterized by three sub-actors:
          <ul>
            <li>The <a href="#user-roles-def">user</a> of the application.</li>
            <li>The <a href="#application-roles-def">application</a>.</li>
            <li>The <a href="#device-roles-def">device</a>.</li>
          </ul>
          Each of these sub-actors is in turn characterized by a role,
          building on the concept of a <a href="https://en.wikipedia.org/wiki/Role-based_access_control">Role Based Access Control (RBAC) model</a>.
          The set of these three roles is called the Client context.<br>
          VISSv3 specifies a rudimentary list of roles for each sub-actor, it is expected that these lists are augmented by the
          <a href="#ecosystem-manager-def">ecosystem manager</a>, hopefully in a cooperative effort.<br>
          Using an RBAC model provides the following main purposes in the VISSv3 access control model:
          <ul>
            <li>Input to the <a href="#access-grant-server-def">Access Grant Token Server</a> during
            <a href="#client-def">client</a> authentication process.</li>
            <li>Input to the <a href="#access-token-server-def">Access Token Server</a> during <a>purpose</a> validation.</li>
          </ul>
        During authentication, the <a href="#access-grant-server-def">Access Grant Token Server</a> MAY need to authenticate each sub-actor individually.
        For the <a href="#access-grant-server-def">Access Grant Token Server</a> to decide on which authentication method to use per sub-actor
        can be quite complex. However, this complexity can be reduced if the <a href="#client-def">client</a> explicitly requests specific roles for each sub-actor.
        Following the principle of least priviledge, a <a href="#client-def">client</a> should not have access to more vehicle signals than necessary.
        This is achieved by the <a href="#purpose-list-def">purpose list</a>, that assigns only the for the
        <a>purpose</a> relevant signals to the <a href="#client-def">client</a>.
        </p>

        <dfn id="user-roles-def"></dfn>
        <section id="user-roles">
          <h2>User Roles</h2>
          <p>
          VISSv3 specifies the following minimum set of roles for users:
          <ul>
            <li>OEM</li>
            <li>Dealer</li>
            <li>Independent</li>
            <li>Owner</li>
            <li>Driver</li>
            <li>Passenger</li>
          </ul>
          An OEM user is anyone who represents the vehicle manufacturer (OEM).<br>
          A Dealer user represents an OEM-affiliated organization that provides vehicle sales and workshop services.<br>
          An Independent user represents a non-OEM-affiliated organization offering aftermarket services for the vehicle.<br>
          An Owner user is the representative of the organization that owns the vehicle.<br>
          A Driver user is anyone operating the vehicle.<br>
          A Passenger user is anyone riding in the vehicle without driving it.<br>
          </p>
        </section>

        <dfn id="application-roles-def"></dfn>
        <section id="application-roles">
          <h2>Application Roles</h2>
          <p>
          VISSv3 defines the following minimum set of roles for applications:
          <ul>
            <li>OEM</li>
            <li>Third Party</li>
          </ul>
          An OEM application role is used for applications that are pre-installed in the vehicle by the OEM, or later OEM-provisioned to the vehicle.<br>
          A Third party application role is used for applications that
	  are approved by automotive manufacturer for vehicle deployment, but developed by a third party.<br>
          </p>
        </section>

        <dfn id="device-roles-def"></dfn>
        <section id="device-roles">
          <h2>Device Roles</h2>
          <p>
          VISSv3 defines the following minimum set of roles for devices:
          <ul>
            <li>Vehicle</li>
            <li>Nomadic</li>
            <li>Cloud</li>
          </ul>
          A Vehicle device role is one that is deployed within the vehicle, such as in the center stack ECU.<br>
          A Nomadic device role refers to a mobile device (e.g., smartphone or laptop) that connects to the vehicle via short-range communication (e.g., Bluetooth or Wi-Fi).<br>
          A Cloud device role is hosted outside the vehicle, typically in a data center, and connects to the vehicle via long-range communication, such as cellular networks.<br>
          </p>
        </section>
      </section>

      <section id="policy-documents">
        <h2>Policy Documents</h2>
        <em>This section is non-normative.</em>
        <p>
        The Policy documents are typically owned and created by the <a href="#ecosystem-manager-def">ecosystem manager</a>.
        They MUST be handled securely to protect their integrity.
        The <a href="#ecosystem-manager-def">ecosystem manager</a> SHALL securely provision them to the
        <a href="#access-token-server-def">Access Token Servers</a> in the access control ecosystem.
        </p>

          <dfn id="purpose-list-def"></dfn>
          <section id="purpose-list">
            <h2>Purpose List</h2>
            <p>
        A <a href="#client-def">client</a> SHALL provide a <a>purpose</a> as input when requesting an <a href="#access-token-def">access token</a>.
        To support this, a predefined list of supported purposes MUST exist, allowing the client to select the <a>purpose</a> that matches its use case.
        The <a href="#ecosystem-manager-def">ecosystem manager</a> SHALL provide a mechanism for <a href="#client-def">clients</a>
        to access and review this list.<br>
        Each entry in the purpose list includes the following:
        <ul>
          <li>A short description of the purpose, which the <a href="#client-def">client</a> uses as input when requesting an <a href="#access-token-def">access token</a>.</li>
          <li>A long description, which MAY be used in consent dialogs when applicable.</li>
          <li>A list of valid <a href="#client-context-def">client context</a> (i.e., combinations of user, app, and device roles) that may be granted access for this purpose.</li>
          <li>A list of signals accessible under this purpose, along with the associated access permissions and any consent requirements.</li>
        </ul>
        The purpose list SHALL be formatted in JSON, as illustrated below:
        <pre><code>
        {"purposes":
            [{"short": "fuel-status",
            "long": "Fuel level and remaining range.",
            "contexts":[{"user":"Independent","app":["OEM", "Third party"], "device":"Cloud"}, {"user":"Owner", "app":"Third party", "device":"Nomadic"}, {"user":"Driver", "app":"OEM", "device":"Vehicle"}],
            "signal_access":
                [{"path": "Vehicle.Powertrain.FuelSystem.Level", "access_permission": "read-only"},
                {"path": "Vehicle.Powertrain.FuelSystem.Range", "access_permission": "read-only"}]
            },
            {}]
        }
        </code></pre>
        The purpose list SHALL be securely provisioned to the <a href="#access-token-server-def">Access Token Server</a>.
        The provisioning protocol is out of scope for this specification.
        If the <a href="#access-token-server-def">Access Token Server</a> does not possess a valid purpose list, 
        it MUST reject all <a href="#access-token-def">access tokens</a> requests.
            </p>
          </section>

          <section id="scope-list">
            <h2>Scope List</h2>
            <p>
              The Scope List defines the VSS tree nodes to which access SHALL be prohibited for specific
            <a href="#client-context-def">client context</a>, regardless of whether the <a href="#client-def">client</a> 
            possesses a valid <a href="#access-token-def">access token</a>.<br>
            In addition to access control, the scope list MAY also be used to restrict metadata visibility when a client sends a signal discovery request.<br>
            Each entry in the list contains:
            <ul>
              <li>A list of node paths to be excluded, and</li>
              <li>A list of <a href="#client-context-def">client contexts</a> (i.e., sub-actor role triplets) for which this exclusion applies.</li>
            </ul>
            The scope list MAY include an entry for a context with all three Roles set to "Undefined".
            The no-access scope of this entry shall then be used for signal discovery requests where no token is included.
            An entry in the no_access array that addresses a branch results in no access to the subtree of this branch.<br>
            The scope list SHALL be formatted in JSON, as illustrated below:
        <pre><code>
        {"scope":
            [{"contexts":[ { "user":["Driver", "Passenger"], "app":"Third party", "device":"Vehicle"}, { } ],
            "no_access":
                ["Vehicle.Drivetrain.Transmission.Speed",
                "Vehicle.CurrentLocation.Latitude",
                "Vehicle.CurrentLocation.Longitude"]
            },
            {}]
        }
        </code></pre>
        The scope list SHALL be securely provisioned to the <a href="#access-token-server-def">Access Token Server</a>.
        The provisioning protocol is out of scope for this specification.
        If the <a href="#access-token-server-def">Access Token Server</a> does not have access to a scope list, it SHALL NOT apply any scope restrictions for
        <a href="#client-context-def">client context</a>.
            </p>
          </section>
      </section>

      <section id="access-control-selection">
        <h2>Access Control Selection</h2>
        <em>This section is non-normative.</em>
        <p>
        This chapter describes a complementary feature to the access control model: 
        the ability to selectively apply access control to specific parts of the VSS tree.
        This functionality is useful in cases where:
        <ul>
          <li>Not all nodes are considered to require access control, or</li>
          <li>Write-only validation is sufficient instead of full read-write validation for certain nodes.</li>
        </ul>

        This functionality requires that the <a href="#access-token-def">access token</a> specifies whether the access permission granted to the
        <a href="#client-def">client</a> to a signal is read-only, or read-write.
        It also requires that the metadata for the node in the VSS tree contains data specifying whether
        the access control verification should be carried out only for write request, or for both read and write requests.<br>
        The former requirement is realized as described in earlier chapters by that the <a href="#access-token-def">access token</a>
        scope claim links to a <a>purpose</a> where the signals and their respective access permission are found.<br>
        The latter requirement is realized by adding to nodes in the VSS tree the key-value pair "validate":'access-control-mode',
        where 'access-control-mode' is either the string "write-only", or "read-write".<br>
        <figure id="fig-access-control-selection">
          <img src="images/access-control-selection.jpg" alt="Access control selection tagging.">
          <figcaption> <span class="fig-title">Access control selection tagging.</span></figcaption>
        </figure>
        The figure above shows an example where both read and write requests to the three leftmost leaf nodes will be access controlled,
        while the two rightmost leaf nodes only will be access controlled for write requests.
        An inheritance rule leads to that any nodes below a tagged node are assigned the same access control, if they are untagged.<br>
        This metadata is not likely to be applied to the standardised VSS tree,
        as different implementers of this standard may have different views on which nodes to apply it to.
        Instead it is anticipated that it is applied at a "deployment" stage, possibly using the VSS layering concept.<br>
        The inheritance model, which says that if access-control-mode data is added to a node,
        then all nodes in the subtree for which this node is the root inherits the setting,
        unless there is access-control-mode data added to any node in this subtree,
        makes possible a reduction of the number of nodes this metadata have to be added to.<br>
        This allows for example an entire VSS tree to be assigned an access-control-mode by merely applying it in the root of the tree.<br>
        The figure below shows an overview of the access control selection model,
        and a table showing the required access control tagging of a node for the VISSv3 server to grant the requested access.
        <figure id="fig-access-control-selection-model">
          <img src="images/access-control-selection-model.jpg" alt="Access control selection model.">
          <figcaption> <span class="fig-title">Access control selection model.</span></figcaption>
        </figure>
        If the VSS tree used by a VISSv3 server contains access control selection tags,
        the server MUST support their usage as described in this chapter.<br>
        If access control selection tags are not present, the server MAY implement access control for the entire tree.<br>
        </p>
      </section>
    </section>

    <section id="consent-support">
      <h2>Consent support</h2>
      <em>This section is non-normative.</em>
      <p>
      The handling of consent involves both vehicle-side and cloud-side architectural subsystems, which are out of scope for VISSv3.
      However, a VISSv3 vehicle server is capable of enforcing consent decisions, i. e. to allow or block access to requested data.
      This capability can be utilized in a model where the server receives consent results from an <a>ECF</a> and uses that information to either grant client requests,
      or not, for data that is consent protected. How the <a>ECF</a> obtains the user’s consent status is out of scope for this specification.
      A secure local communication channel SHALL exist between the <a>ECF</a> and the server as shown in the figure below.
      This channel allows the server to inquire about consent status for data requested by the client.
      <figure id="fig-consent-architecture">
        <img src="images/consent-architecture.jpg" alt="Consent architecture.">
        <figcaption> <span class="fig-title">Consent architecture.</span></figcaption>
      </figure>
      The <a>ECF</a> is responsible for the lifecycle management of consent status for all data managed by the server.
      This includes operations such as initialization, event-based updates, and removal of consent status.<br>
      The consent status can be set to any of the following values:<br>
        <ul>
            <li>NOT_SET: The server MUST request the <a>ECF</a> for the status. Unless an immediate <a>ECF</a> response is given,
            the server MUST deny any client request with an error code that shows the reason.</li>
            <li>NO: The server MUST deny any client request with an error code that shows the reason.</li>
            <li>IN_VEHICLE: The server SHALL serve the client request. The client is not allowed to off-board the data.</li>
            <li>YES: The server SHALL serve the client request. The client is allowed to off-board the data.</li>
        </ul>
      It shall be possible for the <a>ECF</a> to cancel a valid consent, which shall lead to the consent status being set to NOT_SET.
      Any consequences to the data provided to the client prior to the cancelling is out of scope for this specification.<br>
      In the case of a client request requiring a consent for data to be returned, it is the responsibility of the
      <a href="#access-token-server-def">Access Token Server</a> to obtain it from the <a>ECF</a> during the dialogue with a client requesting an access token.
      This is done by issuing a request to the <a>ECF</a> which SHALL contain the following information:
        <ul>
            <li>The requested data.</li>
            <li>The purpose of the request.</li>
            <li>The <a href="#client-context-def">client context</a>.</li>
        </ul>
      The response from the <a>ECF</a> SHALL contain:
        <ul>
            <li>Consent Status.</li>
        </ul>
      If the received consent status is set to NO or NOT_SET, then the Access Token Server must not provide a valid access token to the requesting client.
      The server must store the consent status that it receives from the <a>ECF</a>, together with the data from the request for the duration of the associated service,
      or until a consent cancellation is received.<br>
      Whether a server shall take action to obtain a consent or not shall be signalled in the VSS tree.
      This is done by tagging appropriate nodes in the VSS tree extending the model used for access control selection.
      The key-value pair used for tagging of access control is suffixed with "+consent" as shown in the example below:
        <ul>
            <li>"validate":"read-write+consent"</li>
        </ul>
      The consent tagging follows the same inheritance rules as defined for the access control tagging.
      </p>

      <section id="external-consent-framework-interface">
        <h2>External Consent Framework Interface</h2>
        <p>
         A server receiving a client request that involves obtaining a consent status SHALL send a request to the <a>ECF</a>
         on which it SHALL receive a response containing the consent status.
         The request SHALL contain the data from the list in the previous chapter.
         The response SHALL contain the data shown in the table above.
         This communication SHALL be carried out using a secure channel (e.g., TLS).
        </p>
      </section>
    </section>

    <section id="json-schema" class="appendix">
          <h2>JSON Schema</h2>
          <p>
          The primary payloads that are sent over any transport protocol SHALL conform with the JSON schema in this appendix,
          unless otherwise specified in the VISSv3 [[TRANSPORT]] or VISSv3 [[PAYLOAD ENCODING]] specifications.<br>
          </p>
              <pre><code>
              <embed type="text/json" src="resources/vissv3.0-schema.json" width="700" height="500">
              </code></pre>
    </section>

    <section id="server-capabilities" class="appendix">
        <h2>Server Capabilities</h2>
        <p>
        A client that intends to connect to a server may be interested in what capabilities the server offers.
        The server shall expose this information via a dedicated Server tree, which the client can access to discover supported optional features.
        However, for the client to retrieve this information, it must have information about at least one transport protocol that the server supports.
        The VISS API should not make any assumptions on the communication network topology.
        Therefore it should not mandate any transport protocol, instead it should assume that a client can obtain necessary information via out-of-band mechanisms
        to configure its communication in order to successfully connect to the vehicle server.
        How that is done is out of scope for this specification,
        but as an example a solution may be designed around a cloud based repository to which servers can register their capabilities,
        and clients can inquire about obtaining this information.
        When a client has obtained the information how to connect to the server, then the server MUST respond to read requests for data from the Server tree.
        </p>

        <h3>Server Tree</h3>
        <p>
        The Server tree MUST contain the structures listed below. Additional parts are optional.
        Server capabilities that extends this specification, or change anything defined in this specification SHALL be declared in the Server tree.
        </p>
       <ul>
            <li>The root node name MUST be Server.</li>
            <li>The Server node MUST have at least have two children named Support and Config.</li>
            <li>The Support node MUST have at least one child named Protocol.</li>
            <li>The Protocol node MUST be an attribute with a string array datatype with members defining the supported transport protocols.</li>
        </ul>
        Below follows an example of a server capabilities tree.
          <pre><code>
              <embed type="text/yaml" src="resources/server.yml.txt" width="700" height="500">
          </code></pre>
          A feature that is supported in at least one configuration shall be registered on the Support branch.
          The Config branch shall contain the information needed for a client to utilize the feature,
          for all configurations that has the feature supported.
          If a server e. g. supports file transfer upload and download then this shall be found at the Support branch,
          and then on the Config branch it shall be registered for which transport protocol(s) it is supported, and e. g. which port number is then used.
          Configuration data that is given a value in the specification documents does not have to be present on the Config branch.
 
        <h3>Server Feature Naming</h3>
        <p>
        The feature names that are used in the Server tree should for the features described in this specification use the names listed below.

        <table  style="width:80%">
          <tr>
            <th>Protocol</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>ws</td>
            <td>[[TRANSPORT]], Transport Protocols: <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#secure-websocket">chapter 5.1 Secure WebSocket</a></td>
          </tr>
          <tr>
            <td>http</td>
            <td>[[TRANSPORT]], Transport Protocols: <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#https">chapter 5.2 HTTPS</a></td>
          </tr>
          <tr>
            <td>mqtt</td>
            <td>[[TRANSPORT]], Transport Protocols: <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#mqtt">chapter 5.3 MQTT</a></td>
          </tr>
          <tr>
            <td>grpc</td>
            <td>[[TRANSPORT]], Transport Protocols: <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Transport.html#grpc">chapter 5.4 gRPC</a></td>
          </tr>
        </table><br>

        <table  style="width:50%">
          <tr>
            <th>Filter</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>timebased</td>
            <td><a href="#timebased-filter-operation"></a></td>
          </tr>
          <tr>
            <td>change</td>
            <td><a href="#change-filter-operation"></a></td>
          </tr>
          <tr>
            <td>paths</td>
            <td><a href="#paths-filter-operation"></a></td>
          </tr>
          <tr>
            <td>range</td>
            <td><a href="#range-filter-operation"></a></td>
          </tr>
          <tr>
            <td>curvelog</td>
            <td><a href="#curvelog-filter-operation"></a></td>
          </tr>
          <tr>
            <td>history</td>
            <td><a href="#history-filter-operation"></a></td>
          </tr>
          <tr>
            <td>metadata</td>
            <td><a href="#metadata-request"></a></td>
          </tr>
        </table><br>

        <table  style="width:50%">
          <tr>
            <th>File transfer</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>download</td>
            <td>File download to vehicle</td>
          </tr>
          <tr>
            <td>upload</td>
            <td>File upload to client</td>
          </tr>
        </table><br>

        <table  style="width:50%">
          <tr>
            <th>Data compression</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>pathuid</td>
            <td>Static UID path compresion</td>
          </tr>
          <tr>
            <td>pathlocal</td>
            <td>Request local path compression</td>
          </tr>
          <tr>
            <td>timestamplocal</td>
            <td>Response local timestamp compression</td>
          </tr>
        </table>

        <table  style="width:60%">
          <tr>
            <th>Security</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>accesscontrol</td>
            <td><a href="#access-control-model"></a></td>
          </tr>
          <tr>
            <td>consent</td>
            <td><a href="#consent-support"></a></td>
          </tr>
        </table><br>

        <table  style="width:50%">
          <tr>
            <th>Access Control Flow</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>short_term</td>
            <td><a href="#access-control-flows"></a></td>
          </tr>
          <tr>
            <td>long_term</td>
            <td><a href="#access-control-flows"></a></td>
          </tr>
          <tr>
            <td>signalset_claim</td>
            <td><a href="#access-token"></a></td>
          </tr>
        </table><br>

        </p>
    </section>

    <section id="file-transfer" class="appendix">
          <h2>File Transfer</h2>
          <em>This appendix is non-normative.</em><br>
          <p>
          File transfer use cases, where a client either sends or receives a file from the vehicle server,
          can e. g. be a client that wants to push a map to the vehicle (download), or a client that wants to receive a video recording clip from the vehicle (upload).<br>
          File resources represented in the VSS tree can either be read-only, represented by the sensor node type,
          or write-only, represented by the actuator node type. In either case the node datatype MUST be a reference to a struct datatype with the following fixed definition:
          <pre><code>
          typedef FileDescriptor struct {
              name string
              hash string
              uid string
          }
          </code></pre>
          The FileDescriptor name member SHALL have a dot separated file extension that identifies the file format.<br>
          The FileDescriptor hash member SHALL be a SHA-1 hex string encoded hash calculated on the content of the file.<br>
          The FileDescriptor uid member SHALL be a hex string encoded random uint32 value.
          Its value shall be unique for each file transfer session, created by the client for download sessions,
          and by the server for upload sessions.<br><br>
          File transfer from client to server, or in the other direction, follows the model shown in the two sequence diagrams below.
          The server exposes two communication channels, a control channel and a data channel.
          The control channel is the channel where the primary VISSv3.0 payloads are communicated, 
          while the data channel is a channel over which the file transfer data is communicated.
          As is seen in the sequence diagrams the messages sent on the data channel have the same structure in both the download and upload
          sequences, but interchanged between the client and the server.<br>
          The file transfer data message consists of the data from the file, split into appropriate size chunks, and prepended by a header.<br>
          The file transfer status message consists of the uid and messageNo from the received data message, together with the status
          of the reception of that data message.<br>
          The header in the data message consists of the fixed size parameters shown in the list below.
        <ul>
            <li>uid: 4 bytes. A unique identifier for this file transfer session.</li>
            <li>messageNo: 1 byte. Starting at zero and increasing by one for each file chunk that is transferred.
            Maximum value is 254.</li>
            <li>file chunk size: 4 bytes. The size in bytes of this message, including the header size.</li>
            <li>lastMessage: 1 byte. Indiates whether this message is the last message in the transfer of this file.
          The value zero indicates that this is not the last message, while a non-zero value indicates that it is the last message.</li>
        </ul>
        The status message consists of the fixed size parameters shown in the list below.
        <ul>
            <li>uid: 4 bytes. The identifier from the received message.</li>
            <li>messageNo: 1 byte. The message number from the received message.</li>
            <li>status: 1 byte. Indiates whether the message was correctly received or not.
          The value zero indicates that it was correctly received, while a non-zero value indicates that it was not.
          The value 255 is a request for immediate termination of the file transfer session.</li>
        </ul>
        <figure id="fig-file-download">
          <img src="images/file-download-sequence-diagram.png" alt="VISSv3 file download.">
          <figcaption> <span class="fig-title">VISSv3 file download.</span></figcaption>
        </figure>
        The client SET request on the control channel is exemplified below in the primary payload format.
          <pre><code>
{
  "action": "set",
  "path": "Vehicle.Cabin.Infotainment.privateMap",
  "value": {
    "name": "privateMap.kml",
    "hash": "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed",
    "uid": "2d878213"
  }
}
          </code></pre>
        The Ok response would in primary payload format look like:
          <pre><code>
{"action": "set", "ts": "2024-08-20T11:30:00Z"}
          </code></pre>
        If the SET request on the control channel receives an error message then the client shall not issue any SET requests on the data channel.<br>
        The client data message on the data channel consists of a concatenation of the header and the file chunk.
        The server responds to this with a status message.<br>
        If the client data message receives an error status response then the client shall resend the data message with the corresponding message number.
        If this results in another error response for the same message number the client may terminate the download session.
        If the status value is set to 255 the client shall immediately terminate the file download session.<br>
        

        <figure id="fig-file-upload">
          <img src="images/file-upload-sequence-diagram.png" alt="VISSv3 file upload.">
          <figcaption> <span class="fig-title">VISSv3 file upload.</span></figcaption>
        </figure>
        The server GET request on the control channel is exemplified below in the primary payload format.
          <pre><code>
        {"action": "get", "path": "Vehicle.Cabin.DashCam.Clip"}

        </code></pre>
        The Ok response would in primary payload format look like:
        <pre><code>
        {
          "action": "get",
          "data": {
            "path": "Vehicle.Cabin.DashCam.Clip", 
            "dp" {
              "value": {"name": "dashCamClip.mp4", "hash": "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed", "uid": "2d878213"},
              "ts": "2024-08-20T11:30:00Z"
            }
          },
          "ts": "2025-01-09T12:13:14Z"
        }
        </code></pre>
        If the GET request on the control channel receives an error message then the client shall not start the file upload session
        on the data channel by issuing the initial status message.<br>
        The client must issue an initial status message to trigger the server to respond with the first data message,
        in this first status message the message number is set to 255.
        The data message from the server following this status message shall have the message number zero.
        The client shall send a final status message after receiving the last data message from the server.
        If the status is set to zero the server shall respond with only the header from its last message,
        with the chunk size set to zero, thus terminating the file upload session.<br>
        If the server data message receives an error status response then the server shall resend the data message with the corresponding message number.
        If this results in another error response for the same message number the server may terminate the download session.
        If the status value is set to 255 the server shall immediately terminate the file download session.<br><br>
        The receiver of the file should calculate the hash on the received data after the session is concluded
        and compare with the file hash value received on the control channel.
        If they differ the received file is likely corrupt.<br><br>
        The sender of the file may terminate the file transfer session on the data channel by sending only the header by setting the message number to 255, 
        the chunk size to zero, and the last message to non-zero, on which the receiver shall respond with status set to zero.<br><br>
        The node type for the file resource MUST be "actuator" for the download case and "sensor" for the upload case.
        This node must have a fixed datatype,  a struct with the members "name", "hash", and "uid".<br>
        Examples of tree nodes for file download and upload, respectively:
        <pre><code>
        DownloadFile:
          type: actuator
          datatype: Types.Resources.FileDescriptor
          description: File that may be downloaded to the vehicle.

        UploadFile:
          type: sensor
          datatype: Types.Resources.FileDescriptor
          description: File stored at the vehicle that may be uploaded to a client.
          </code></pre>
        The Types.Resources.FileDescriptor definition in the Types tree must mirror the struct definition above.
          </p>
        <h3>Data channel realization</h3>
        <p>
        If file transfer is realized over any supported transport protocol, this must then be shown in the server capabilities tree,
        together with the information needed for a client to access the data channel.
        The default mechanism for realizing a data channel is to assign a port number for it.
        The list below shows the recommended port numbers for the HTTP and WebSocket protocols.
        <ul>
            <li>HTTP port number: 445</li>
            <li>WebSocket port number: 6445</li>
        </ul>
        The recommended mechanism for MQTT is to assing a separate topic name to the data channel.
        The recommended topic name is created by appending "/datachannel" to the topic name of the control channel.
        </p>
        <h3>Alternative based on well-known file transfer protocols</h3>
        <p>
        There exists a number of common file transfer protocols e. g. ftp, sftp, ftps,
        and scp which are widely adopted and have been optimized over many years.
        For larger files these may be a more efficient solution than the integrated VISS protocol.
        The model for using any of these instead builds on that the client can access the needed informattion to connect to the end point
        that is offering the use of the file transfer protocol to access the file.
        This information is available as a struct data point of the tree node.
        This struct should have members similar to what is shown below, depending on what is required to initiate he file transfer.
          <pre><code>
          struct {
              schema string
              port uint32
              path string
              filename string
          }
          </code></pre>
          Schema is the file transfer protocol schema.<br>
          Port is the port number for this service, at least for the initial setup.<br>
          Path is the URL path for this service.<br>
          Filename is the file name of the file to be transferred. It shall include a file extension that defines the format of the file.<br>
          The node type of this tree node shall be "sensor" for files that can only be uploaded to a client, and "actuator" for the file download case.<br>
          Information about the vehicle file system structure, such as the file path information, shall not be exposed to the client.
          The server may use the VSS path as a key into a lookup table for accessing the file in the vehicle file system.
        </p>
    </section>

    <section id="data-compression" class="appendix">
        <h2><dfn data-dfn-type="dfn" id="dfn-dc">Data Compression</dfn></h2>
        <em>This appendix is non-normative.</em>
        <p>
        The primary payload format is JSON, which is text based and thus may lead to large messages in terms of bytes.
        Particularly in subscription scenarios with large number of event messages that are sent off-vehicle this is an undesireable
        feature as the transportation cost may be significant.
        The payload encoding that is supported in this specification provides one possibility of compressing the message size,
        but it does typically not take advantage of specific knowledge of the data being transported.
        The data compression described here does so, as will be described in the following.
        This compression can typically also be combined with a following payload encoding compression step.
        The compression scheme is assymmetric in that it is applied to the response data from the server,
        but not to the client requests.
        The assumption is that this is where it may have the largest impact, particularly in the case of multiple responses on a subscribe request.
        It is also applied per request by an optional parameter that can be included in the Read or Subscribe requests,
        having the following format.
          <pre><code>
          "dc": "A+B"
          </code></pre>
        The expression A+B instructs the server what compression scheme it shall apply to paths and/or timestamps in its response(s) to this request.
        This expression must consist of two values separated by a plus sign, "A + B",
        where the first value A represents which path compression that is selected, and the second value B represents which timestamp compression that is selected.
        The value 0 means that no compression scheme is selected,
        values 1, 2, 4, or 8 represents the compression scheme associated with bits no 0, 1, 2, or 3 in the figure below.
      <figure id="fig-data-compression-scheme-coding">
        <img src="images/data-compression-scheme-coding.jpg" alt="Consent architecture.">
        <figcaption> <span class="fig-title">Data compression scheme coding.</span></figcaption>
      </figure>
      The bits shown in the figure above are assigned to the data compression schemes shown in the list below and described in the following chapters.<br>
      For path compression:
        <ul>
            <li>Bit 0: Static UID path compression.</li>
            <li>Bit 1: Request local path compression.</li>
            <li>Bit 2-3: Reserved for other path compression schemes.</li>
        </ul>
      For timestamp compression:
        <ul>
            <li>Bit 0: Request relative timestamp compression.</li>
            <li>Bit 1-3: Reserved for other timestamp compression schemes.</li>
        </ul>
        See the following chapters for description of the supported compression schemes.<br>
        If the server supports data compression it SHALL declare the compression schemes it supports in its server capabilities tree
        with an expression A+B where A and B are the sum of the values representing the supported schemes, respectively.<br>
        If a client request for data compression is not supported, or impossible to realize, the server shall respond with an error message.
        </p>

        <h3>Static UID Path Compression</h3>
        <p>
        To enable the server to support this path compression the VSS tree must include the static UIDs for each node.
        The VSS-Tools exporter tools can be used to assign a static UID to each tree node as described
        <a data-link-type="dfn" href="https://github.com/COVESA/vss-tools/blob/master/docs/id.md">here</a>.<br>
        The server will then in the response message(s) replace the VSS path with the static UID value.
        The static UID is represented as a hex value string starting with the characters "0x" then followed by 8 hexadecimal values.
        The client needs to obtain means for decoding the static UIDs into corresponding VSS paths, see the 
        <a data-link-type="dfn" href="https://github.com/COVESA/vss-tools/blob/master/docs/id.md">VSS-tools description</a>.<br>
        The server shall respond with an error message if the client applies the path compression in its request.
        </p>

        <h3>Request Local Path Compression</h3>
        <p>
        The principle for request local path compression is that the server will in the response message(s) replace the path(s) with an integer index.
        In the case that the request only contains one path reference, then the index is always set to zero.
        For requests that reference more than one path via the usage of the paths filter, the first response from the server will contain the paths uncompressed,
        but any following responses will replace the paths with an index.
        The value of the index is then assigned according to a sorted list of the paths included in the first response,
        i. e. the first path in the sorted list is assigned the value zero, the second the value 1, and so on.
        The index logically represent an integer value but it is in the message payload represented as a string.
        </p>

        <h3>Request Relative Timestamp Compression</h3>
        <p>
        The request relative time stamp compression builds on that response messages always contain a timestamp that represent
        the time when the response message was issued by the server.
        This timestamp will then be the base time that the timestamps for the data point(s) in the response will contain an offset to.
        This offset will be represented as an integer representing milliseconds, prepended with a plus (+) or minus (-) sign.
        The uncompressed ISO8601 based timestamp contains 24 characters,
        so for very large offset values leading to low compression rates the server may decide to keep the uncompressed timestamp.
        The client will be able to analyze whether it is a compressed timestamp or not by examining the first character of the string.
        If it is an integer it is an uncompressed timestamp, as the compressed timestamps starts with a plus or a minus character.
        </p>

        <h3>Sequence Diagram Compression Scheme Examples</h3>
        <p>
        The sequence diagram below shows client Get requests for the vehicle speed signal where different combinations of compression schemes are used.
        The responses mainly show the paths or timestamps that becomes compressed.
        In the first request/response the client requests static UID path compression, in the second request local path compression,
        and in the third and fourth request relative timestamp compression is added together with the respective path compression.
      <figure id="data-compression-scheme-sequence-diagram">
        <img src="images/data-compression-sequence-diagram.png" alt="Compression scheme sequence diagram.">
        <figcaption> <span class="fig-title">Data compression scheme sequence diagram.</span></figcaption>
      </figure>
      An example with the complete payloads for a subscribe on two signals with path and timestamp compression are shown below.
      The first payload is the request, the second is the response, then follows the two first event messages.
          <pre><code>
{"action":"subscribe","path":"Vehicle.CurrentLocation","filter":[{"variant":"paths","parameter":["Latitude", "Longitude"]}, {"variant":"timebased","parameter":{"period":"3000"}}], "dc":"2+1","requestId":"286"}

{"action":"subscribe","requestId":"286","subscriptionId":"1","ts":"2025-01-10T11:46:09.955Z"}

{"action":"subscription","data":[{"dp":{"ts":"-123","value":"56.02"},"path":"Vehicle.CurrentLocation.Latitude"},{"dp":{"ts":"-123","value":"12.36"},"path":"Vehicle.CurrentLocation.Longitude"}],"subscriptionId":"1","ts":"2025-01-10T11:46:12.957Z"}

{"action":"subscription","data":[{"dp":{"ts":"-15","value":"56.03"},"path":"0"},{"dp":{"ts":"-15","value":"12.37"},"path":"1"}],"subscriptionId":"1","ts":"2025-01-10T11:46:15.956Z"}
          </code></pre>
        </p>
    </section>

  </body>
</html>
