<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>COVESA VISS version 3.0 - Core</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
    <script class='remove'>
      var respecConfig = {
        latestVersion: null,
        github: "https://github.com/COVESA/vehicle-information-service-specification",
        specStatus: "base",
	logos: [{
	  src: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/images/covesa.jpg",
          url: "https://covesa.global",
          alt: "COVESA",
          height: 70,
	  width: 100,
          id: "covesa-logo",
        },],
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Ford Motor Company",
          companyURL: "https://www.ford.com",
        },
        {
          name: "이원석(Wonsuk Lee)",
          company: "한국전자통신연구원(ETRI)",
          url: "mailto:wonsuk.lee@etri.re.kr",
          companyURL: "https://etri.re.kr/eng/main/main.etri",
          w3cid: 34457
        }],
        edDraftURI: "https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html",
        shortName: "viss3.0-core",
        localBiblio: {
          "SemVer": {
            title: "Semantic Versioning 2.0.0",
            href: "https://semver.org/spec/v2.0.0.html",
            status: "published",
            publisher: "Tom Preston-Werner"
          },
          "viss3-payload-encoding": {
            title: "COVESA VISS version 3.0-Payload Encoding",
            href: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_PayloadEncoding.html",
            publisher: "Ulf Bjorkengren"
          },
          "viss3-transport-examples": {
            title: "COVESA VISS version 3.0-Transport Examples",
            href: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html",
            publisher: "Ulf Bjorkengren"
          }
        }
      };
    </script>
    <style>
      table.parameters, table.exceptions {
          border-spacing: 0;
          border-collapse:    collapse;
          margin: 0.5em 0;
          width:  100%;
      }
      table.parameters { border-bottom:  1px solid #90b8de; }
      table.exceptions { border-bottom:  1px solid #deb890; }

      .parameters th, .exceptions th {
          color:  inherit;
          padding:    3px 5px;
          text-align: left;
          font-weight:    normal;
      }
      .parameters th { color: #fff; background: #005a9c; }
      .exceptions th { background: #deb890; }

      .parameters td, .exceptions td {
          padding:    3px 10px;
          border-top: 1px solid #ddd;
          vertical-align: top;
      }

      .parameters tr:first-child td, .exceptions tr:first-child td {
          border-top: none;
      }

      .parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
          width:  100px;
      }

      .parameters td.prmType {
          width:  120px;
      }

      table.exceptions table {
          border-spacing: 0;
          border-collapse:    collapse;
          width:  100%;
      }

      .simple {
        width:100%;
      }

      thead th{
        border-bottom: 1px solid black;
      }

      .simple tbody th{
        width:33%;
        background: white;
        color: black;
      }
      pre { white-space: pre-wrap;}
  </style>
  </head>
  <body>
    <p class="copyright">Copyright © 2024 COVESA®. This document
    includes material derived from <a href="https://www.w3.org/TR/viss2-core/">W3C VISS version 2 - Core</a>.</p>
    <section id='abstract'>
      <p>The Vehicle Information Service Specification (VISS) is a
      service for accessing vehicle information, signals from sensors
      on control units within a vehicle's network. It exposes this
      information using a hierarchical tree like taxonomy defined in
      COVESA Vehicle Signal Specification (VSS). The service provides
      this information in JSON format. The service may reside in the
      vehicle, or on servers in the internet with information
      already brought off the vehicle.</p>

      <p>This specification describes a third version of VISS which
      has been implemented and deployed on production vehicles.
      The first version of VISS only supported WebSocket as a
      transport protocol, the second version is generalized to work
      across different protocols as some are better suited for
      different use cases.
      The second version added support for the HTTP and MQTT transport
      protocols, subscription capabilities was improved and an
      access control solution was added.</p>

      <p>
        There are three parts to this specification, CORE, [[viss3-transport-examples]], and [[viss3-payload-encoding]]. This document, the VISS version 3.0 CORE specification,
        describes the VISSv3.0 messaging layer.<br>
        The VISSv3.0 transport protocol examples document describe the deviations from the CORE definitions that are used in some transport protocols.<br>
        The VISSv3.0 payload encoding document describes paylod encoding designs that may be applied e. g. for payloads in transit.<br>
      </p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        This document describes the messaging API for the VISS protocol.
        This includes the messaging layer and set of rules for structuring data.<br>
        The specification is agnostic to which transport protocol that is used as long as it conforms to this messaging API and data rule set.
        Transport protocols that cannot conform to the entire CORE specification can still be conformant to by describing their deviations in the
        [[viss3-transport-examples]] specification.<br>
        The primary payload data format is JSON. The JSON schema (<a href="#json-schema"></a>) defines all of the payloads.
        If a transport protocol uses a different payload encoding, such as gRPC,
        or a more bandwidth efficient data representation is desired, then this encoding may be defined in the [[viss3-payload-encoding]] document.
        This encoding must contain a solution for both encoding of the JSON payloads and decoding back to the JSON format.
        A client MUST be able to access the message payload in the JSON format.
      </p>
      <p>
        The messages are exchanged between a server implementation holding the representation of data
        and a client using the data as shown in the figure below, where the payload also is encoded when in transit over the transport protocol.
      </p>
        <figure id="fig-payload-encoding">
          <img src="images/VISSv3-payload-encoding.jpg" alt="VISSv3 paylod encoding overview.">
          <figcaption> <span class="fig-title">VISSv3 paylod encoding overview.</span></figcaption>
        </figure>
      <p>
        The VISSv3.0 messaging layer builds on RESTful principles for the method exchange via the interface (<a href="#interface"></a>).
      </p>
      <p>
        The VISSv3.0 data structuring rules (<a href="https://covesa.github.io/vehicle_signal_specification/rule_set/">VSS Rule set</a>)
        are the same through all transport protocols.
        The basis for structuring data hold by a server is a tree.
      </p>
    </section>

    <section id="conformance"></section>

    <section id="terms">
      <h2>Terminology</h2>
      <p>The acronym 'VISSv3.0' is used to refer to this document, the VISS version 3.0 specification.
      The acronym 'VSS' is used to refer to the <a href="https://github.com/COVESA/vehicle_signal_specification">'Vehicle Signal Specification'</a>
      which is hosted by COVESA.
      The term 'WebSocket' when used in this document, is as defined in the
      <a href="https://www.w3.org/TR/websockets/">W3C WebSocket API</a> and [[RFC6455]], the WebSocket Protocol.
      </p>

        <section id="definitions">
          <h2>Definitions</h2>
        <p></p>

        <dl title="enum Defs" class="idl">
          <dt><b>client</b></dt>
          <dd>An entity that works with data managed by a server.</dd>
          <dt><b>server</b></dt>
          <dd>An entity that manages and offers access to data.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-success-response">success response</dfn></dt>
          <dd>The message being returned by the server to the client when no error is encountered. These are specific per request type</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-error-message">error message</dfn></dt>
          <dd>The message being returned by the server to the client when an error is encountered. It can be a synchronous response message,
          or an asynchrounous event message.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-data-point">data point</dfn></dt>
          <dd>A structure containing one or more value, timestamp tuplets.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-value">value</dfn></dt>
          <dd>The data that is associated with one or more VSS nodes. Regardless of its data type,
          a single data item is always represented as a string in message payloads.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-timestamp">timestamp</dfn></dt>
          <dd>A date and time representation. See chapter <a href="#timestamp"></a>.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-filter">filter</dfn></dt>
          <dd>Additional to help the server in the selection of data for the client.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-authorization">authorization</dfn></dt>
          <dd>A token providing a verifiable proof that the client may be authorized access to the requested data.
          This may be represented by a token handle provided by the server.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-subscription-id">subscriptionId</dfn></dt>
          <dd>A handle identifying a subscription session.</dd>
          <dt><b>requestId</b></dt>
          <dd>Unique id value specified by the client.
          Returned by the server in the response and used by the client to link the request and response messages.
          The value MAY be an integer or a Universally Unique Identifier (UUID).</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-purpose">purpose</dfn></dt>
          <dd>A purpose is one of the short text entries from the <a href="#purpose-list"></a>.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-ecf">ECF</dfn></dt>
          <dd>External Consent Framework. An agent that is responsible for inquiring a data owner about consent.</dd>
        </dl>
      </section>
    </section>

    <section id="data-model">
      <h2>Data Model</h2>
                <p>The service is intended for use with a tree-like logical taxonomy to represent the vehicle data.
                An illustrative example of such a tree structure is shown in <a href="#fig-example-vss-tree">Figure 1</a>.
                While it is meant to support conforming taxonomies it was created principally with the
                <a href="https://github.com/COVESA/vehicle_signal_specification">Vehicle Signal Specification</a> (VSS) in mind.
                For more details, see the <a href="http://covesa.github.io/vehicle_signal_specification/">VSS documentation</a>.<br>
                Depending on how VISS is being used, for instance to serve data already off-boarded and residing in the cloud,
                it may make sense to allow sensor values to be updated by sending a 'set' request.
                When VISS is directly on the vehicle, values reported by sensors are authoritative and should be read-only within VISS.
                Implementations should handle set requests appropriately for their situation and give appropriate success or error responses accordingly.
                </p>
        <figure id="fig-example-vss-tree">
          <img src="images/vss-tree.jpg" alt="example-vss-tree">
          <figcaption> <span class="fig-title">Example VSS 2.0 tree.</span></figcaption>
        </figure>

      <section id="address">
        <h2>Addressing</h2>
        <p>Addressing of resources is done using URIs as defined in [[RFC3987]].<br>
        <blockquote><a>scheme</a>://<a>authority</a>/<a>path</a>?<a>query</a></blockquote>
        The <dfn>scheme</dfn> describes the protocol to use to reach the addressed resource.
        For supported protocols, see the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#transport-protocols">transport protocols</a> in [[viss3-transport-examples]] specification.<br>
        The <dfn>authority</dfn> describes where to reach the resource, for more details see <a href="#authority-component"></a>.<br>
        The <dfn>path</dfn> addresses a specific service within the resource, for more details see <a href="#path-component"></a>.<br>
        The <dfn>query</dfn> contains further information related to the addressed service, see <a href="#filter-request"></a>.<br>
        There are potentially three resources for which a client needs a URI, see <a href="#architecture"></a>:<br>
        <ul>
            <li>VISSv3 server.</li>
            <li>Access grant token server.</li>
            <li>Access token server.</li>
        </ul>
        </p>

      <section id="authority-component">
        <h2>Authority URI Component</h2>
        <p>
          The authority component of the URI consists of an IP address or a domain name followed by a colon and a port number.
        </p>

        <section id="ip-address-domain-name">
          <h2>IP address / domain name</h2>
          <p>
          Depending on the deployment of a resource, either in the cloud or in a vehicle, they will have a domain name or an IP address, respectively.
          A client is expected to obtain this part of the authority component via an interaction with the
          <a href="#ecosystem-manager-def">ecosystem manager</a>. The details of this interaction is out of scope for this specification.
          </p>
        </section>

        <section id="port-number">
          <h2>Port number</h2>
          <em>This section is non-normative.</em><br>
          <p>
          The VISSv3 server shall use the following port numbers for the different transport protocols.
          <ul>
            <li>HTTP port number = 443.</li>
            <li>Websocket port number = 6443.</li>
            <li>MQTT port number = 8883.</li>
          </ul>
          The access grant token server shall use the port number 7443.<br>
          The access token server shall use the port number 8443.<br>
          A client may be provisioned with other port numbers than the above specified in its interaction
          to obtain the other parts of the authority component, see <a href="#ip-address-domain-name"></a>.
          </p>
        </section>
      </section>

      <section id="path-component">
        <h2>Path URI Component</h2>
        <p>
          The path URI component definition differs between the three resources.<br>
          For the <b>VISSv3 server</b> the definition is as follows.<br>
          The path consists a sequence of VSS node names separated by a delimiter. VSS specifies the dot (.) as delimiter,
          which therefore is the recommended choice also in this specification.
          However, in HTTP URLs the conventional delimiter is slash (/), therefore also this delimiter is supported.
          To exemplify, the path expression from traversing the nodes Vehicle, Car, Engine, RPM can  be "Vehicle.Car.Engine.RPM",
          or "Vehicle/Car/Engine/RPM". A mix of delimiters in the same path expression SHOULD be avoided.<br>
          The path MUST not contain any wildcard characters ("*"), for such needs see <a href="#paths-filter-operation"></a>.<br>
          For the <b>access grant token server</b> the path is "agts".<br>
          For the <b>access token server</b> the path is "ats".<br>
        </p>
      </section>
      </section>

      <section id="data-representation">
        <h2>Data representation</h2>
        <p>
          A single data point is in the message payload represented by a value and an associated timestamp,
          in JSON represented by two key-value pairs with the key names "value" and "ts".<br>
          The "ts" value MUST be a string as specified in <a href="#timestamp"></a>, while the "value" value MUST be a string,
          an array of strings for array type signals, or an object for complex datatypes,
          see <a href="https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/data_types/">VSS Data Types</a>.<br>
          In the case of the value being a number, it MUST follow the number formats as specified in [[RFC8259]].
          A boolean value is represented by "true" or "false".<br>
          In the case of the value being a complex datatype represented by a struct, it is represented as a JSON object as shown below.
          A struct with the following declaration<br>
          <pre><code>
          struct {
              field1 datatype
              field2 datatype
          }
          </code></pre>
          is represented by the following JSON object<br>
          {"field1":"X", "field2":"Y"}<br>
          where X and Y are the actual values of respective datatype, here represented for simplicity as string values.
          The datatype of a field of the struct may be any datatype suported by VSS, including a struct.<br>
          For representation of multiple data points, see <a href="#response-syntax"></a>.<br>
          If data is represented incorrectly, then an error message with number 400, and reason "Bad data" MUST be returned.
          A specific case of this is if an array of data elements does not contain the number expected by the server.
          The server MAY then respond successfully, and follow a proprietary recovery policy,
          or it MAY respond with error number 400, and reason "Invalid array size".
        </p>
      </section>
    </section>

    <section id="interface">
      <h2>Interface</h2>
      <p>
        This chapter describes the different methods and its arguments that govern the communication between a client and the server.
      </p>

      <section id="methods">
        <h2>Methods</h2>
        <p>
          The transport protocols used to implement these methods MUST implement the Read and Update methods,
          and MAY implement the Subscribe, Unsubscribe, and Subscription methods.
        </p>
        <section id="read">
          <h2>Read</h2>
          <p>Purpose: Get one or more values addressed by the given path.</p>
          <p>The client MAY have to obtain an <a>authorization</a> token before being able to access the values.
             If the server is able to satisfy the request it MUST return a <a>success response</a>.
             If the server is unable to fulfil the request, then the server MUST return an <a href="#error-message">error response</a>.</p>
          <p>Arguments, of which path is mandatory:
          <ul>
            <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
            <li><a>filter</a> Additional information defining the requested data.</li>
            <li><a>authorization</a> The authorization token.</li>
          </ul>
          </p>
          <p>Success response, of which authorization is optional:
            <ul>
              <li><a>data</a> The data structure contains one or more sets of a path and a data point structure.</li>
              <li style="margin-left: 40px"><a>path</a> The path for the associated data point structure.</li>
              <li style="margin-left: 40px"><a>data point</a> A structure containing one or more tuplets of value and timestamp.</li>
              <li style="margin-left: 80px"><a>value</a> The latest available value.
              Please note that also for actuators this returns the current value, and not a target value that might have been set.</li>
              <li style="margin-left: 80px"><a>timestamp</a> The capture time of the value.</li>
              <li><a>authorization</a> A handle representing the authorization token.</li>
              <li><a>timestamp</a> The time of the server request execution.</li>
            </ul>
          </p>
        </section>

        <section id="update">
          <h2>Update</h2>
          <p>Purpose: Provide altered value to the vehicle signal addressed by the <a>path</a></p>
          <p>The client MAY have to obtain an authorization token before being able to update the vehicle signal.
          If the server is able to satisfy the request it MUST return a <a>success response</a>, else it MUST return an <a>error message</a>.
          Only actuator type signals can be updated.
          Please note that a success response does not guarantee that the actuation attempt to change to the updated target value has, or will, succeed.
          A client may monitor the actuation progress through subsequent reads of the actuator value.
          </p>
          <p>Arguments, of which path and value are mandatory:
            <ul>
              <li><a>path</a> The path as defined in VSS to a single node in the VSS tree.</li>
              <li><a>value</a> The value by which the vehicle signal addressed by the path will be updated to.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response, of which authorization is optional:
            <ul>
              <li><a>authorization</a> A handle representing the authorization token.</li>
              <li><a>timestamp</a> The time of the server request execution. This may not be the same as the final update time of the signal.</li>
            </ul>
          </p>
        </section>

        <section id="subscribe">
          <h2>Subscribe</h2>
          <p>Purpose: Get asynchronous messages containing the value(s) addressed by the path.
          The triggering rules for issuing the event messages are set by the filter data.</p>
          <p>The client MAY have to obtain an authorization token before being able to subscribe to the vehicle signal(s).
             The server MUST issue an event message if a trigger rule is fulfilled.
             If the server is able to satisfy the request it MUST return a <a>success response</a>.
             If the server is unable to fulfil the request, then the server MUST return an <a href="#error-message">error response</a>.
             If an error occurs during the subscription period, the server SHOULD return an <a href="#error-message">error event</a>.</p>
          <p>Arguments, of which path and filter are mandatory:
            <ul>
              <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
              <li><a>filter</a> The rule set describing triggering criterias for issuance of asynchronous event messages.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response, of which authorization is optional:
            <ul>
              <li><a>authorization</a> A handle representing the authorization token.</li>
              <li><a>subscriptionId</a> A handle identifying event messages associated with the subscription.</li>
              <li><a>timestamp</a> The start time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section id="unsubscribe">
          <h2>Unsubscribe</h2>
          <p>Purpose: Termination of the subscription period started by a previous subscribe request.</p>
          <p>If the server is able to satisfy the request it MUST return a <a>success response</a>,
          and it MUST stop issuing event messages associated to the subscription handle.
          If the server is unable to fulfil the request, then the server MUST return an <a href="#error-message">error response</a>.</p>
          <p>Arguments, of which subscriptionId is mandatory:
            <ul>
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>
              <li><a>timestamp</a> The stop time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section id="subscription">
          <h2>Subscription</h2>
          <p>Purpose: Asynchronous client event message according to the subscribe request trigger rules.</p>
          <p>The server MUST issue an event message when a triggering rule associated with the subscription is met.
             If the server cannot fulfill the triggering rules it MUST issue an error event message and terminate the subscription.
          </p>
          <p>Arguments:
            <ul>
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
              <li><a>data</a> The data structure contains one or more sets of a path and a data point structure.</li>
              <li style="margin-left: 40px"><a>path</a> The path for the associated data point structure.</li>
              <li style="margin-left: 40px"><a>data point</a> A structure containing one or more tuplets of value and timestamp.</li>
              <li style="margin-left: 80px"><a>value</a> The value associated with the filter expression.</li>
              <li style="margin-left: 80px"><a>timestamp</a> The capture time of the value.</li>
              <li><a>timestamp</a> The time of the server subscription execution.</li>
            </ul>
          </p>
        </section>
      </section>

      <section id="error-message">
        <h2>Error Message</h2>
        <p>The server MUST inform a client about errors ocurring in interactions between the two, whether it is in a synchronous
        error response, or an asynchronous error event as a result of a previous subscribe.
        For transport protocols which do not control the logical linking between request and response messages it may not be possible to link an error message to the correct client request.
        In cases like this the server may omit sending an error message.
        The error message has three arguments, of which subscriptionId is mandatory only for error events.
        In the case of an error event being issued by the server, the associated subscription session SHALL thereafter be terminated by the server.
        </p>
          <p>Arguments:
            <ul>
              <li><a>error message</a> <a href="#error-information"></a></li>
              <li><a>subscriptionId</a> The reference to the subscribe session.</li>
              <li><a>timestamp</a> The time of the server execution leading to the error.</li>
            </ul>
          </p>

        <section id="error-information">
          <h2>Error Information</h2>
          <p>The error information has three components - a number, a reason, and a message.
          The number MUST always be part of the error information, while the reason and message components MAY be a part of it.
            <ul>
              <li><b>number</b> See the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html/#status-codes">status codes</a> as defined in [[viss3-transport-examples]].</li>
              <li><b>reason</b> See the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#status-codes">status codes</a> as defined in [[viss3-transport-examples]].</li>
              <li><b>message</b> See the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#status-codes">status codes</a> as defined in [[viss3-transport-examples]].</li>
            </ul>
          </p>
          </section>
      </section>

      <section id="timestamp">
        <h2>Timestamps</h2>
        <p>
           Timestamps in transport payloads MUST conform to the [[ISO8601]] standard, using the UTC format with a trailing Z.
           Time resolution SHALL at least be seconds, with subsecond resolution as an optional degree of precision when desired.
           The time and date format shall be as shown below, where the sub-second data and delimiter is optional.<br>
           YYYY-MM-DDTHH:MM:SS.ssssssZ<br>
           The exception to this is timestamps within tokens, which MUST conform to Unix time.
        </p>
      </section>
    </section>

      <section id="security">
        <h2>Security Considerations</h2>
        <p>
        </p>

      <section id="transport-security">
        <h2>Transport security</h2>
        <p>
        Transport protocols supported by this specification MUST make use of TLS v1.2 as defined in [[RFC5246]].
        </p>
      </section>

      <section id="data-security">
        <h2>Data security</h2>
        <p>
        The <a href="#access-control-model"></a> makes it possible to apply restrictions on the data access for clients that are
        granted access on the transport protocol level.
        </p>
      </section>

      <section id="privacy">
        <h2>Privacy Considerations</h2>
        <p>In addition to some privacy provisions within the
        specification itself, COVESA and W3C have activities seeking
	to establish systems and guidelines to provide further considerations for handling of
        information. </p>

        <p>For some uses, such as when information is only referenced within the vehicle not sent
        off nor persisting between restarts, there should be little to
        no privacy concerns.</p>

        <p>This specification, unlike its predecessor, has granular
        access control capabilities to limit what information an
        application may access. All information sent from a VISS
        service to client application must be transported over an
        encrypted protocol to help protect privacy.
        </p>

        <p>For an application to be installed and permitted to run on a vehicle it should
        have consent from whoever is deemed authoritative for a given
        jurisdiction and ownership situation. That consent should be
        revocable. Consent and revoking it are outside the scope of
        this specification, it is expected to be handled out of band
        and in some cases by regulations and contractual commitments. Future version of this specification however may provide
        mechanism for enabling and suspending application
        authorization to access information.</p>

      </section>
      </section>

    <section id="filter-request">
      <h2>Filter Request</h2>
          <p>
          Filtering is a mechanism to refine a client request, in order to more precisely control what is returned in a response.
          Filtering can be applied in read requests and in subscribe requests.
          A request where filtering is applied has the following structure
          <ul>
          <li>for the HTTP protocol:
          <ul>
          <li>GET /&lt;vsspath&gt;?filter=&lt;filter-expression&gt;</li>
          </ul></li>
          <li>for the Websocket protocol:
          <ul>
          <li>{"action":"get", "path":"&lt;vsspath&gt;", "filter":"&lt;filter-expression&gt;"}</li>
          </ul></li>
          </ul>
          where<br>
          <ul>
          <li>Get is the transport protocol method,</li>
          <li>vsspath is the path starting from the tree root,</li>
          <li>filter is the key name for the filter expression,</li>
          <li>filter-expression contains the filter instructions.</li>
          </ul>
          </ul>
          The JSON expression has the object format as shown below. For the case of an optional second object of this type,
          these are enclosed in an array expression.<br>
          <ul>
          <li>{"variant":"&lt;x&gt;", "parameter":"&lt;y&gt;"}</li>
          </ul>
          where<br>
          <ul>
          <li><b>variant</b>: the key name for the filter operation variant, which can have one of the values:
          <ul>
          <li><u>paths</u>:
          <ul>
          <li>one or more relative paths. In the case of several paths an array expression shall be used.</li>
          </ul></li>
          <li><u>timebased</u>:
          <ul>
          <li>data is captured repeatedly with a fixed period time.</li>
          </ul></li>
          <li><u>range</u>:
          <ul>
          <li>data is captured when values are in the given range.</li>
          </ul></li>
          <li><u>change</u>:
          <ul>
          <li>data is captured when the value since last capture has changed more than a fixed value.</li>
          </ul></li>
          <li><u>curvelog</u>:
          <ul>
          <li>captured data is processed according to the curve logging algorithm before being sent to client.</li>
          </ul></li>
          <li><u>history</u>:
          <ul>
          <li>captured data from a time period from current time and backwards in time.</li>
          </ul></li>
          <li><u>static-metadata</u>:
          <ul>
          <li>the response contains the VSS metadata of the addressed sub-tree.</li>
          </ul></li>
          <li><u>dynamic-metadata</u>:
          <ul>
          <li>the response contains metadata additional to the VSS specification.</li>
          </ul></li>
          </ul></li>
          <li><b>parameter</b>: the key name for the optional configuration data that the filter operation requires.
          The parameter data varies depending on the variant,
          is enclosed in one object, or optionally an array of two objects, and is described in the following chapters.</li>
          </ul>
          The server MUST support the timebased and change variants, the other variants are optional.<br>
          In the JSON object, the key-value pairs "variant" and "parameter" must always be present.
          The JSON expression may consist of maximum one object with variant "paths", plus maximum one object with any other supported variant,
          which are then logically combined as with an AND operator.<br>
          The variants timebased, range, change, and curvelog are only applicable for subscription requests.
          Subscription requests are supported by the websocket and the MQTT transport protocols.<br>
          The restriction on how many objects that can be combined is also set by the URL size restriction on 1k characters (*).<br>
          (*) 1k is the "conservative limit, which should always be supported, a more liberal limit is 2k, which is supported in most cases.
          </p>

     <section id="paths-filter-operation">
        <h2>Paths Filter Operation</h2>
                <p>
                The paths filter operation is used when a single request is used to retrieve signal data from multiple data points in the VSS tree.
                The vsspath shall point to the last node in the tree that is common for the relative paths in the filter parameter object,
                that start off from this node.
                If the end point of a path in the filter value is a branch, then all leaf nodes in the sub-tree below this branch are addressed.
                A path in the filter value may contain the wildcard character (*) as a representative for a single path segment.<br>
                Every path element in an value array must address at least one node in the tree, or else an error response is returned.<br>
                Different elements of the value array may address the same node,
                in which case it is the responsibility of the server to resolve this to a singleton in the event messages.<br>
                Examples can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#https-search-read">search read on HTTPS</a> and
                <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#wss-search-read">search read on WebSocket</a> in [[viss3-transport-examples]] specification.
                </p>
        </section>

     <section id="history-filter-operation">
        <h2>History Filter Operation</h2>
                <p>
                The server typically have access only to the latest, most fresh data point representing a signal.
                However, it may for various reasons at least temporarily have access to also older data points.
                A scenario where this could occur is when a vehicle temporarily loses its connectivity,
                maybe because it enters into a tunnel. Assuming that the vehicle detects the loss of connectivity, it may then start to record data.
                If recorded, this data may then be accessed using the history variant.
                The vehicle system makes its own decision whether to record any data, and for how long this data will be kept in storage.
                The period in the filter expression goes from current time, excluding the current value, and backwards in time.
                The number of data points in the response depends on the period size, and the sample frequency.
                The latter can not be set by the client,
                so the client should have some understanding of its value to estimate the amount of data it may receive.
                A request for historic data will return a Not found error (404) if historic data is unavailable.
                The period must conform to the [[ISO8601]] duration format, expressed with days, hour, minute,
                and second data, i. e. "parameter": "PdddDThhHmmMssS".
                The number of days shall be less than 999. Only a single period can be expressed.<br>
                Examples can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#https-history-read">history read on HTTPS</a> and
                <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#wss-history-read">history read on WebSocket</a> in [[viss3-transport-examples]] specification.
                </p>
        </section>

     <section id="timebased-filter-operation">
          <h2>Time Based Filter Operation</h2>
                <p>
                The parameter object contains the period time X in between captures, {"period":"X"}.
                X is an integer and represents the period time in milliseconds.
                Example can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#subscribe">subscribe section</a> in [[viss3-transport-examples]] specification.
               </p>
        </section>

     <section id="range-filter-operation">
          <h2>Range Filter Operation</h2>
                <p>
                The range filter operation supports two types of ranges, see the following sub chapters.<br>
                <section id="single-boundary-range">
                  <h2>Single Boundary Range</h2>
                  <p>
                  One logical "boundary operator" evaluates the current signal value in relation to the boundary.
                  If evaluated to true, the server issues an event message containing the signal value to the subscribing client.
                  The boundary operator MUST be one of the values shown in the footer (**).<br>
                  Examples<br>
                  {"boundary-op":"gt", "boundary": "5"}   // x > 5<br>
                  {"boundary-op":"eq", "boundary": "5"}   // x == 5
                  </p>
                </section>
                <section id="multi-boundary-range">
                  <h2>Multi Boundary Range</h2>
                  <p>
                  Two boundaries with respective boundary operators are evaluated relative to the current signal value.
                  The logical outcome of the two evaluations are applied as input to a logical AND/OR operation.
                  If evaluated to true, the server issues an event message containing the signal value to the subscribing client.
                  Besides the mandatory "boundary-op", and "boundary" key-value pairs in each JSON object,
                  the first object may contain a "combination-op" key value pair, which then MUST have either the value "AND", or the value "OR".
                  If omitted, the result of the two boundary evaluations is per default applied to an AND operation.
                  The JSON array MUST contain two objects.
                  The boundary operator MUST be one of the values shown in the footer (**).<br>
                  Examples<br>
                  [{"boundary-op":"gt", "boundary": "5"},{"boundary-op":"lt", "boundary": "10"}]   // x > 5 AND x < 10<br>
                  [{"boundary-op":"lt", "boundary": "5", "combination-op":"OR"},{"boundary-op":"gt", "boundary": "10"}]   // x < 5 OR x > 10
                  </p>
                </section>
                (**)The supported boundary operators are ["eq", "ne", "gt", "gte", "lt", "lte"],
                where "eq" is "equal", "ne" is "not equal", "gt" is "greater than", "gte" is "greater than or equal", "lt" is "less than",
                "lte" is "less than or equal".<br>
                Examples can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#authorized-subscribe">authorized subscribe</a> and
                <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#range-subscribe">range subscribe</a> in [[viss3-transport-examples]] specification.
               </p>
        </section>

     <section id="change-filter-operation">
          <h2>Change Filter Operation</h2>
                <p>
                The parameter object contains the logical operator for comparison of previous and current values, {"logic-op":"X", "diff":"Y"},
                where X is one of the supported logical operators (**), and Y is the value of the required change.<br>
                For boolean values the following expressions shall be supported:<br>
                "parameter":{"logic-op":"gt", "diff": "0"} This leads to a trigger event when the value goes false->true.<br>
                "parameter":{"logic-op":"lt", "diff": "0"} This leads to a trigger event when the value goes true->false.<br>
                "parameter":{"logic-op":"ne", "diff": "0"} This leads to a trigger event when the value goes true->false OR false->true.
                <br><br>
                (**)The supported logic operators are ["eq", "ne", "gt", "gte", "lt", "lte"],
                where "eq" is "equal", "ne" is "not equal", "gt" is "greater than", "gte" is "greater than or equal",
                "lt" is "less than", "lte" is "less than or equal".<br>
                Example can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#change-subscribe">Change Subscribe</a>
                 in [[viss3-transport-examples]] specification.
               </p>
        </section>

     <section id="curvelog-filter-operation">
          <h2>Curve logging Filter Operation</h2>
                <p>
                The parameter object contains the maximum error limit, and the buffer size, {"maxerr": "X", "bufsize":"Y"},
                where X is a float value setting the max allowed error between any data sample and the simplified curve,
                and Y is the number of buffer elements. Data is processed when the buffer becomes full,
                and the essential data points are returned as a time series per signal.<br>
                Example can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#curve-logging-subscribe">curve logging subscribe</a>
                 in [[viss3-transport-examples]] specification.
               </p>
        </section>

   <section id="static-metadata-request">
     <h2>Static Metadata Filter Operation</h2>
        <p>
        The static metadata request is used when the client instead of the data associated to VSS node(s)
        wants to retrieve meta data associated to the VSS node(s).<br>
        The metadata is retrieved from the VSS tree that is deployed in the vehicle.
        This request variant is sometimes referred to as a signal discovery request.
        If the "parameter" object contains an empty string, then all metadata that the server can retrieve for the for the addressed node(s) are returned,
        while if it contains a metadata key name, or an array of key names, then only the selected metadata is returned.<br>
        For the set of static metadata key names,
        see the <a href="https://github.com/COVESA/vehicle_signal_specification">Vehicle Signal Specification</a>.<br>
        The vsspath in the request may point to either a leaf node, or to a branch node.
        In the latter case then the response will contain static metadata from the entire sub-tree having this branch as the root.<br>
        A static metadata request can be combined with a paths filter operation to address multiple nodes,
        but cannot be combined with any other filter variant.<br>
        The response is a JSON formatted object with corresponding key-value pairs per addressed node.
        The server MAY support the static metadata request.<br>
        Example can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#https-service-discovery-read">signal discovery read on HTTPS</a> in [[viss3-transport-examples]] specification.
        </p>
    </section>

   <section id="dynamic-metadata-request">
     <h2>Dynamic Metadata Filter Operation</h2>
        <p>
        Dynamic metadata requests are used when the client instead of the data associated to VSS node(s) wants to
        retrieve metadata that is additional to the VSS specification.<br>
        The dynamic metadata may change over time.
        The request filter "parameter" object MUST only contain one of the metadata key names from the list of dynamic metadata key names below.<br>
        <ul>
        <li><u>samplerate</u>: The native capture frequency in Hz that is used by the vehicle system.
        The response uses the same syntax as for ordinary data responses, with "value" representing the sample rate.</li>
        <li><u>availability</u>: The current availability of the signal(s). The possible values are ["available", "unavailable", "error"].
        The unavailable status is returned when the signal is inaccessible due to the current vehicle state.
        The error status is returned if the subsystem represented by the signal exists in the vehice, but is broken and requires repair.
        The response uses the same syntax as for ordinary data responses, with "value" representing the availability.</li>
        <li><u>validate</u>: The access control rule that is applied to the node and its sub-tree.
        The possible values are ["write-only", "read-write"].
        The response uses the same syntax as for ordinary data responses, with "value" representing the validate tag.
        The server applies the validate data according to the inheritance rules described in the access control selection chapter.</li>
        <li><u>server_capabilities</u>: The capabilities that the server supports.
        See <a href="#server-capabilities">B. Server Capabilities</a> for how this is expressed in the response.</li>
        </ul>
        A dynamic metadata request can be combined with a paths filter operation to address multiple nodes,
        but not with any other filter variant.<br>
        The server capabilities request MUST be supported, the others on the list are optional.
        For the server capabilities request the vsspath SHALL be set to "Vehicle", and the paths filter MUST not be used.<br>
        Examples can be found in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#https-dynamic-metadata-read">dynamic metadata read on HTTPS</a>
        and <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#wss-service-discovery-read">signal discovery read on WebSocket</a> in [[viss3-transport-examples]] specification.
        </p>
    </section>

     <section id="multiple-signals-request">
          <h2>Multiple Signals Request</h2>
            <p>
            The filtering operations may be used to address multiple tree nodes in one request.
            This may lead to specific issues in certain situations, as described below.
            </p>

     <section id="error-handling">
          <h2>Error Handling</h2>
            <p>
            A request addressing multiple nodes may address both valid nodes, and invalid nodes.
            The latter case shall lead to a Forbidden error (403) response message part that contains information about which node, or nodes,
            that are invalid.
            The error response shall not contain data from any of the validly addressed nodes.
            </p>
     </section>

     <section id="response-syntax">
          <h2>Response syntax</h2>
            <p>
            A response may contain multiple values, due to either that multiple nodes are addressed,
            or to that multiple values for one signal is returned.
            These two reasons can be combined, leading to four different cases.
                <ul>
                <li>Request for a single value from a single node.</li>
                <li>Request for multiple values from a single node.</li>
                <li>Request for a single value from multiple nodes.</li>
                <li>Request for multiple values from multiple nodes.</li>
                </ul>
                The syntax to accomodate these four cases have a common structure where a data point ("dp") consists of one or more objects
                containing a "value" and a timestamp ("ts"), and the complete aggregation ("data"),
                consists of one or more objects containing a "path" and a data point (dp"). The syntax of the four cases are shown below.
                <p>Response for a single value from a single node:
        <pre class="highlight hljs javascript" aria-busy="false">
  "data": {
    "dp": {
      "ts": "Z",
      "value": "Y"
    },
    "path": "X"
  }
                   </pre></p>
                   <p>Response for multiple values from a single node:
                <pre class="highlight hljs javascript" aria-busy="false">
  "data": {
    "dp": [
      {
        "ts": "Z1",
        "value": "Y1"
      },
      {
        "ts": "Zn",
        "value": "Yn"
      }
    ],
    "path": "X"
  }
                </pre></p>
                <p>Response for a single value from multiple nodes:
                <pre class="highlight hljs javascript" aria-busy="false">
  "data": [
    {
      "dp": {
        "ts": "Z1",
        "value": "Y1"
      },
      "path": "X1"
    },
    {
      "dp": {
        "ts": "Zm",
        "value": "Ym"
      },
      "path": "Xm"
    }
  ]
                </pre></p>
                <p>Response for multiple values from multiple nodes:
                <pre class="highlight hljs javascript" aria-busy="false">
  "data": [
    {
      "dp": [
        {
          "ts": "Z11",
          "value": "Y11"
        },
        {
          "ts": "Z1n",
          "value": "Y1n"
        }
      ],
      "path": "X1"
    },
    {
      "dp": [
        {
          "ts": "Zm1",
          "value": "Ym1"
        },
        {
          "ts": "Zmn",
          "value": "Ymn"
        }
      ],
      "path": "Xm"
    }
  ]
        </pre></p>
               In the case of a request for multiple values from multiple nodes, the datapoint for different paths may contain single or multiple objects,
               as the vehicle system may not have multiple values recorded for all requested signals.
            </p>
     </section>

     <section id="subscription-event-triggering">
          <h2>Subscription Event Triggering</h2>
            <p>
            A subscription request must always contain a filter operation that describes the trigger event that leads to
            that the server dispatches an asynchronous event message.
            For the filter variants "range" or "change", the triggering is dependent on the signal value.
            When the request addresses multiple signals, the triggering condition shall only be evaluated on one of the signals,
            which is the first signal in the parameter array of paths.
            The first path in the array must therefore not contain wildcards to address multiple signals.
            In this case one of the path addresses in the wildcard expression must be selected as the first array element,
            which can then be followed by the wildcard expression.
            The duplicate reference to one signal that this leads to shall be resolved by the server to a singleton in the event messages.
            </p>
     </section>
     </section>
   </section>

    <section id="access-control-model">
      <h2>Access Control Model</h2>
      <p>
      Access control MUST be supported. However, in this chapter only the sections that describe the interactions between the
      <a href="#client-def">client</a> and the VISSv3 server are mandatory.<br>
      Access control SHALL not be applied to the VSS nodes containing the VSS version data,
      and not to client requests for dynamic metadata about the server capabilities,
      or about the access control selection tags applied to the VSS tree.
      </p>

      <section id="architecture">
        <h2>Architecture</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The VISSv3 access control model is inspired by the concepts of OAuth2.0 [[RFC6749]],
        but some deviations exist as is described in the following chapters.<br><br>
        Four actors are defined:<br>
        <b>Client</b><br>
        An <a href="#application-roles-def">application </a>making protected and authorized resource requests on behalf of its
        <a href="#user-roles-def">user</a>.<br>
        <b>Access grant token server</b><br>
        The server issuing the Access Grant credential after successfully authenticating the <a href="#client-def">client</a>.<br>
        <b>Access token server</b><br>
        The server issuing the <a href="#access-token-def">access token</a> to the <a href="#client-def">client</a>
        after successfully validating the request and obtaining authorization.<br>
        <b>VISSv3 server</b><br>
        The server hosting the protected resources, capable of accepting and responding to protected resource requests using
        <a href="#access-token-def">access tokens</a>.<br><br>
        The abstract protocol flow illustrated in the figure below describes the interaction between the four actors.<br>
        <figure id="fig-oauth2.0-flow">
          <img src="images/VISSv3-abstract-flow.jpg" alt="VISSv3 abstract protocol flow.">
          <figcaption> <span class="fig-title">The abstract protocol flow.</span></figcaption>
        </figure>
        Besides the four actors directly involved in the abstract flow, there are two more actors.<br>
        <b>Resource owner</b><br>
        This is typically the driver of the vehicle, who may be asked for consent before access is granted.<br>
        <b>Ecosystem manager</b><br>
        The entity managing the access control ecosystem. It controls the Policy documents,
        and manages the PKI ecosystem that the other actors may utilize.<br><br>
        The abstract protocol flow is implemented by two different flows, as will be described in the following chapters.<br>
        The process to obtain the credentials needed for <a href="#client-def">client</a> authentication is out-of-scope,
        as well as the installation procedures for the <a href="#application-roles-def">applications</a>.
        </p>
      </section>

      <section id="access-control-flows">
        <h2>Protocol Flows</h2>
        <p>
        <em>This section is non-normative.</em><br>
        Two different flows are described. Which flow to use depends on the capabilities of the <a href="#client-def">client</a>.<br>
        If a <a href="#client-def">client</a> is able to run public key cryptographic primitives,
        i.e. key pair generation and signatures,
        and has access to some kind of trusted execution environment where private keys are protected from the regular execution environment,
        then it can use the long term flow. <a href="#client-def">Clients</a> that do not have access to these capabilities,
        or do not want to use them, must select the short term flow.<br>
        The advantage of using the long term flow is that the <a href="#client-def">client</a> can be trusted with longer expiry times of
        <a href="#access-grant-token-def">access grant tokens</a>.
        In the short term flow the <a href="#client-def">client</a> must due to a shorter expiry time contact the
        <a href="#access-grant-server-def">access grant token server</a> more often to obtain a new
        <a href="#access-grant-token-def">access grant token</a>.<br>
        A <a href="#client-def">client</a> selects the type of flow by either submitting a public key in the
        <a href="#access-grant-request-def">access grant request</a>, or not. The latter leading to an short term flow.
        </p>
      </section>

      <section id="protocol-messages">
        <h2>Protocol Messages</h2>
        <em>This section is non-normative.</em><br>
        This chapter describes the payloads of the messages used in the protocol flow.

        <dfn id="access-grant-request-def"></dfn>
        <section id="access-grant-request">
          <h2>Access Grant Request</h2>
          <p>
          The request shall contain the Context and Proof parameters below, the others are optional:
          <ul>
            <li>VIN: The vehicle identification number. Instead of the
	    assigned VIN a generated hash can be used as a pseudo VIN,
            or any other identity that uniquely links to the vehicle in the access control ecosystem.</li>
            <li><a href="#client-context-def">Context</a>: The context associated to the <a href="#client-def">client</a>.
            The context consists of a triplet of roles for <a href="#user-roles-def">user</a>, <a href="#application-roles-def">app </a>permissions,
            and <a href="#device-roles-def">device</a> characteristics.</li>
            <li><a href="#proof-of-possession-def">Proof</a>: A proof mechanism that is used by the <a href="#client-def">client</a>
            to attest its context to the <a href="#access-grant-server-def">access grant token server</a>.
            This is indeed a composed proof for the User role, <a href="#application-roles-def">app </a>permissions,
            and <a href="#device-roles-def">device</a> characteristics.</li>
            <li>Public key: If this parameter is present, the client will receive a long term
            <a href="#access-grant-token-def">access grant token</a> in return.</li>
          </ul>
          </p>
          <p>
            Depending on the kind of <a href="#proof-of-possession-def">proofs</a> included in the request,
            the client and the server may need to run an interactive protocol to verify them.
            The protocol may involve also third parties, such as the <a href="#ecosystem-manager-def">ecosystem manager</a> or the
            <a href="#resource-owner-def">resource owner</a>. The protocol is out of scope for this specification.<br>
            In scenarios where both the client and the <a href="#access-grant-server-def">access grant token server</a>
            are deployed in-vehicle the VIN parameter may be omitted, in all other deployment scenarios it shall be present.<br>
          </p>
        </section>

        <section id="access-grant-response">
          <h2>Access Grant Response</h2>
          <p>
          The response shall contain the parameter below:
          <ul>
            <li><a href="#access-grant-token-def">Access grant token</a>: A signed token with claims needed for the validation of the
            <a href="#client-def">client</a> request.</li>
          </ul>
          The response for a successful <a href="#access-grant-request-def">access grant request</a> is a short or long term
          <a href="#access-grant-token-def">access grant token</a>, depending on the input in the request message.
          The only difference between both kind of tokens is that long term <a href="#access-grant-token-def">access grant token</a>
          would include the public key used in the request.
          <br>
          The <a href="#access-grant-token-def">access grant token</a> is a digitally signed document issued by the
          <a href="#access-grant-server-def">access grant token server</a> including all relevant information needed to issue
          <a href="#access-token-def">access tokens</a>.
        </p>
        <p>
          An error response shall contain the parameter:
          <ul>
            <li>Error code: The error code shall be informative in order for the <a href="#client-def">client</a>
            to understand what it needs to correct to become successful.</li>
          </ul>
        </p>

        </section>



        <section id="access-token-request">
          <h2>Access Token Request</h2>
          <p>
          The client may have to issue several requests before an access token can be obtained, even in the case of having a valid access grant token.
          The reason for this is that if consent is required, the ATS will forward the consent request to the External Consent Framework,
          and it is likely that there will not be an immediate response from the <a>ECF</a>.
          The ATS will then on the initial access token request respond to the client with a session handle that the client must use in subsequent requests for the access token.
          When the ATS has obtained a consent reply from the <a>ECF</a> it can thereafter following client inquiry request in the case of a positive consent
          respond with the access token, or in the case of a negative consent respond with only the negative consent result.

        <section id="initial-access-token-request">
          <h2>Initial Access Token Request</h2>
          <p>
          The request shall contain at least these two parameters below:
          <ul>
            <li><a href="#access-grant-token-def">Access grant token</a>: A signed token with claims needed for the validation of the
            <a href="#client-def">client</a> request.</li>
            <li><a>Purpose</a>: The intended client usage of the requested data.</li>
          </ul>
            Short term <a href="#access-grant-token-def">access grant token</a>s can be used as direct input to the
            <a href="#access-token-server-def">access token server</a>, but long term <a href="#access-grant-token-def">access grant tokens</a>
            should be accompanied by a <a href="#proof-of-possession-def">proof of possession</a> (PoP)
            for the private key corresponding to the public key included in the token.
          </p>
          <p>
            The <a href="#access-token-server-def">access token server</a> acts as a Policy Enforcement Point,
            making decisions on whether to grant access to the protected resource based on the provided
            <a href="#access-grant-token-def">access grant token</a> and <a>purpose</a>.
          </p>
        </section>

        <section id="inquiry-access-token-request">
          <h2>Inquiry Access Token Request</h2>
          <p>
          This request can be issued by the client after a session handle has been received in a response to an initial access token request.<br>
          The request shall contain at least the parameter below:
          <ul>
            <li>Session handle: The handle logically links the request to a previously issued initial access token request.</li>
          </ul>
          </p>
        </section>
        </section>

        <section id="access-token-response">
          <h2>Access Token Response</h2>
          <p>

        <section id="access-token-response-consent-not-required">
          <h2>Access Token Response Consent Not Required</h2>
          <p>
          In the case that the access control is not combined with a requirement for obtaining consent from the data owner,
          an immediate response is possible, and in the case of a successful response it shall contain the parameter:
          <ul>
            <li><a href="#access-token-def">Access token</a>: The token to be used in <a href="#client-def">client</a>
            requests to the VISSv3 server for Protected Resources.</li>
          </ul>
          An error response shall contain the parameter:
          <ul>
            <li>Error code: The error code shall be informative in order for the <a href="#client-def">client</a>
            to understand what it needs to correct to become successful.</li>
          </ul>
          </p>
        </section>

        <section id="access-token-response-consent-required">
          <h2>Access Token Response Consent Required</h2>
          <p>

        <section id="access-token-response-to-initial-access-token-request">
          <h2>Access Token Response To Initial Access Token Request</h2>
          <p>
          In the case that the access control is combined with a requirement for obtaining consent from the data owner,
          an immediate response is not possible, and the response to an initial access token request shall contain the parameter:
          <ul>
            <li>Session handle: A reference to the initial access token request that can be used by the client in subsequent inquiry requests.</li>
            <li>Consent status: There is at this point not any consent status received from the <a>ECF</a>, so consent status is set to NOT_SET.</li>
          </ul>
          </p>
        </section>

        <section id="access-token-response-to-inquiry-access-token-request">
          <h2>Access Token Response To Inquiry Access Token Request</h2>
          <p>
          There are three different responses possible to an inquiry access token request.<br>
          In the case that there is still no consent reply available from the <a>ECF</a>, the response is identical to the response to the initial access token response, see above.<br>
          In the case that there is a negative consent reply from the <a>ECF</a>, the response shall contain the parameter:
          <ul>
            <li>Consent status: The consent reply was negative, so consent status is set to NO.</li>
          </ul>
          In the case that there is a positive consent reply from the <a>ECF</a>, the response shall contain the parameters:
          <ul>
            <li><a href="#access-token-def">Access token</a>: The token to be used in <a href="#client-def">client</a>
            requests to the VISSv3 server for Protected Resources.</li>
            <li>Consent status: The consent reply was positive, so consent status is set to YES.</li>
          </ul>
          </p>
        </section>
        </section>
        </section>

        <section id="protected-resource-request">
          <h2>Protected Resource Request</h2>
          <p>
          This is a VISSv3 request including an <a href="#access-token-def">access token</a> as described in general in the
          <a href="#methods"></a> chapter,
          and for different <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#transport-protocols">
          transport protocols</a> in the [[viss3-transport-examples]] document.
          The first time a token is submitted in a request it must be provided in its entirety. If a server supports caching of access tokens and returns a token hanle to the client,
          then any following requests may provide the token handle instead of the complete access token.
          </p>
        </section>

        <section id="protected-resource-response">
          <h2>Protected Resource Response</h2>
          <p>
          This is a VISSv3 response as described in general in the <a href="#methods"></a> chapter,
          and for different <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#transport-protocols">transport protocols</a> in the [[viss3-transport-examples]] document.
          It does not differ from the response to an unprotected resource request.
          </p>
        </section>
      </section>

      <section id="actors">
        <h2>Actors</h2>

      <dfn id="client-def"></dfn>
      <section id="client">
        <h2>Client</h2>
        <p>
        <em>This section is non-normative.</em><br>
          The client is an abstract representation of three sub-actors:
          <ul>
            <li>The <a href="#device-roles-def">device</a>. It is in charge of running the Apps that make requests to the VISSv3 server</li>
            <li>The <a href="#application-roles-def">app. </a>It runs requests on behalf of the user.</li>
            <li>The <a href="#user-roles-def">user</a>. It delegates access rights to the app.</li>
          </ul>
          All the information regarding the client is encoded in the <a href="#client-context-def">context</a> of the request.
        </p>
      </section>

      <dfn id="access-grant-server-def"></dfn>
      <section id="access-grant-server">
        <h2>Access Grant Token Server</h2>
        <p>
        <em>This section is non-normative.</em><br>
          The access grant token server is in charge of producing <a href="#access-grant-token-def">access grant tokens</a> to
          <a href="#client-def">clients</a>.<br>
          Depending on the capabilities of the <a href="#client-def">client</a>, the specification supports two types of
          <a href="#access-grant-token-def">access grant tokens</a>: Short term and long term
          <a href="#access-grant-token-def">access grant tokens</a>.<br>
          Long term <a href="#access-grant-token-def">access grant tokens</a>,
          are supported for those <a href="#client-def">clients</a> able to run public key cryptographic primitives,
          i.e. key pair generation and signatures,
          and is the recommended choice for <a href="#client-def">clients</a> with access to a trusted execution environment where
          private keys are protected from the regular execution environment.
          The specification also supports short term <a href="#access-grant-token-def">access grant tokens</a> that require
          no extra capabilities in the client,
          but due to its shorter expiry time it forces the client to contact the access grant token server more often before
          <a href="#access-token-server-def">access token server</a> requests for an <a href="#access-token-def">access token</a>.<br>
          The <a href="#client-def">client</a> request shall contain the following:
          <ul>
            <li>A <a href="#client-context-def">client context</a>.</li>
            <li>A set of <a href="#proof-of-possession-def">proofs</a>.</li>
          </ul>
          In scenarios where both the client and the access grant token server are deployed in-vehicle the VIN parameter may be omitted,
          in all other deployment scenarios it shall be present.
          <ul>
            <li>A VIN.</li>
          </ul>
          When a VIN is present in the request, the vehicle identity (vin) claim shall be present in the
          <a href="#access-grant-token-def">access grant token</a>.<br>
          If the <a href="#client-def">client</a> needs a long term <a href="#access-grant-token-def">access grant token</a>,
          then the request shall also contain:
          <ul>
            <li>A public key.</li>
          </ul>
          The Vehicle identification number shall be for the vehicle that the <a href="#client-def">client</a> wants to access.<br>
          The <a href="#client-context-def">client context</a> contains all relevant information from the client,
          i.e. for each of the three sub-actors that the <a href="#client-def">client</a> represents.<br>
          The <a href="#proof-of-possession-def">proofs</a> are to be used for verifying the <a href="#client-context-def">client context</a>.<br>
          The public key shall be generated by the <a href="#client-def">client</a>,
          and the associated private key must be under control of the <a href="#client-def">client</a>.<br><br>
          The main responsibilities of the access grant token server are:
          <ul>
            <li>To verify the <a href="#client-context-def"> client context</a>, and assess that their respective role request can be granted.</li>
            <li>To check that the vehicle represented by the VIN belong to this Ecosystem, and is accessible.</li>
            <li>To create an <a href="#access-grant-token-def">access grant token</a>.</li>
          </ul>
          The <a href="#proof-of-possession-def">proofs</a> may include certificates from a Certificate Authority known by the
          access grant token server.
          For example, users might authenticate themselves using X.509 identity certificates and roles might be issued using attribute certificates.
          In those cases, as part of the authentication protocol,
          the access grant token server shall also validate the certificates signatures.<br>
          The access grant token server may contact the <a href="#ecosystem-manager-def">ecosystem manager</a> for checking the VIN.<br>
          The <a href="#access-grant-token-def">access grant token</a> generation is defined in the corresponding chapter.
        </p>
          </p>
        </section>

      <dfn id="access-token-server-def"></dfn>
      <section id="access-token-server">
        <h2>Access Token Server</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The <a href="#client-def">client</a> shall after a successful interaction with the
        <a href="#access-grant-server-def">access grant token server</a>
        request an <a href="#access-token-def">access token</a> from the access token server.
        The <a href="#client-def">client</a> request shall contain at least these two parameters below.
          <ul>
            <li><a href="#access-grant-token-def">Access grant token</a>.</li>
            <li><a>Purpose</a>.</li>
          </ul>
        For long term <a href="#access-grant-token-def">access grant tokens</a>, i.e. those including a public key, the
        <a href="#client-def">client</a> must also include a <a href="#proof-of-possession-def">proof of possession</a>,
        for the corresponding private key, in the request.<br>
        The <a>purpose</a> must be supported by the <a href="#ecosystem-manager-def">ecosystem manager</a>, and thus be on the
        <a href="#purpose-list-def">purpose list</a>.
        The <a href="#purpose-list-def">purpose list</a> associates a set of accessible signals to the <a>purpose</a>,
        thus realizing the principle of least privilege.<br>
        The main responsibilities of the access token server are:
          <ul>
            <li>To validate the <a href="#access-grant-token-def">access grant token</a>.</li>
            <li>To validate that the <a href="#client-context-def">client context</a> provides permission for the requested <a>purpose</a>.</li>
            <li>To create an <a href="#access-token-def">access token</a>.</li>
          </ul>
        The validation of the <a href="#access-grant-token-def">access grant token</a> consists of at least the following:
          <ul>
            <li>Signature validation.</li>
            <li>Expiry time check.</li>
          </ul>
        Additionally, for long term <a href="#access-grant-token-def">access grant tokens</a>, the access token server needs to verify the
        <a href="#proof-of-possession-def">proof of possession</a> using the public key contained in the token.<br>
        The <a href="#access-grant-token-def">access grant token</a> signature validation is done with the
        <a href="#access-grant-server-def">access grant token server</a> public key.
        <br>
        To allow for some time synchronization inaccuracy and minor network latency,
        expiry times should be set to include potential modest margin of error, possibly as long as tens of seconds.<br>
        If a vehicle identity claim (vin) is present in the <a href="#access-grant-token-def">access grant token</a>,
        the vehicle identity (vin) claim SHALL be included in the access token.<br>
        If the <a href="#client-context-def">client context</a> as declared in the <a href="#access-grant-token-def">access grant token</a>
        does not match in the set of allowed roles for the requested <a>purpose</a> in the <a href="#purpose-list-def">purpose list</a>,
        then the <a href="#client-def">client</a> request for an <a href="#access-token-def">access token</a> must be denied.<br>
        </p>
      </section>

      <section id="access-control-server">
        <h2>Access Control Server</h2>
        <p>
        The VISSv3 server MUST support validation of <a href="#access-token-def">access tokens</a>.
        The functionality needed for this is decribed in this chapter.
        This includes validation of at least the following:
          <ul>
            <li>Token signature.</li>
            <li>Token expiry time.</li>
          </ul>
          If a vehicle identity claim (vin) is present in the token, then it MUST be validated to match the identity of this vehicle.<br>
          If any of the mentioned validations fail, the server MUST reject the access request.<br>
          Token signature validation may be delegated to the <a href="#access-token-server-def">access token server</a>,
          if a secure communication link can be established.
          If not delegated, then a preprovisioned common secret may be shared with the <a href="#access-token-server-def">access token server</a>,
          or other PKI based solutions may be used.<br>
          The VISSv3 server SHALL have access to a secure system time, that cannot be modified by actors without system acknowledged credentials.
          Time validation may allow for a time synchronization inaccuracy in the range of tens of seconds.<br>
          After a successful token validation, the server MUST check that the scope of the token is compatible with the request.
          If the scope claim of the <a href="#access-token-def">access token</a> contains a <a>purpose</a> short-name, successful validation requires that all the nodes addressed by the path in the request MUST
          be matched by the paths associated with the <a>purpose</a> in the <a href="#purpose-list-def">purpose list</a> .<br>
          If the scope claim of the <a href="#access-token-def">access token</a> contains a explicit list of signals, successful validation requires that all the nodes addressed by the path in the request MUST
          be matched by the one of the signals included in the token.<br>
          Validation of the <a href="#device-roles-def">device</a> and <a href="#application-roles-def">app </a>roles may involve MAC address checks,
          or message round-trip measurements.<br>
          The access permission validation MUST have the outcome shown in the table below,
          when comparing the type of the <a href="#client-def">client</a> request with the access control mode either in the
          <a href="#purpose-list-def">purpose list</a> or the explicit signals that are associated to the scope claim in the <a href="#access-token-def">access token</a>.
          If the <a href="#client-def">client</a> request contains several signals, and one fails the validation,
          then the entire request MUST be rejected.<br><br>
          <table class="simple">
          <thead>
            <tr><th>Permission</th><th>read-only</th><th>read-write</th></tr>
          </thead>
          <tbody>
            <tr>
              <th rowspan="4">get<br>set<br>subscribe</th>
            </tr>
            <tr><td>Ok</td><td>Ok</td></tr>
            <tr><td>Nok</td><td>Ok</td></tr>
            <tr><td>Ok</td><td>Ok</td></tr>
          </tbody>
          </table>
        </p>
        <p>
          The <a href="#access-token-def">access token</a> need to be refreshed periodically, which is controlled by the expiry time.
          If the <a href="#access-grant-token-def">access grant token</a> that the <a href="#client-def">client</a> used to obtain the now expired
          <a href="#access-token-def">access token</a> is not expired,
          then the <a href="#client-def">client</a> can revisit the <a href="#access-token-server-def">access token server</a> with this
          <a href="#access-grant-token-def">access grant token</a> to obtain a new <a href="#access-token-def">access token</a>.<br>
          If the <a href="#access-grant-token-def">access grant token</a> is expired, then the <a href="#client-def">client</a> must obtain a new
          <a href="#access-grant-token-def">access grant token</a> first,
          before revisiting the <a href="#access-token-server-def">access token server</a>.<br>
          The server SHOULD support caching of a limited number of <a href="#access-token-def">access tokens</a>.
          The <a href="#access-token-def">access token</a> MUST be included in the cache after a first successful request and
          MUST be removed once they expire.
          If an access token is cached then the server shall return a token handle of at least 24 bytes long.
          The client may then use this instead of the complete access token in following requests that require this access token.
          If the client decides to include the access token handle in a request, the server must then fetch the corresponding access token from the cache,
          and verify its validity before deciding to grant the request.<br>
          The server might decide to remove any token from the cache. In the case this token is then referred to with a token handle the client will get a "401,
          missing_token" error and will be forced to send the whole <a href="#access-token-def">access token</a> again.
          For <a href="#client-def">client</a> requests that are not granted due to access control,
          the VISSv3 server MUST return one of the error codes shown in the table below.<br>
        <table id="errorDefs" class="parameters">
          <tbody><tr>
            <th>Error&nbsp;Number&nbsp;(Code)</th>
            <th>Error Reason</th>
            <th>Error Message</th>
          </tr>
          <tr>
            <td>401 (Unauthorized)</td>
            <td>missing_token</td>
            <td>One or more of the requested signals are access controlled, an <a href="#access-token-def">access token</a> or its jti,
            must be included in the request.</td>
          </tr>
          <tr>
            <td>406 (Not Acceptable)</td>
            <td>invalid_token</td>
            <td>In case the request included an <a href="#access-token-def">access token</a>, a fresh one must be obtained.
            In case the request included just the jti, the whole <a href="#access-token-def">access token</a> needs to be send again.</td>
          </tr>
          <tr>
            <td>406 (Not Acceptable)</td>
            <td>insufficient_priviledges</td>
            <td>The priviledges represented by the <a href="#access-token-def">access token</a> are not sufficient.</td>
          </tr>
          </tbody>
        </table>
        </p>
      </section>

      <dfn id="resource-owner-def"></dfn>
      <section id="resource-owner">
        <h2>Resource Owner</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The resource owner is typically the owner and/or driver of the vehicle. If Consent is required for granting access to the protected resource,
        then it should be directed to the resource owner. The process for this is out of scope for this specification.
        </p>
      </section>

      <dfn id="ecosystem-manager-def"></dfn>
      <section id="ecosystem-manager">
        <h2>Ecosystem Manager</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Ecosystem manager is the entity responsible for the functionality of the access control system.
        This typically includes the management of the <a href="#access-grant-server-def">access grant token server</a>,
        and the <a href="#access-token-server-def">access token server</a>, the Policy documents,
        and that there is a PKI domain for the other actors to utilize.
        </p>
      </section>
      </section>

      <section id="credentials">
        <h2>Credentials</h2>
        <p>
        </p>

        <section id="client-authentication">
          <h2>Client Authentication</h2>
          <p>
          <em>This section is non-normative.</em><br>
          The three <a href="#client-def">client</a> sub-actors must provide authentication credentials to the
          <a href="#access-grant-server-def">access grant token server</a>.
          This may be certificates that the sub-actors have obtained from a Certificate Authority that is known by the
          <a href="#access-grant-server-def">access grant token server</a>.
          The interactions related to this are out of scope.
          </p>
        </section>

        <dfn id="access-grant-token-def"></dfn>
        <section id="access-grant-token">
          <h2>Access Grant Token</h2>
          <p>
          <em>This section is non-normative.</em>
          </p>

          <section id="ags-signed-agtoken">
            <h2>Short Term Access Grant Token</h2>
            <p>
          The short term access grant token shall have the following claims in header and payload,
          where all but the vehicle identity (vin) claim are mandatory.<br>
          <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>
          {
            "alg": "ES256",
            "typ": "JWT"
          },
          {
            "vin": "vehicle-id",
            "iat": 1609452095,
            "exp": 1609459199,
            "clx": "user+app+dev",
            "aud": "covesa.global/VISSv3",
            "jti": "5967e92e-40e8-5f39-892d-cc0da890db1d"
          }
          </pre>
          The algorithm (alg) claim shall be set to a valid RSA or ECDSA algorithms according to [[RFC7518]].<br>
          The type (typ) claim shall be set to "JWT".<br>
          The vehicle identity (vin) claim may be present or not, depending on input to the
          <a href="#access-grant-server-def">access grant token server</a>.<br>
          The issued at (iat) claim shall be set to the time of token issuance, in Unix time.<br>
          The expiry (exp) claim shall be set to the time when the token expires, in Unix time.<br>
          The <a href="#client-context-def">Client context</a> (clx) claim shall be set to the role triplet that the client has been assigned.
          The delimiter separating the roles is a plus sign (+).<br>
          The audience (aud) claim shall be set to the URL "covesa.global/VISSv3".<br>
          The JSON Web Token identity (jti) claim shall be set to a UUID that is unique within the domain controlled by the
          <a href="#ecosystem-manager-def">ecosystem manager</a>.
            </p>
          </section>

          <section id="client-signed-agtoken">
            <h2>Long Term Access Grant Token</h2>
            <p>
          Except for the vehicle identity (vin) claim that is optional,
          the long term access grant token SHALL have the following claims in header and payload.<br>
          <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>
          {
            "alg": "ES256",
            "typ": "JWT"
          },
          {
            "vin": "vehicle-id",
            "iat": 1609452095,
            "exp": 1609459199,
            "clx": "user+app+dev",
            "pub": client_pub_key,
            "aud": "covesa.global/VISSv3",
            "jti": "5967e92e-40e8-5f39-892d-cc0da890db1d"
          }
          </pre>
          The algorithm (alg) claim shall be set to a valid RSA or ECDSA algorithms according to [[RFC7518]].<br>
          The type (typ) claim shall be set to "JWT".<br>
          The vehicle identity (vin) claim may be present or not, depending on input to the
          <a href="#access-grant-server-def">access grant token server</a>.<br>
          The issued at (iat) claim shall be set to the time of token issuance, in Unix time.<br>
          The expiry (exp) claim shall be set to the time when the token expires, in Unix time.<br>
          The <a href="#client-context-def">Client context</a> (clx) claim shall be set to the role triplet that the client has been assigned.
          The delimiter separating the roles is a plus sign (+).<br>
          The public key (pub) claim shall be set to the public key that the <a href="#client-def">client</a> provided in the
          <a href="#access-grant-request-def">access grant request</a>, using the JSON Web Key (JWK) data structure [[RFC7517]].<br>
          The audience (aud) claim shall be set to the URL "covesa.global/VISSv3".<br>
          The JSON Web Token identity (jti) claim shall be set to a UUID that is unique within the domain controlled by the
          <a href="#ecosystem-manager-def">ecosystem manager</a>.
            </p>
          </section>
        </section>

        <dfn id="access-token-def"></dfn>
        <section id="access-token">
          <h2>Access Token</h2>
          <p>
          Except for the vehicle identity (vin), and client context (clx) claims that are optional,
          the Access token SHALL have the following claims in header and payload.<br>
          <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>
          {
            "alg": "HS256",
            "typ": "JWT"
          },
          {
            "vin": "vehicle-id",
            "iat": 1609452095,
            "exp": 1609459199,
            "scp": "PurposeX" || signal-set,
            "clx": "user+app+dev",
            "aud": "covesa.global/VISSv3",
            "jti": "5967e93f-40f9-5f39-893e-cc0da890db2e"
          }
          </pre>
          The algorithm (alg) claim shall be set to any valid algorithms according to [[RFC7518]].<br>
          The type (typ) claim shall be set to "JWT".<br>
          The vehicle identity claim (vin) may be present or not, depending on its presence in the
          <a href="#access-grant-token-def">access grant token</a>.<br>
          The issued at (iat) claim shall be set to the time of token issuance, in Unix time.<br>
          The expiry (exp) claim shall be set to the time when the token expires, in Unix time.<br>
          The scope (scp) claim shall be set to either a <a href="#purpose-list-def">purpose list</a> short name,
          which logically links to the signal scope as defined in the <a href="#purpose-list-def">purpose list</a>,
          or to a set of signals that the token permits access to.
          Each signal is defined as a JSON object containing the signal path, and the signal permission as shown below.<br>
          {"path":"vss-path", "access_permission":"permission"}<br>
          If the scope claim is set to a purpose, the client context claim MUST be present in the token.<br>
          The <a href="#client-context-def">Client context</a> (clx) claim shall be set to the role triplet that the client has been assigned.
          The delimiter separating the roles is a plus sign (+).<br>
          The audience (aud) claim shall be set to the URL "covesa.global/VISSv3".<br>
          The JSON Web Token identity (jti) claim shall be set to an unguessable UUID that is unique within the domain controlled by the
          <a href="#ecosystem-manager-def">ecosystem manager</a>.
          </p>
        </section>

        <dfn id="proof-of-possession-def"></dfn>
        <section id="proof-of-possession">
          <h2>Proof of Possession</h2>
          <em>This section is non-normative.</em><br>

          <p>
            Long term <a href="#access-grant-token-def">access grant tokens</a> need to be accompanied by a Proof of Possession (PoP)
            for the private key corresponding to the public key included in the <a href="#access-grant-token-def">access grant token</a>.
            This requirement enables a longer validity for this kind of tokens, ranging from a few days to a even a year.
            By adding the PoP, an eavesdropper is prevented to reuse an <a href="#access-token-def">access token</a> request,
            impersonating the client. Without a PoP, the longer the validity of an <a href="#access-grant-token-def">access grant token</a>,
            the higher the risk an attacker could intercept and reuse it.
            PoP for JWT are defined in [[RFC7800]], but in essence,
            a PoP enables the requester to proof to the server that it has access to a private key, without disclosing it.
            Traditionally that would require the server to create a random challenge, or nonce, and ask the client to sign it with its private key.
            Along with the public key,
            the server would be able to verify the PoP.
            This scheme would require an extra step in the protocols, where the client ask for the nonce.
          </p><p>
            In order to avoid this extra step, the client can generate the nonce itself. The server would need to check that nonces are not reused.
            Although logging previous nonces at the server side would work for small environments,
            the use of an incremental nonce in the form of a timestamp is proposed.
            One of the drawbacks of this proposal is that the server has no means to check whether the PoP has been precomputed or not.
            However, this is irrelevant from the eavesdropper point of view.
          </p><p>
            In case freshness of the PoP was a critical requirement, a public source of randomness to obtain the nonce could be used,
            e.g. <a href="https://www.cloudflare.com/leagueofentropy/">Leage of Entropy</a> or
            <a href="https://csrc.nist.gov/projects/interoperable-randomness-beacons">Interoperable Randomness Beacons</a>.
            That would provide the server a mean to check freshness of the PoP but on the other hand,
            it would require the client to access the public source of randomness every time it needs to create a PoP
            which is against the main design goals for the long term <a href="#access-grant-token-def">access grant token</a>.
              </li>
            </ul>
          </p>
        </section>
      </section>

      <dfn id="client-context-def"></dfn>
      <section id="client-context">
        <h2>Client Context</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The client context contains a <a href="#client-def">client</a> actor that is characterized by three subactors:
          <ul>
            <li>The <a href="#user-roles-def">user</a> of the application.</li>
            <li>The <a href="#application-roles-def">application</a>.</li>
            <li>The <a href="#device-roles-def">device</a>.</li>
          </ul>
          Each of these subactors is in turn characterized by a role,
          building on the concept of a <a href="https://en.wikipedia.org/wiki/Role-based_access_control">Role Based Access Control (RBAC) model</a>.
          The set of these three roles is called the Client context.<br>
          VISSv3 specifies a rudimentary list of roles for each subactor, it is expected that these lists are augmented by the
          <a href="#ecosystem-manager-def">ecosystem manager</a>, hopefully in a cooperative effort.<br>
          Using an RBAC model provides the following main purposes in the VISSv3 access control model:
          <ul>
            <li>Input to the <a href="#access-grant-server-def">access grant token server</a> in the
            <a href="#client-def">client</a> authentication process.</li>
            <li>Input to the <a href="#access-token-server-def">access token server</a> in the <a>purpose</a> validation.</li>
          </ul>
        The <a href="#access-grant-server-def">access grant token server</a> must in the authentication process of the client
        possibly separately authenticate each of the three subactors.
        For the <a href="#access-grant-server-def">access grant token server</a> to decide on which authentication method to use per subactor
        can be quite complex, but may be somewhat eased by the <a href="#client-def">client</a> request for roles for each subactor.<br>
        Following the principle of least priviledge, a <a href="#client-def">client</a> should not have access to more vehicle signals than necessary.
        This is achieved by the <a href="#purpose-list-def">purpose list</a>, that assigns only the for the
        <a>purpose</a> relevant signals to the <a href="#client-def">client</a>.
        </p>

        <dfn id="user-roles-def"></dfn>
        <section id="user-roles">
          <h2>User Roles</h2>
          <p>
          VISSv3 specifies the following minimum set of roles for users:
          <ul>
            <li>OEM</li>
            <li>Dealer</li>
            <li>Independent</li>
            <li>Owner</li>
            <li>Driver</li>
            <li>Passenger</li>
          </ul>
          An OEM user is anyone representing the vehicle brand.<br>
          A Dealer user is anyone representing a normally OEM affiliated organisation that provide sale and workshop services for the vehicle.<br>
          An Independent user is anyone representing a normally OEM independent organisation that provide after-market services for the vehicle.<br>
          An Owner user is anyone representing the organisation owning the vehicle.<br>
          A Driver user is anyone driving the vehicle.<br>
          A Passenger user is anyone travelling in the vehicle, but not being the Driver.<br>
          </p>
        </section>

        <dfn id="application-roles-def"></dfn>
        <section id="application-roles">
          <h2>Application Roles</h2>
          <p>
          VISSv3 specifies the following minimum set of roles for applications:
          <ul>
            <li>OEM</li>
            <li>Third party</li>
          </ul>
          An OEM application role is used for applications that are pre-installed in the vehicle by the OEM, or later OEM-provisioned to the vehicle.<br>
          A Third party application role is used for applications that
	  are approved by automotive manufacturer for vehicle deployment, but developed by a third party.<br>
          </p>
        </section>

        <dfn id="device-roles-def"></dfn>
        <section id="device-roles">
          <h2>Device Roles</h2>
          <p>
          VISSv3 specifies the following minimum set of roles for devices:
          <ul>
            <li>Vehicle</li>
            <li>Nomadic</li>
            <li>Cloud</li>
          </ul>
          A Vehicle role is used for <a href="#application-roles-def">applications</a> that are deployed in-vehicle, in e. g. the center stack ECU.<br>
          A Nomadic role is used for <a href="#application-roles-def">applications</a> that are deployed in a user's mobile phone, laptop, etc,
          that uses short range radio communication like Bluetooth, or WiFi.<br>
          A Cloud role is used for <a href="#application-roles-def">applications</a> that are deployed in off-vehicle devices,
          and uses a long range radio communication like cellular in the connection to the vehicle.<br>
          </p>
        </section>
      </section>

      <section id="policy-documents">
        <h2>Policy Documents</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Policy documents are typically owned and created by the <a href="#ecosystem-manager-def">ecosystem manager</a>.
        They need to be handled securely to protect their integrity.
        The <a href="#ecosystem-manager-def">ecosystem manager</a> shall securely provision them to the
        <a href="#access-token-server-def">access token servers</a> in the access control ecosystem.
        </p>

          <dfn id="purpose-list-def"></dfn>
          <section id="purpose-list">
            <h2>Purpose List</h2>
            <p>
        A <a href="#client-def">client</a> shall provide a <a>purpose</a> as input to a request for an <a href="#access-token-def">access token</a>.
        A list of supported purposes needs to exist for a client to select from.
        The <a href="#ecosystem-manager-def">ecosystem manager</a> shall therefore provide means for <a href="#client-def">clients</a>
        to survey the list to find a <a>purpose</a> that fits its use case.<br>
        Each entry in the list contains a short description of the purpose, which is what the <a href="#client-def">client</a>
        shall provide as input to its request for an <a href="#access-token-def">access token</a>.
        There is also a long purpose description, which may be used in the dialogue for consent, if needed.
        Then there is a list of the <a href="#client-context-def">client context</a>, i. e. the sub-actor role triplet,
        that can be granted this access, and last there is a list of  the signals that the client is given access to for this purpose,
        with the access control and consent requirements. The list shall use a JSON format as shown in the example below.
        <pre><code>
        {"purposes":
            [{"short": "fuel-status",
            "long": "Fuel level and remaining range.",
            "contexts":[{"user":"Independent","app":["OEM", "Third party"], "device":"Cloud"}, {"user":"Owner", "app":"Third party", "device":"Nomadic"}, {"user":"Driver", "app":"OEM", "device":"Vehicle"}],
            "signal_access":
                [{"path": "Vehicle.Powertrain.FuelSystem.Level", "access_permission": "read-only"},
                {"path": "Vehicle.Powertrain.FuelSystem.Range", "access_permission": "read-only"}]
            },
            {}]
        }
        </code></pre>
        The purpose list shall be securely provisioned to the <a href="#access-token-server-def">access token server</a>.
        The protocol for this is out-of-scope.
        The <a href="#access-token-server-def">access token server</a> must reject all requests for <a href="#access-token-def">access tokens</a>
        if it is not in possession of a purpose list.
            </p>
          </section>

          <section id="scope-list">
            <h2>Scope List</h2>
            <p>
            The scope list contains a list of the VSS tree nodes for which access shall be prohibited, per
            <a href="#client-context-def">client context</a>.
            This prohibition is regardless of whether the <a href="#client-def">client</a> has a valid
            <a href="#access-token-def">access token</a> or not.<br>
            The scope list can also be used to limit the node metadata that is returned on a signal discovery request.<br>
            Each entry in the list contains a list of paths to nodes that should be excluded, and a list of the
            <a href="#client-context-def">client contexts</a>, i. e. the sub-actor role triplet,
            for which this exclusion should be made.<br>
            The scope list may contain an entry for a context with all three Roles set to "Undefined".
            The no-access scope of this entry shall then be used for signal discovery requests where no token is included.
            An entry in the no_access array that addresses a branch results in no access to the subtree of this branch.<br>
            The list shall use a JSON format as shown in the example below.
        <pre><code>
        {"scope":
            [{"contexts":[ { "user":["Driver", "Passenger"], "app":"Third party", "device":"Vehicle"}, { } ],
            "no_access":
                ["Vehicle.Drivetrain.Transmission.Speed",
                "Vehicle.CurrentLocation.Latitude",
                "Vehicle.CurrentLocation.Longitude"]
            },
            {}]
        }
        </code></pre>
        The scope list shall be securely provisioned to the <a href="#access-token-server-def">access token server</a>.
        The protocol for this is out-of-scope.
        The <a href="#access-token-server-def">access token server</a> shall not restrict the scope for any
        <a href="#client-context-def">client context</a> if it is not in possession of a scope list.
            </p>
          </section>
      </section>

      <section id="access-control-selection">
        <h2>Access Control Selection</h2>
        <p>
        <em>This section is non-normative.</em><br>
        This chapter describes a complementary functionality to the access control model, the ability to apply it selectively to parts of the tree.
        It can be used in cases where not all nodes of the tree are believed to require access control,
        or where write-only validation is sufficient instead of read-write validation for certain nodes.<br>
        This functionality requires that the <a href="#access-token-def">access token</a> specifies whether the access permission granted to the
        <a href="#client-def">client</a> to a signal is read-only, or read-write.
        It also requires that the metadata for the node in the VSS tree contains data specifying whether
        the access control verification should be carried out only for write request, or for both read and write requests.<br>
        The former requirement is realized as described in earlier chapters by that the <a href="#access-token-def">access token</a>
        scope claim links to a <a>purpose</a> where the signals and their respective access permission are found.<br>
        The latter requirement is realized by adding to nodes in the VSS tree the key-value pair "validate":'access-control-mode',
        where 'access-control-mode' is either the string "write-only", or "read-write".<br>
        <figure id="fig-access-control-selection">
          <img src="images/access-control-selection.jpg" alt="Access control selection tagging.">
          <figcaption> <span class="fig-title">Access control selection tagging.</span></figcaption>
        </figure>
        The figure above shows an example where both read and write requests to the three leftmost leaf nodes will be access controlled,
        while the two rightmost leaf nodes only will be access controlled for write requests.
        An inheritance rule leads to that any nodes below a tagged node are assigned the same access control, if they are untagged.<br>
        This metadata is not likely to be applied to the standardised VSS tree,
        as different implementers of this standard may have different views on which nodes to apply it to.
        Instead it is anticipated that it is applied at a "deployment" stage, possibly using the VSS layering concept.<br>
        The inheritance model, which says that if access-control-mode data is added to a node,
        then all nodes in the subtree for which this node is the root inherits the setting,
        unless there is access-control-mode data added to any node in this subtree,
        makes possible a reduction of the number of nodes this metadata have to be added to.<br>
        This allows for example an entire VSS tree to be assigned an access-control-mode by merely applying it in the root of the tree.<br>
        The figure below shows an overview of the access control selection model,
        and a table showing the required access control tagging of a node for the VISSv3 server to grant the requested access.
        <figure id="fig-access-control-selection-model">
          <img src="images/access-control-selection-model.jpg" alt="Access control selection model.">
          <figcaption> <span class="fig-title">Access control selection model.</span></figcaption>
        </figure>
        If the VSS tree used by a VISSv3 server contains access control selection tags,
        then the server MUST support their usage as described in this chapter.<br>
        If it is not used, then a server may implement access control for the entire tree.<br>
        </p>
      </section>
    </section>

    <section id="consent-support">
      <h2>Consent support</h2>
      <em>This section is non-normative.</em><br>
      <p>
      Handling of consent involves vehicle and cloud architectural subsystems that is out of scope in VISSv3.
      However, a VISSv3 vehicle server has a capability to enforce consent results, i. e. to allow or block access to requested data.
      This can be leveraged in a model where the server receives consent results from an <a>ECF</a> and uses that information to either grant client requests,
      or not, for data that is consent protected. How the <a>ECF</a> obtains the consent status is out-of-scope in this specification.
      A secure, local communication channel exists between the in-vehicle <a>ECF</a> and the server as shown in the figure below,
      over which the server can inquire about the consent status for data requested by a client.
      <figure id="fig-consent-architecture">
        <img src="images/consent-architecture.jpg" alt="Consent architecture.">
        <figcaption> <span class="fig-title">Consent architecture.</span></figcaption>
      </figure>
      The <a>ECF</a> is responsible for the lifetime management of the consent status for all data that is managed by the server, which may involve initialization,
      event based update, consent status removal.<br>
      The consent status can be set to any of the following values:<br>
        <ul>
            <li>NOT_SET // the server must request the <a>ECF</a> for the status. Unless an immediate <a>ECF</a> response is given,
            the server must deny any client request with an error code that shows the reason.</li>
            <li>NO  // the server must deny any client request with an error code that shows the reason.</li>
            <li>IN_VEHICLE // the server shall serve the client request. The client is not allowed to off-board the data.</li>
            <li>YES // the server shall serve the client request. The client is allowed to off-board the data.</li>
        </ul>
      It shall be possible for the <a>ECF</a> to cancel a valid consent, which shall lead to the consent status being set to NOT_SET.
      Any consequences to the data provided to the client prior to the cancelling is out of scope.<br>
      In the case of a client request requiring a consent for data to be returned, it is the responsibility of the
      <a href="#access-token-server-def">access token server</a> to obtain it from the <a>ECF</a> during the dialogue with a client requesting an access token.
      This is done by issuing a request to the <a>ECF</a> which shall contain the following information:
        <ul>
            <li>The requested data.</li>
            <li>The purpose of the request.</li>
            <li>The client context.</li>
        </ul>
      The response from the <a>ECF</a> shall contain:
        <ul>
            <li>Consent status.</li>
        </ul>
      If the received consent status is set to NO or NOT_SET, then the access token server must not provide a valid access token to the requesting client.
      The server must store the consent status that it receives from the <a>ECF</a>, together with the data from the request for the duration of the associated service,
      or until a consent cancellation is received.<br>
      Whether a server shall take action to obtain a consent or not shall be signalled in the VSS tree.
      This is done by tagging appropriate nodes in the VSS tree extending the model used for access control selection.
      The key-value pair used for tagging of access control is suffixed with "+consent" as shown in the example below:
        <ul>
            <li>"validate":"read-write+consent"</li>
        </ul>
      The consent tagging follows the same inheritance rules as defined for the access control tagging.
      </p>

      <section id="external-consent-framework-interface">
        <h2>External Consent Framework Interface</h2>
        <p>
         A server receiving a client request that involves obtaining a consent status shall send a request to the <a>ECF</a>
         on which it shall receive a response cintaining the consent status.

         The request shall contain the data from the list in the previous chapter.

         The response shall contain the data shown in the table above.

         This communication shall be carried out using a secure channel (e.g. TLS).
        </p>
      </section>
    </section>

    <section id="file-transfer" class="appendix">
          <h2>File Transfer</h2>
          <em>This appendix is non-normative.</em><br>
          <p>
          File transfer use cases, where a client either sends or receives a file from the vehicle server,
          can e. g. be a client that wants to push a map to the vehicle, or a client that wants to receive a video recording clip from the vehicle.<br>
          File resources reprsented in the VSS tree can either be read-only, represented by the sensor node type,
          or read-write, represented by the actuator node type. In either case the node datatype MUST be "filedescriptor",
          which is a struct datatype with the following fixed definition:
          <pre><code>
          typedef FileDescriptor struct {
              name string
              hash string
              uid string
          }
          </code></pre>
          The FileDescriptor name member SHALL have a dot separated file extension that identifies the file format.<br>
          The FileDescriptor hash member SHALL be a SHA-1 hash calculated on the content of the file.<br>
          The FileDescriptor uid member SHALL be a base64 encoded random uint64 value.<br><br>
          File transfer from client to server, or in the other direction, follows the model shown in the two sequence diagrams below.
          The server exposes two communication channels, a control channel and a data channel.
          The control channel is the channel where the primary VISSv3.0 payloads are communicated, 
          while the data channel is a channel over which the the file transfer data is communicated.
          The file transfer data consists of the data from the file, split into appropriate size chunks, and prepended by a header.
          The header consists of three fixed size parameters as shown in the list below.
        <ul>
            <li>uid: 8 bytes. A unique identifier for this file transfer session.</li>
            <li>messageNo: 1 byte. Starting at zero and increasing by one for each file chunk that is transferred.
            Maximum value is 254.</li>
            <li>file chunk size: 4 bytes. The size in bytes of this message, including the header size.</li>
            <li>lastMessage: 1 byte. Indiates whether this message is the last message in the transfer of this file.
          The value zero indicates that this is not the last message, while a non-zero value indicates that it is the last message.</li>

        </ul>
        <figure id="fig-file-download">
          <img src="images/file-download-sequence-diagram.png" alt="VISSv3 file download.">
          <figcaption> <span class="fig-title">VISSv3 file download.</span></figcaption>
        </figure>
        The client SET request on the control channel is exemplified below in the primary payload format.
          <pre><code>
{
  "action": "set",
  "path": "Vehicle.Cabin.Infotainment.privateMap",
  "value": {
    "name": "privateMap.kml",
    "hash": "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed",
    "uid" "MTIzNDU2Nzg5MA=="
  }
}
          </code></pre>
        The Ok response would in primary payload format look like:
          <pre><code>
{"action": "set", "ts": "2024-08-20T11:30:00Z"}
          </code></pre>
        The client message on the data channel consists of a concatenation of the header and the file chunk.
        The server response on this contains a concatanation of the three parameters shown below.
        <ul>
            <li>uid: 8 bytes. The identifier from the received message.</li>
            <li>messageNo: 1 byte. The message number from the received message.</li>
            <li>status: 1 byte. Indiates whether the message was correctly received or not.
          The value zero indicates that it was correctly received, while a non-zero value indicates that it was not.</li>
        </ul>
        If the SET request on the control channel receives an error message then the client shall not issue any SET requests on the data channel.<br>
        If the client message on the data channel receives an error response then the client hall send the same message again.
        If this results in another error response the client shall terminate the download session.<br>
        

        <figure id="fig-file-upload">
          <img src="images/file-upload-sequence-diagram.png" alt="VISSv3 file upload.">
          <figcaption> <span class="fig-title">VISSv3 file upload.</span></figcaption>
        </figure>
        The server GET request and response on the control channel are exemplified below in the primary payload format.
          <pre><code>
{"action": "get", "path": "Vehicle.Cabin.DashCam.Clip"}

{
  "action": "get",
  "data": {
    "path": "Vehicle.Cabin.DashCam.Clip", 
    "dp" {
      "value": {"name": "dashCamClip.mp4", "hash": "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed", "uid" "MTIzNDU2Nzg5MA=="},
      "ts": "2024-08-20T11:30:00Z"
    }
  }
}
          </code></pre>
        If the GET request on the control channel receives an error message then the client shall not issue any messages on the data channel.
        Client messages has the same format as the server messages in the file download scenario,
        and as in that case it refers to the previously received message from the server.
        The client must issue an initial message of this ype to trigger the server to respond,
        in this first message the message number is set to 255 (all bits set to one).
        The client shall send a final message after receiving the last message from the server.
        If the status is set to zero the server shall respond with only the header from its last message.<br>
        If the GET request on the data channel receives an error response then the client shall terminate the upload session.
        The client should calculate the file hash on the received file data after the session is concluded
        and compare with the file hash value received in the GET on the control channel.
        If they differ the received file is likely corrupt.<br><br>
        A client may terminate a file download session on the data channel by sending only the header by setting the message number to 255, 
        the chunk size to zero, and the last message to non-zero, on which the server shall respond with status set to zero.<br>
        A file upload session is terminated by the client by not issuing a message with both the message number and the status set to 255.<br>
        The node type for the file resource MUST be "file".
        This node type has a fixed datatype,  a struct with the members "name", "hash", and "size",
        c. f. the HIM specification for the "file" node type definition.
          </p>
        <h3>Data channel realization</h3>
        <p>
        If file transfer is realized over any supported transport protocol, this must then be shown in the server capabilities tree,
        together with the information needed for a client to access the data channel.
        The default mechanism for realizing a data channel is to assign a port number for it.
        The list below shows the recommended port numbers for the HTTP and WebSocket protocols.
        <ul>
            <li>HTTP port number: 445</li>
            <li>WebSocket port number: 6445</li>
        </ul>
        The recommended mechanism for MQTT is to assing a separate topic name to the data channel.
        The recommended topic name is created by appending "/datachannel" to the topic name of the control channel.
        Examples for Websockets and MQTT are found in the [[viss3-transport-examples]] specification.
        </p>
        <h3>Alternative based on well-known file transfer protocols</h3>
        <p>
        There exists a number of common file transfer protocols e. g. ftp, sftp, ftps,
        and scp which are widely adopted and have been optimized over many years.
        For larger files these may be a more efficient solution than the integrated VISS protocol.
        The model for using any of these intead builds on that the client can access the needed informattion to connect to the end point
        that is offering the use of the file transfer protocol to access the file.
        This information is available as a struct data point of the tree node.
        This struct should have members similar to what is shown below, depending on what is required to initiate he file transfer.
          <pre><code>
          struct {
              schema string
              port uint32
              path string
              filename string
          }
          </code></pre>
          Schema is the file transfer protocol schema.<br>
          Port is the port number for this service, at least for the initial setup.<br>
          Path is the URL path for this service.<br>
          Filename is the file name of the file to be transferred. It shall include a file extension that defines the format of the file.<br>
          The node type of this tree node shall be "sensor" for files that can only be uploaded to a client, and "actuator" for the file download case.
        </p>
    </section>

    <section id="json-schema" class="appendix">
          <h2>JSON Schema</h2>
          <p>
          The payloads that are sent over any transport protocol SHALL conform with the JSON schema in this appendix,
          unless otherwise specified in the VISSv3 TRANSPORT-EXAMPLE or VISSv3 PAYLOAD-ENCODING specifications.<br>
          </p>
              <pre><code>
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://covesa.global/vissv2.0.bundled.schema.json",
  "title": "VISSv2",
  "description": "VISS version 2.0 bundled schema",
  "type": "object",
  "properties": {
    "action": {
      "type": "string"
    }
  },
  "required": ["action"],
  "oneOf": [
    {
      "properties": {
        "action": { "const": "get" }
      },
      "$ref": "/vissv2.0/get-message.schema.json"
    },
    {
      "properties": {
        "action": { "const": "set" }
      },
      "$ref": "/vissv2.0/set-message.schema.json"
    },
    {
      "properties": {
        "action": { "const": "subscribe" }
      },
      "$ref": "/vissv2.0/subscribe-message.schema.json"
    },
    {
      "properties": {
        "action": { "const": "unsubscribe" }
      },
      "$ref": "/vissv2.0/unsubscribe-message.schema.json"
    },
    {
      "properties": {
        "action": { "const": "subscription" }
      },
      "$ref": "/vissv2.0/subscription-event.schema.json"
    }
  ],
  "$defs": {
    "https://covesa.global/vissv2.0/get-message.schema.json": {
  "$id": "https://covesa.global/vissv2.0/get-message.schema.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "VISSv2-get-message",
  "description": "VISSv2 get request and response messages",
  "type": "object",
  "oneOf": [
    {
      "properties": {
        "path": {
          "description": "The path",
          "type": "string"
        },
        "filter": {
          "$ref": "https://covesa.global/vissv2.0/filter.schema.json"
        },
        "authorization": {
          "description": "The access token",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["path"]
    },
    {
      "properties": {
        "data": {
          "$ref": "https://covesa.global/vissv2.0/data.schema.json"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["data", "ts"]
    },
    {
      "properties": {
        "metadata": {
          "type": "object",
          "description": "The metadata"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["metadata", "ts"]
    },
    {
      "properties": {
        "error": {
          "$ref": "https://covesa.global/vissv2.0/error.schema.json"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["error", "ts"]
    }
  ]
    },
    "https://covesa.global/vissv2.0/set-message.schema.json": {
  "$id": "https://covesa.global/vissv2.0/set-message.schema.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "VISSv2-set-message",
  "description": "VISSv2 set request and response messages",
  "type": "object",
  "oneOf": [
    {
      "properties": {
        "path": {
          "description": "The path",
          "type": "string"
        },
        "value": {
          "description": "The value",
          "type": "string"
        },
       "authorization": {
          "description": "The access token",
          "type": "string"
        },
        "requestId": {
         "description": "The request id",
         "type": "string"
        }
      },
      "required": ["path", "value"]
    },
    {
      "properties": {
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["ts"]
    },
    {
      "properties": {
        "error": {
          "$ref": "https://covesa.global/vissv2.0/error.schema.json"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["error", "ts"]
    }
  ]
    },
    "https://covesa.global/vissv2.0/subscribe-message.schema.json": {
  "$id": "https://covesa.global/vissv2.0/subscribe-message.schema.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "VISSv2-subscribe-message",
  "description": "VISSv2 subscribe request and response messages",
  "type": "object",
  "oneOf": [
    {
      "properties": {
        "path": {
          "description": "The path",
          "type": "string"
        },
        "filter": {
          "$ref": "/vissv2.0/filter.schema.json"
        },
        "authorization": {
          "description": "The access token",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["path", "filter"]
    },
    {
      "properties": {
        "authorization": {
          "description": "The access token handle",
          "type": "string"
        },
        "subscriptionId": {
          "description": "The subscription Id",
          "type": "string"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["subscriptionId", "ts"]
    },
    {
      "properties": {
        "error": {
          "$ref": "https://covesa.global/vissv2.0/error.schema.json"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["error", "ts"]
    }
  ]
    },
    "https://covesa.global/vissv2.0/unsubscribe-message.schema.json": {
  "$id": "https://covesa.global/vissv2.0/unsubscribe-message.schema.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "VISSv2-unsubscribe-message",
  "description": "VISSv2 unsubscribe request and response messages",
  "type": "object",
  "oneOf": [
    {
      "properties": {
        "subscriptionId": {
          "description": "The subscription Id",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["subscriptionId"]
    },
    {
      "properties": {
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["ts"]
    },
    {
      "properties": {
        "error": {
          "$ref": "https://covesa.global/vissv2.0/error.schema.json"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["error", "ts"]
    }
  ]
    },
    "https://covesa.global/vissv2.0/subscription-event.schema.json": {
  "$id": "https://covesa.global/vissv2.0/subscription-event.schema.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "VISSv2-subscription-event",
  "description": "VISSv2 subscription event",
  "type": "object",
  "oneOf": [
    {
      "properties": {
        "subscriptionId": {
          "description": "The subscription Id",
          "type": "string"
        },
        "data": {
          "$ref": "/vissv2.0/data.schema.json"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["subscriptionId", "data", "ts"]
    },
    {
      "properties": {
        "subscriptionId": {
          "description": "The subscription Id",
          "type": "string"
        },
        "error": {
          "$ref": "https://covesa.global/vissv2.0/error.schema.json"
        },
        "ts": {
          "description": "The time stamp",
          "type": "string"
        },
        "requestId": {
          "description": "The request id",
          "type": "string"
        }
      },
      "required": ["subscriptionId", "error", "ts"]
    }
  ]
    },
    "https://covesa.global/vissv2.0/filter.schema.json": {
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://covesa.global/vissv2.0/filter.schema.json",
  "title": "VISSv2.0-filter",
  "description": "VISS version 2.0 filter",
  "type": "object",
  "properties": {
    "variant": {
      "type": "string"
    }
  },
  "required": ["variant"],
  "oneOf": [
    {
      "properties": {
        "variant": { "const": "paths" },
        "parameter": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": ["parameter"]
    },
    {
      "properties": {
        "variant": { "const": "timebased" },
        "parameter": {
          "properties": {
            "period": {
              "type": "string"
            }
          },
          "required": ["period"]
        }
      },
      "required": ["parameter"]
    },
    {
      "oneOf": [
        {
          "properties": {
            "variant": { "const": "range" },
            "parameter": {
              "type": "object",
              "properties": {
                "boundary-op": {
                  "type": "string",
                  "enum": ["eq", "ne", "gt", "gte", "lt", "lte"]
                },
                "boundary": {
                  "type": "string"
                }
              },
              "required": ["boundary-op", "boundary"]
            }
          },
          "required": ["parameter"]
        },
        {
          "properties": {
            "variant": { "const": "range" },
            "parameter": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "boundary-op": {
                    "type": "string",
                    "enum": ["eq", "ne", "gt", "gte", "lt", "lte"]
                  },
                  "boundary": {
                    "type": "string"
                  },
                  "combination-op": {
                    "type": "string",
                    "enum": ["AND", "OR"]
                  }
                },
                "required": ["boundary-op", "boundary"]
              },
              "minItems": 2,
              "maxItems": 2
            }
          },
          "required": ["parameter"]
        }
      ]
    },
    {
      "properties": {
        "variant": { "const": "change" },
        "parameter": {
          "properties": {
            "logic-op": {
              "type": "string",
              "enum": ["eq", "ne", "gt", "gte", "lt", "lte"]
            },
            "diff": {
              "type": "string"
            }
          },
          "required": ["logic-op", "diff"]
        }
      },
      "required": ["parameter"]
    },
    {
      "properties": {
        "variant": { "const": "curvelog" },
        "parameter": {
          "properties": {
            "maxerr": {
              "type": "string"
            },
            "bufsize": {
              "type": "string"
            }
          },
          "required": ["maxerr", "bufsize"]
        }
      },
      "required": ["parameter"]
    },
    {
      "properties": {
        "variant": { "const": "history" },
        "parameter": {
          "type": "string"
        }
      },
      "required": ["parameter"]
    },
    {
      "oneOf": [
        {
          "properties": {
            "variant": { "const": "static-metadata" },
            "parameter": {
              "type": "string"
            }
          },
          "required": ["parameter"]
        },
        {
          "properties": {
            "variant": { "const": "static-metadata" },
            "parameter": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["parameter"]
        }
      ]
    },
    {
      "oneOf": [
        {
          "properties": {
            "variant": { "const": "dynamic-metadata" },
            "parameter": {
              "type": "string"
            }
          },
          "required": ["parameter"]
        },
        {
          "properties": {
            "variant": { "const": "dynamic-metadata" },
            "parameter": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["parameter"]
        }
      ]
    }
  ]
    },
    "https://covesa.global/vissv2.0/data.schema.json": {
  "$id": "https://covesa.global/vissv2.0/data.schema.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "VISSv2-data-representation",
  "description": "VISSv2 data representation",
  "oneOf": [
    {
      "type": "object",
      "$ref": "/vissv2.0/datapoint-single.schema.json"
    },
    {
      "type": "object",
      "$ref": "/vissv2.0/datapoint-multiple.schema.json"
    },
    {
      "type": "array",
      "items": {
        "$ref": "/vissv2.0/datapoint-single.schema.json"
      }
    },
    {
      "type": "array",
      "items": {
        "$ref": "/vissv2.0/datapoint-multiple.schema.json"
      }
    }
  ],
  "$defs": {
    "https://covesa.global/vissv2.0/datapoint-single.schema.json": {
      "$id": "https://covesa.global/vissv2.0/datapoint-single.schema.json",
      "$schema": "https://json-schema.org/draft/2020-12/schema",
      "title": "VISSv2-single-datapoint",
      "description": "VISSv2 single datapoint",
      "properties": {
        "path": {
          "description": "The path",
          "type": "string"
        },
        "dp": {
          "description": "The data point",
          "type": "object",
          "properties": {
            "value": {
              "description": "The value",
              "type": "string"
            },
            "ts": {
              "description": "The time stamp",
              "type": "string"
            }
          },
          "required": ["value", "ts"]
        }
      },
      "required": ["path", "dp"]
    },
    "https://covesa.global/vissv2.0/datapoint-multiple.schema.json": {
      "$id": "https://covesa.global/vissv2.0/datapoint-multiple.schema.json",
      "$schema": "https://json-schema.org/draft/2020-12/schema",
      "title": "VISSv2-multiple-datapoints",
      "description": "VISSv2 multiple datapoints",
      "properties": {
        "path": {
          "description": "The path",
          "type": "string"
        },
        "dp": {
          "description": "Array of data points",
          "type": "array",
          "items": {
            "properties": {
              "value": {
                "description": "The value",
                "type": "string"
              },
              "ts": {
                "description": "The time stamp",
                "type": "string"
              }
            },
            "required": ["value", "ts"]
          }
        }
      },
      "required": ["path", "dp"]
    }
    }
    },
    "https://covesa.global/vissv2.0/error.schema.json": {
  "$id": "https://covesa.global/vissv2.0/error.schema.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "VISSv2-error",
  "description": "VISSv2 error data",
  "type": "object",
  "properties": {
    "number": {
      "description": "The status code",
      "type": "integer",
      "enum": [400, 401, 403, 404, 503]
    },
    "reason": {
      "description": "The reason",
      "type": "string",
      "enum": ["bad_request", "invalid_data", "expired_token", "invalid_token", "missing_token", "forbidden_request",
               "unavailable_data", "service_unavailable"]
    },
   "message": {
      "description": "The access token",
      "type": "string",
      "enum": ["The request is malformed.", "Data present in the request is invalid.", "Access token has expired.",
               "Access token is invalid.", "Access token is missing.", "The server refuses to carry out the request.",
               "The requested data was not found.", "The server is temporarily unable to handle the request."]
    }
  },
  "required": ["number", "reason", "message"]
    }
  }
}              </code></pre>
    </section>

    <section id="server-capabilities" class="appendix">
        <h2>Server Capabilities</h2>
        <p>
        On receiving a dynamic-metadata request on server capabilities the server SHALL respond with a JSON object that for each of the keys
        in the list below contains the associated values in the list that the server supports.
        Both the keys and the values are represented as strings, if a key has more than one value, these are represented as an array.<br>
        A key name refers to a functional domain of the specification, and the tables below contain the capabilities of these domains.
        The ones marked as underlined are mandatory, the others are optional.
        <table  style="width:60%">
          <tr>
            <th>Key name</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>filter</td>
            <td><a href="#filter-request"></a></td>
          </tr>
          <tr>
            <td>access_ctrl</td>
            <td><a href="#access-control-model"></a></td>
          </tr>
          <tr>
            <td>transport_protocol</td>
            <td>[[viss3-transport-examples]], <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html">Transport Protocol Examples</a> chapter</td>
          </tr>
          <tr>
            <td>payload_encoding</td>
            <td>[[viss3-payload-encoding]], <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_PayloadEncoding.html">Payload Encoding</a> chapter</td>
          </tr>
        </table><br>
        <table  style="width:50%">
          <tr>
            <th>filter</th>
            <th>Description</th>
          </tr>
          <tr>
            <td><u>timebased</u></td>
            <td><a href="#timebased-filter-operation"></a></td>
          </tr>
          <tr>
            <td><u>change</u></td>
            <td><a href="#change-filter-operation"></a></td>
          </tr>
          <tr>
            <td>paths</td>
            <td><a href="#paths-filter-operation"></a></td>
          </tr>
          <tr>
            <td>range</td>
            <td><a href="#range-filter-operation"></a></td>
          </tr>
          <tr>
            <td>curvelog</td>
            <td><a href="#curvelog-filter-operation"></a></td>
          </tr>
          <tr>
            <td>history</td>
            <td><a href="#history-filter-operation"></a></td>
          </tr>
          <tr>
            <td>static_metadata</td>
            <td><a href="#static-metadata-request"></a></td>
          </tr>
          <tr>
            <td><u>dynamic_metadata</u></td>
            <td><a href="#dynamic-metadata-request"></a></td>
          </tr>
        </table><br>
        <table  style="width:50%">
          <tr>
            <th>access_ctrl</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>short_term</td>
            <td><a href="#access-control-flows"></a></td>
          </tr>
          <tr>
            <td>long_term</td>
            <td><a href="#access-control-flows"></a></td>
          </tr>
          <tr>
            <td>signalset_claim</td>
            <td><a href="#access-token"></a></td>
          </tr>
        </table><br>
        <table  style="width:50%">
          <tr>
            <th>transport_protocol</th>
            <th>Description</th>
          </tr>
          <tr>
            <td><u>https</u></td>
            <td>[[viss3-transport-examples]], Transport Protocol Examples:<a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#https">HTTPS</a> chapter</td>
          </tr>
          <tr>
            <td><u>wss</u></td>
            <td>[[viss3-transport-examples]], Transport Protocol Examples:<a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_TransportExamples.html#secure-websockets">Secure Websocket</a> chapter</td>
          </tr>
          <tr>
            <td>mqtts</td>
            <td>[[viss3-transport-examples]], Transport Protocols:MQTT chapter</td>
          </tr>
        </table>

        </p>
    </section>

    <section id="tof" class="appendix"></section>

  </body>
</html>
