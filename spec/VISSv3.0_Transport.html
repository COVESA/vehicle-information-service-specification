<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>COVESA VISS version 3.0-Transport</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
    <script class='remove'>
      var respecConfig = {
        latestVersion: null,
        github: "https://github.com/COVESA/vehicle-information-service-specification",
        specStatus: "base",
	logos: [{
	  src: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/images/covesa.jpg",
          url: "https://covesa.global",
          alt: "COVESA",
          height: 50,
          id: "covesa-logo",
        },],
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Ford Motor Company",
          companyURL: "https://www.ford.com",
        },
        {
          name: "이원석(Wonsuk Lee)",
          company: "한국전자통신연구원(ETRI)",
          url: "mailto:wonsuk.lee@etri.re.kr",
          companyURL: "https://etri.re.kr/eng/main/main.etri",
          w3cid: 34457
        }],
        edDraftURI: "https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Transport.html",
        shortName: "viss3-transport",
        localBiblio: {
          "PAYLOAD ENCODING": {
            title: "COVESA VISS version 3.0-Payload Encoding",
            href: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_PayloadEncoding.html",
            publisher: "Ulf Bjorkengren; Wonsuk Lee"
          },
          "CORE": {
            title: "COVESA VISS version 3.0-Core",
            href: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html",
            publisher: "Ulf Bjorkengren; Wonsuk Lee"
          }
        }
      };
    </script>
    <style>
      table.parameters, table.exceptions {
          border-spacing: 0;
          border-collapse:    collapse;
          margin: 0.5em 0;
          width:  100%;
      }
      table.parameters { border-bottom:  1px solid #90b8de; }
      table.exceptions { border-bottom:  1px solid #deb890; }

      .parameters th, .exceptions th {
          color:  inherit;
          padding:    3px 5px;
          text-align: left;
          font-weight:    normal;
      }
      .parameters th { color: #fff; background: #005a9c; }
      .exceptions th { background: #deb890; }

      .parameters td, .exceptions td {
          padding:    3px 10px;
          border-top: 1px solid #ddd;
          vertical-align: top;
      }

      .parameters tr:first-child td, .exceptions tr:first-child td {
          border-top: none;
      }

      .parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
          width:  100px;
      }

      .parameters td.prmType {
          width:  120px;
      }

      table.exceptions table {
          border-spacing: 0;
          border-collapse:    collapse;
          width:  100%;
      }

      .simple {
        width:100%;
      }

      thead th{
        border-bottom: 1px solid black;
      }

      .simple tbody th{
        width:33%;
        background: white;
        color: black;
      }
      pre { white-space: pre-wrap;}
  </style>
  </head>
  <body>
    <p class="copyright">Copyright © 2024 COVESA®. This document includes material copied from or derived from <a href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html">W3C VISS version 2 - Core</a>.</p>
    <section id='abstract'>
      <p>
        The Vehicle Information Service Specification (VISS) is a
        service for accessing vehicle information, including signals from sensors
        on control units within a vehicle's network. This information is exposed through a hierarchical, 
        tree-like taxonomy as defined in the COVESA Vehicle Signal Specification (VSS), 
        and is provided in JSON format. The VISS service may be hosted within the vehicle or on external servers, 
        using data that has already been off-boarded.
      </p>
      <p>
        VISS enables a broad range of use cases, including predictive maintenance, usage-based insurance, fleet management, 
        and real-time driver assistance services.
        In the context of artificial intelligence, VISS serves as a critical data access layer, providing high-quality, 
        real-time vehicle data that can be utilized by AI algorithms for tasks such as anomaly detection, 
        driver behavior analysis, energy optimization, and contextual decision-making.
      </p>
      <p>
        This specification describes the third version of VISS, which
        has been implemented and deployed in production vehicles.
        The first version of VISS supported only WebSocket as a
        transport protocol, the second version is generalized to work
        across different protocols as some are better suited for
        different use cases.
        The second version added support for the HTTP and MQTT transport
        protocols, improved subscription capabilities and added an
        access control mechanism.
      </p>

      <p>
        This specification consists of three parts, [[CORE]], [[PAYLOAD ENCODING]], and TRANSPORT. This document, the VISS version 3.0 TRANSPORT specification,
        describes the VISSv3 transport protocols, and how the message layer is mapped to each transport.
        The companion specification [[CORE]] describes the messaging layer, and [[PAYLOAD ENCODING]] describes payload encodings to/from the primary JSON payload format.
      </p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>This specification provides examples of how the message payloads defined in [[CORE]] are used together with different transport protocols.
      The Websocket protocol([[RFC6455]]) is used to give an example of how the JSON primary payload format is directly used.
      This is followed by examples of other transport protocols that introduce exceptions or transformations to the primary payload format.<br>
      The Vehicle Information Service Specification, version 3.0, allows the use of any transport protocol that can carry the unaltered primary payload format.
      If a transport protocol requires modifications or transformations, those MUST be specified either in this document or in the [[PAYLOAD ENCODING]] document.
      The transport protocols that define such deviations in this document are listed below.
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Protocol name</th>
	    <th>Reference</th>
	  </tr>
	  <tr>
	    <td>HTTP</td>
	    <td>[[RFC9112]]</td>
	  </tr>
	  <tr>
	    <td>MQTT</td>
	    <td>[[MQTT]]</td>
	  </tr>
	  <tr>
	    <td>gRPC</td>
	    <td><a href="https://grpc.io/">[gRPC]</a></td>
	  </tr>
	</tbody></table>
    The Websocket protocol is included to provide an example for protocols that does not introduce any deviations, and therefore it is not listed above.
      </p>
    </section>

    <section id="conformance"></section>

    <section id="terminology">
      <h2>Terminology</h2>
      <p>
      The acronym 'VISSv3.0' refer to this document, the VISS version 3.0 specification.
      The acronym 'VSS' refer to the <a href="https://github.com/COVESA/vehicle_signal_specification">'Vehicle Signal Specification'</a>
      which is maintained by COVESA.
      The term 'WebSocket', as used in this specification, follows the definition in the
      <a href="https://www.w3.org/TR/websockets/">W3C WebSocket API</a> and [[RFC6455]], the WebSocket Protocol.
      </p>
    </section>

    <section id="transport-common-defs">
      <h2>Transport Common Definitions</h2>
      <p>This section defines features that SHALL be common for all transport protocols.</p>

      <section id="status-codes">
        <h2>Status Codes</h2>
	        <p>A server implementing this specification SHALL support the error codes, reasons, and descriptions listed in the table below,
            across all supported transport protocols.
            The server MAY dynamically replace the error description with one of the alternatives 
            described in the following sub-sections, or with any other relevant message.<br>
            The client <em class="rfc2119" title="MAY">MAY</em> support any status code defined in [[RFC2616]].</p>
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Error&nbsp;Number&nbsp;(Code)</th>
	    <th>Error Reason</th>
	    <th>Error Description</th>
	  </tr>
	  <tr>
	    <td>400 (Bad Request)</td>
	    <td>bad_request	</td>
	    <td>The request is malformed</td>
	  </tr>
	  <tr>
	    <td>400 (Bad Request)</td>
	    <td>invalid_data</td>
	    <td>Data in the request is invalid</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>invalid_token</td>
	    <td>Access token is invalid</td>
	  </tr>
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>forbidden_request</td>
	    <td>The server refuses to carry out the request</td>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>unavailable_data</td>
	    <td>The requested data was not found</td>
	  </tr>
	  <tr>
	    <td>408 (Request Timeout)</td>
	    <td>request_timeout</td>
	    <td>Subscribe duration limit exceeded</td>
	  </tr>
	  <tr>
	    <td>429 (Too Many Requests)</td>
	    <td>too_many_requests</td>
	    <td>Rate-limiting due to too many requests</td>
	  </tr>
	  <tr>
	    <td>502 (Bad Gateway)
	    <td>bad_gateway</td>
	    <td>The upstream server response was invalid</td>
	  </tr>
	  <tr>
	    <td>503 (Service Unavailable)</td>
	    <td>service_unavailable</td>
	    <td>The server is temporarily unable to handle the request</td>
	  </tr>
	  <tr>
	    <td>504 (Gateway Timeout)</td>
	    <td>gateway_timeout</td>
	    <td>The upstream server took too long to respond</td>
	  </tr>
	</tbody></table>

      <section id="in-line-error-reporting">
        <h2>In-line Error Reporting</h2>
        <p>
        A client MAY issue one request to get or subscribe to multiple signals.
        If one or more of the requested signals are temporarily unavaliable, the server has two response options:
        </p>
        <ul>
            <li>Error message: 404 - unavailable_data</li>
            <li>In-line error reporting</li>
        </ul>
        Returning an error message means that the client will not receive any signals, including those that were available.
        In contrast, in-line error reporting allows the client to receive all available signals, while indicating errors for those that are unavailable.
        The in-line error reporting takes advanage of the fact that all values are represented as strings in the payload.
        For any missing value, the server replaces the value with the following string:
        <ul>
            <li>"viss-inline:Data-not-available"</li>
            <ul><li>Note: The prefix "viss-inline:" MUST NOT be used in any ordinary string values.</li></ul>
        </ul>
        An in-line error reporting example is shown below.
        <pre><code>
{
    "action": "get",
    "data": [
        {
            "dp": {
                "ts": "2025-02-04T15:48:43.739Z",
                "value": "viss-inline:Data-not-available"
            },
            "path": "Vehicle.ADAS.ABS.IsEnabled"
        },
        {
            "dp": {
                "ts": "2025-02-04T15:48:43.739Z",
                "value": "true"
            },
            "path": "Vehicle.ADAS.ABS.IsError"
        }
    ],
    "requestId": "237",
    "ts": "2025-02-04T15:48:43.739Z"
}        </code></pre>
        In-line error reporting SHALL NOT be used when access control is required for the request.
        The reason for this is that the purpose that is associated with the set of requested data can not be met
        with a reduced data set, thus the "contract" between client and data owner becomes invalid.
      </section>

      <section id="common-error-scenarios">
        <h2>Common Error Scenarios</h2>
        <p>
          The following table outlines common error scenarios that clients may encounter, 
          along with the corresponding error messages that the server is expected to return.
        </p>
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Error Scenario</th>
	    <th>Error Message</th>
	    <th>Comment</th>
	  </tr>
	  <tr>
	    <td>Incorrect datatype</td>
	    <td>400 - invalid_data - Incorrect data type</td>
	    <td>Mismatch with the datatype in the VSS tree</td>
	  </tr>
	  <tr>
	    <td>Signal currently not available</td>
	    <td>404 - unavailable_data - Data temporarily unaccessible</td>
	    <td>Vehicle is currently not offering the signal</td>
	  </tr>
	  <tr>
	    <td>Unknown signal</td>
	    <td>404 - unavailable_data - Data is unknown</td>
	    <td>Signal is not part of the VSS tree</td>
	  </tr>
	  <tr>
	    <td>Misused filter</td>
	    <td>400 - bad_request - Missing or invalid filter</td>
	    <td>Missing or invalid filter</td>
	  </tr>
	  <tr>
	    <td>Incorrect filter</td>
	    <td>400 - bad_request - Incorrect filter</td>
	    <td>Filter type not allowed with request method</td>
	  </tr>
	  <tr>
	    <td>Unknown subscription Id</td>
	    <td>404 - unavailable_data - Unknown subscription Id</td>
	    <td>Filter type not allowed with request method</td>
	  </tr>
	  <tr>
	    <td>Unsupported feature Id</td>
	    <td>404 - unavailable_data - Unsupported feature</td>
	    <td>The feature is not a server capability</td>
	  </tr>
	  <tr>
	    <td>Invalid access rights</td>
	    <td>401 - invalid_token - Access token is invalid</td>
	    <td>Access right is expired or otherwise invalid</td>
	  </tr>
	</tbody></table>
      </section>

      <section id="400-bad-request">
        <h2>400 Bad Request Error Descriptions</h2>
        <p>
          The 400 Bad Request error code and its associated reason SHALL be used for errors related to the JSON schema.
          The default error description is listed in the table above. However, the server MAY dynamically replace 
          it with one of the following error descriptions, or with any other relevant description:
        </p>
        <ul>
            <li>Missing or invalid <code>action</code></li>
            <li>Missing or invalid <code>path</code></li>
            <li>Missing or invalid <code>filter</code></li>
            <li>Missing or invalid <code>value</code></li>
        </ul>
      </section>

      <section id="400-invalid-data">
        <h2>400 Invalid Data Error Descriptions</h2>
        <p>
        The 400 Invalid Data error code and reason SHALL be used for errors that are not covered by 
        the JSON schema, but instead violate rules defined by a VSS property.
        The default error description is provided in the table above. However, the server MAY dynamically replace 
        it with one of the following descriptions, or with any other relevant error message:
        </p>
        <ul>
            <li>Update of a sensor is not supported</li>
            <li>Requested action on a branch is not supported</li>
            <li>Data value outside limit</li>
            <li>Incorrect data type</li>
        </ul>
      </section>

      <section id="401-unauthorized">
        <h2>401 Unauthorized Error Descriptions</h2>
        <p>
        The 401 Unauthorized error code and reason SHALL be used for errors related to access control validation.
        The default error description is provided in the table above. However, the server MAY dynamically replace 
        it with one of the following messages, or with any other relevant description:
        </p>
        <ul>
            <li>Access token has expired</li>
            <li>Access token is missing</li>
        </ul>
      </section>

      <section id="404-not-found">
        <h2>404 Not Found Error Descriptions</h2>
        <p>
        The 404 Not Found error code and reason SHALL be used when the server does not have access to the requested data.
        The default error description is listed in the table above. The server MAY dynamically replace 
        it with one of the following messages, or with any other relevant description:
        </p>
        <ul>
            <li>Data temporarily unaccessible</li>
            <li>Data is unknown</li>
        </ul>
      </section>
      </section>

      <section id="transport-payload">
        <h2>Transport Payload</h2>
        <p>
          The payload SHALL be formatted in JSON.
          Refer to the <a href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#json-schema">section A. JSON Schema</a> of appendix in the [[CORE]] specification for details on the primary payload format.
        </p>
      </section>

      <section id="authorization">
        <h2>Authorization</h2>
          <p>
            If authorization is enabled for a signal requested by the client,
            the client MUST provide an access token to the server to verify that it is authorized to access the requested service
            (refer to the [[CORE]] specification).
            For HTTP requests, tokens SHALL be included in <code>Authorization</code> header.
            For transport protocols that use the primary payload format, an optional <code>authorization</code> property in the payload SHALL be used.
          </p>
      </section>
    </section>

    <section id="transport-protocols">
      <h2>Transport Protocols</h2>
      <p>
      The VISSv3.0 specification lists the transport protocols HTTP, WebSocket, gRPC, and MQTT as supported.
      However, this is not necessarily a final list as says that any protocol that transport the primary payloads of this specification,
      or an encoded version of the primary payloads, can be included on this list.<br>
      The specification does not mandate the use of a specific transport protocol,
      but at least one of the listed transport protocols MUST be supported.
      </p>

      <section id="secure-websocket">
        <h2>Secure WebSocket</h2>
        <p>
        The WebSocket protocol is used in this document to provide examples of a protocol that does not apply any deviations to the primary payload format.
        As it does not implicitly provide a logical association between the request and response messages,
        a key-value pair with the key name "requestId" MUST be added to the data components, as described in the [[CORE]] specification.<br>
        Additionally, since WebSocket does not define explicit methods, another key-value pair, "action", MUST also be included. 
        Refer to the <a href='#action-def'></a> for detailed descriptions of these key-value pairs.
        All data components are mapped to the payload.
        </p>

        <section id="wss-lifetime-mngmnt">
          <h2>Session Life Time Management</h2>

          <section id="wss-initialisation">
            <!--OddPage--><h2>Initialization</h2>

            <p>If the client application is an HTML Application running in a web runtime or is a web page running 
              in a browser, the WebSocket instance may either be instantiated natively or be created using 
              a 'standards compliant' WebSocket JavaScript library.</p>
            <p>A WebSocket can also be initiated from a native application (e.g., written in C++)
              or from a managed runtime environment such as Java or C#. 
              In these cases, it is assumed that the client uses a standards-compliant WebSocket library 
              to request a connection with the server.</p>

            <p>Implementations that support additional devices or multiple VISSv3 services
              should provide discovery. Alternatively, the location of a particular VISSv3
              Server instance on the local vehicle network may be handled by
              configuration, either as part of a package manifest or by consulting a
              registry on application install. The 'wwwVISSv3' hostname in this
              specification is used an example.
            </p>
    
            <p>A client running on the vehicle is able to connect to the
            VISSv3 Server instance using the hostname e.g. 'wwwVISSv3' and uses the
            default port 6443. The hostname 'wwwVISSv3' may locally be mapped to the localhost
            IP address 127.0.0.1 e.g. by adding an entry to the /etc/hosts file.</p>

            <p>The sub-protocol name SHALL be 'VISSv3' with the digit 3 being the version number.
            The sub-protocol version will
            be associated with exactly one VISS Server Specification version so that the client and server can
            correctly validate and parse request and response message packets.</p>
            <pre><code>
              var vehicle  = new WebSocket("wss://wwwVISSv3:6443", "VISSv3");
            </code></pre>
            <p>The client SHALL connect to the server over HTTPS and request that
            the server opens a WebSocket. All WebSocket communications between
            the client and server MUST use ‘wss’ (WebSocket Secure). Non encrypted communication
            is not supported, hence the server MUST reject ‘ws’ connection requests.</p>
      
            <p>This specification assumes that a single WebSocket is used to enable communication between a client application
            and the server. The client MAY open more than one websocket.
            However, the server MAY reject to open a subsequent WebSocket connection and
            the client is responsible for handling this gracefully.
            </p>
            <p>If multiple WebSocket connection is established between a client application and the server 
              then each connection MUST be managed independently. For example, subscriptions created 
              through one connection can only trigger events through that same connection, 
              and the client MUST use the same connection to unsubscribe.
            </p>
            <p>If multiple WebSocket connection has been established
            between one or more clients and a particular server instance, there
            is a risk that race conditions and concurrency issues could occur.
            For instance, simultaneous updates to the same signal from different connections 
            could result in conflicts.
            </p>

            <p>Unless explicitly stated otherwise, the client MAY assume that the server implements 
              a basic concurrency model, meaning that lost updates or dirty reads could occur 
              when multiple WebSocket connections are in use.
            </p>	
          </section>

          <section id="wss-closure">
            <!--OddPage--><h2>Closure</h2>
            <p>The WebSocket connection MAY be closed by either the client or the
            server by invoking the ‘close()’ method on the WebSocket
            instance.</p>

            <p>The following example shows the typical lifecycle of a WebSocket connection on the client side:</p>
              <pre><code>
              // Open the WebSocket</span>
              var vehicle  = new WebSocket("wss://wwwVISSv3:6443", "VISSv3");
              …
              // Close the WebSocket
              vehicle.close();
              </code></pre>
            <p>
              The VISSv3 server MAY also terminate the connection if it does not receive any requests from the client 
              within a server-defined timeout period. 
              In such cases, the client MUST handle the closure gracefully, and if needed, re-establish the connection and request new subscriptions, where required.
            </p>
        </section>
      </section>

      <section id="wss-transport-messages">
          <h2>Transport Messages</h2>

          <section id="wss-read-message">
            <h2>Read</h2>
            <p>The client MAY send a <a href="#dfn-getrequest" class="internalDFN" data-link-type="dfn">getRequest</a>
            message to the server to get the value of one or more vehicle signals.
            If the server can fulfill the request, it SHALL return a
            <a href="#dfn-getsuccessresponse" class="internalDFN" data-link-type="dfn">getSuccessResponse</a> message.
            If an error occurs, the server SHALL return a
            <a href="#dfn-geterrorresponse" class="internalDFN" data-link-type="dfn">getErrorResponse</a> message.
            The structure of these message objects is defined in the tables below:
            </p><br>
            <table class="simple">
            <thead>
              <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
            </thead>
            <tbody>
                <tr><th rowspan="6"><dfn data-dfn-type="dfn" id="dfn-getrequest">getRequest</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
                <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
	              <tr><td><a href="#dfn-filter">filter</a></td><td>string</td><td>Optional</td></tr>		
                <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
                <tr><td><a href="#dfn-data-compression">data compression</a></td><td>string</td><td>Optional</td></tr>
                <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
            </tbody>
            </table>
            <br>
            <table class="simple">
            <thead>
              <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
            </thead>
            <tbody>
             <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-getsuccessresponse">getSuccessResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
             <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
             <tr><td><a href="#dfn-value">data</a></td><td>object/array</td><td>Yes</td></tr>
 	           <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
           </tbody>
           </table>
           <p>
            In the table above, the "data" attribute is either an object containing "value" and "ts" name/value pairs, or an array of such objects.
           </p>
           <table class="simple">
           <thead>
             <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
           </thead>
           <tbody>
           <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-geterrorresponse">getErrorResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
           <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
           <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
           <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
           </tbody>
           </table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Powertrain.CombustionEngine.RPM",
                "requestId": "8756"
              }
              </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8756",
                "data":{"path":"Vehicle.Powertrain.CombustionEngine.RPM",
                        "dp":{"value":"2372", "ts":"2020-04-15T13:37:00Z"}
                },
                "ts":"2020-04-15T13:37:05Z"
              }
              </code></pre>
              Error response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8756",
                "error": {"number": "404", "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>

          <section id="wss-authorized-read">
            <h2>Authorized Read</h2>
            <p> 
              If the operation on the addressed VSS node requires authorization, the request MUST include 
              the "authorization" field, containing a valid JWT token as its value.
              The token validation MUST be successful for a
              <a href="#dfn-getsuccessresponse" class="internalDFN" data-link-type="dfn">getSuccessResponse</a>
              to be returned. If validation fails, a <a href="#dfn-geterrorresponse" class="internalDFN" data-link-type="dfn">getErrorResponse</a> SHALL be returned.
              JWT tokens can be used with all types of read requests.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Powertrain.CombustionEngine.RPM",
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds",
                "requestId": "8657"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8657",
                "data":{"path":"Vehicle.Powertrain.CombustionEngine.RPM",
                        "dp":{"value":"2372", "ts":"2020-04-15T13:37:00Z"}
                },
                "ts":"2020-04-15T13:37:01Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-search-read">
            <h2>Search Read</h2>
            <p>The client MAY issue a search read request to retrieve multiple signal values in one request message.
               This is realized by adding a "filter" object following the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#paths-filter-operation">section 7.1 Paths Filter Operation</a> described in the [[CORE]] specification.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Cabin",
                "filter": {"variant":"paths", "parameter":["Door.*.*.IsOpen", "DriverPosition"]},
                "requestId": "5688"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "data":[{"path":"Vehicle.Cabin.Door.Row1.Left.IsOpen", "dp":{"value":"false", "ts":"2020-04-15T13:37:00Z"}},
                        {...},…
                        {"path":"Vehicle.Cabin.Door.Row4.Right.IsOpen", "dp":{"value":"true", "ts":"2020-04-15T13:37:01Z"}},
                        {"path":"Vehicle.Cabin.DriverPosition", "dp":{"value":"1", "ts":"2020-04-15T07:00:01Z"}}
                       ],
                "requestId": "5688",
                "ts":"2020-04-15T07:00:02Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-history-read">
            <h2>History Read</h2>
            <p>A client MAY issue a history read request to retrieve previously recorded data points.
               This is realized by adding a "filter" object following the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#history-filter-operation">section 7.2 History Filter Operation</a> described in the [[CORE]] specification.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Acceleration.Longitudinal",
                "filter": {"variant":"history", "parameter":"P2DT12H"},
                "requestId": "5688"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "data": {"path": "Vehicle.Acceleration.Longitudinal", "dp": [{"value": "0.123", "ts": "2020-04-15T13:00:00Z"}, {"value": "0.125", "ts": "2020-04-15T13:37:02Z"}]},
                "requestId": "5688",
                "ts": "2020-04-15T13:37:02Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-signal-discovery-read">
            <h2>Signal Discovery Read</h2>
            <p>
              To retrieve metadata about the VSS tree, the client MAY issue a signal discovery read request.
              This is realized by adding a "filter" object following the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#metadata-request">section 7.7 Metadata Filter Operation</a> described in the [[CORE]] specification.
              The response includes metadata for all nodes in the subtree rooted at the node specified by the path, 
              limited to the number of generations set by the "parameter" value.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Powertrain.FuelSystem",
                "filter":{"variant":"metadata", "parameter":"2"},
                "requestId": "5687"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "requestId": "5687",
                "metadata": {"FuelSystem":{"type":"branch","children":["HybridType", ... ]}},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>
          </section>

          <section id="wss-update">
            <h2>Update</h2>
            <p>
            The client MAY send a request to the server to set the value of a signal.
            If the server can fulfill the request successfully, it SHALL return a
            <a href="#dfn-setsuccessresponse" class="internalDFN" data-link-type="dfn">setSuccessResponse</a> message.
            If an error occurs, the server SHALL return a
            <a href="#dfn-seterrorresponse" class="internalDFN" data-link-type="dfn">setErrorResponse</a> message.
             The structure of these message objects is defined below:
            </p>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5">setRequest</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
          <tr><td><a href="#dfn-value">value</a></td><td>string/array/object</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="3"><dfn data-dfn-type="dfn" id="dfn-setsuccessresponse">setSuccessResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-seterrorresponse">setErrorResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "set",
                "path": "Vehicle.Powertrain.Transmission.PerformanceMode",
                "value": "sport",
                "requestId": "5687"
              }
               </code></pre>
             Successful response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
             Error response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "error": {"number": "404", "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>

         <section id="wss-authorized-update">
            <h2>Authorized Update</h2>
            <p>
              If the operation on the targeted VSS node requires authorization, 
              the request MUST include the "authorization" field, containing a valid JWT token.
              The token MUST be successfully validated by the server to return a
              <a href="#dfn-setsuccessresponse" class="internalDFN" data-link-type="dfn">setSuccessResponse</a>.
              If validation fails, a <a href="#dfn-seterrorresponse" class="internalDFN" data-link-type="dfn">setErrorResponse</a> SHALL be returned.
              Authorization tokens MAY be used with all types of update requests.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "set",
                "path": "Vehicle.Powertrain.Transmission.PerformanceMode",
                "value": "sport",
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds",
                "requestId": "5687"
              }
               </code></pre>
              Response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>
          </section>

          <section id="subscribe">
            <h2>Subscribe</h2>
            <p>
            The client MAY send a <a href="#dfn-subscriberequest" class="internalDFN" data-link-type="dfn">subscribeRequest</a> message
            to request a subscription to one or more signals,
            thereby requesting the server to repeatedly return subscription event messages based on
	          the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#filter-request">section 7. Filter Request</a> described in the [[CORE]] specification.
            To reduce processing load, the server MAY limit the number of
            <a href="#dfn-subscriptionevent" class="internalDFN" data-link-type="dfn">subcriptionEvent</a> messages sent.<br>
            If the server can fulfill the request, it SHALL return a
            <a href="#dfn-subscribesuccessresponse" class="internalDFN" data-link-type="dfn">subscribeSuccessResponse</a> message.
            If an error occurs while processing the request, the server SHALL return a
            <a href="#dfn-subscribeerrorresponse" class="internalDFN" data-link-type="dfn">subscribeErrorResponse</a> message.<br>
            If an error occurs during an active subscription session, the server SHALL return a
            <a href="#dfn-subscriptionerrorevent" class="internalDFN" data-link-type="dfn">subscriptionErrorEvent</a> message.<br>
            The structure of the subscription messages is defined below.<br>
            As specified in the [[CORE]] specification, the supported subscription variants are:
            <ul>
              <li><b>timebased</b>: Event messages are issued at a regular time interval,</li>
              <li><b>change</b>: Event messages are issued when the value has changed as specified,</li>
              <li><b>range</b>: Event messages are issued when the value is in the specified range,</li>
              <li><b>curvelog</b>: Event messages are issued when the buffer is full, and then processed according to the curve logging algorithm.</li>
            </ul>

            </p>
	<table class="simple">
 	<thead>
	   <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	 </thead>
	 <tbody>
	   <tr><th rowspan="6"><dfn data-dfn-type="dfn" id="dfn-subscriberequest">subscribeRequest</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	   <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
	   <tr><td><a href="#dfn-filter">filter</a></td><td>string</td><td>Yes</td></tr>
	   <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
           <tr><td><a href="#dfn-data-compression">data compression</a></td><td>string</td><td>Optional</td></tr>
	   <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	 </tbody>
	 </table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-subscribesuccessresponse">subscribeSuccessResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-subscribeerrorresponse">subscribeErrorResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5"><dfn data-dfn-type="dfn" id="dfn-subscriptionevent">subscriptionEvent</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-value">data</a></td><td>object/array</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-subscriptionerrorevent">subscriptionErrorEvent</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Powertrain.FuelSystem.Level",
                "filter": {"variant":"timebased", "parameter":{"period":"500"}},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error response:
              <pre><code>
              {
                "action": "subscribe",
                "requestId": "6578",
                "error": {"number": "404", "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data": {"path": "Vehicle.Powertrain.FuelSystem.Level",
                        "dp": {"value": "50", "ts": "2020-04-15T13:37:00Z"}
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "error": {"number": "401", "reason": "expired_token", "description": "Access token has expired."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>

          <section id="authorized-subscribe">
            <h2>Authorized Subscribe</h2>
            <p>
              If the operation on the addressed VSS node requires authorization, 
              the request MUST include the "authorization" field with a valid JWT token as its value.
              The token MUST be successfully validated for a
              <a href="#dfn-subscribesuccessresponse" class="internalDFN" data-link-type="dfn">subscribeSuccessResponse</a> to be returned.
              If validation fails, a <a href="#dfn-subscribeerrorresponse" class="internalDFN" data-link-type="dfn">subscribeErrorResponse</a> SHALL be returned.
              An "authorization" key-value pair can be combined with all types of subscription requests.
              </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Powertrain.FuelSystem.Level",
                "filter": {"variant":"range", "parameter":[{"logic-op":"gt", "boundary":"49"}, {"logic-op":"lt", "boundary":"51"}]},
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds",
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data": {"path": "Vehicle.Powertrain.FuelSystem.Level",
                        "dp": {"value": "50", "ts": "2020-04-15T13:37:00Z"}
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>

          <section id="curve-logging-subscribe">
            <h2>Curve Logging Subscribe</h2>
            <p>
            Curve logging data compression by eliminating data points that are within a set error margin is activated via a subscription request.
            Event messages will be issued when the buffer becomes full, after insignificant data points have been eliminated,
            refer to the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#curvelog-filter-operation">section 7.6 Curve logging Filter Operation</a> in the [[CORE]] specification.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Powertrain.FuelSystem.Level",
                "filter": {"variant":"curvelog", "parameter":{"maxerr":"0.5", "bufsize":"100"}},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data":{"path": "Vehicle.Powertrain.FuelSystem.Level",
                        "dp":[{"value": "50", "ts": "2020-04-15T13:38:00Z"}, ..., {"value": "25", "ts": "2020-04-15T13:39:30Z"}]
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>

          <section id="range-subscribe">
            <h2>Range Subscribe</h2>
            <p>
              Subscription to a range of values, 
              that can have either a single boundary, or multipe boundaries as in the example below.
              For a more information how to use range of values, refer to the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#range-filter-operation">section 7.4 Range Filter Operation</a> in the [[CORE]] specification.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Powertrain.FuelSystem.Level",
                "filter": "filter":{"variant":"range","parameter":[{"logic-op":"lt","boundary":"50","combination-op":"OR"},{"logic-op":"gt","boundary":"55"}]},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data":{"path": "Vehicle.Powertrain.FuelSystem.Level",
                        "dp":{"value": "51", "ts": "2020-04-15T14:00:00Z"}},
                "ts": "2020-04-15T14:00:00Z"
              }
               </code></pre>
            </p>
          </section>

          <section id="change-subscribe">
            <h2>Change Subscribe</h2>
            <p>
            Subscription to when a signal has changed between two sequential captures.
            For a more information how to use change of values, refer to the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#change-filter-operation">section 7.5 Change Filter Operation</a> in the [[CORE]] specification.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Powertrain.FuelSystem.Level",
                "filter":{"variant":"change","parameter":{"logic-op":"gt","diff":"10"}},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data":{"path": "Vehicle.Powertrain.FuelSystem.Level",
                        "dp":{"value": "101", "ts": "2020-04-15T14:00:00Z"}},
                "ts": "2020-04-15T14:00:00Z"
              }
               </code></pre>
            </p>
          </section>
          </section>

          <section id="unsubscribe">
            <h2>Unsubscribe</h2>
            <p>
            To unsubscribe from a subscription, the client <em class="rfc2119" title="SHALL">SHALL</em> send an
            <a href="#dfn-unsubscriberequest" class="internalDFN" data-link-type="dfn">unsubscribeRequest</a> message to the server.
            If the server can fulfill the request successfully, it SHALL returns an
            <a href="#dfn-unsubscribesuccessresponse" class="internalDFN" data-link-type="dfn">unsubscribeSuccessResponse</a> message.
            If an error occurs, an
            <a href="#dfn-unsubscribeerrorresponse" class="internalDFN" data-link-type="dfn">unsubscribeErrorResponse</a> message SHALL be returned.
            <br>
            If the client has created multiple WebSocket instance, it <em class="rfc2119" title="MUST">MUST</em> unsubscribe
            using the same WebSocket instance that was originally used to create the subscription.
            </p>
	<table class="simple">
	  <thead>
	    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	  </thead>
	  <tbody>
	    <tr><th rowspan="3"><dfn data-dfn-type="dfn" id="dfn-unsubscriberequest">unsubscribeRequest</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	    <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  </tbody>
	  </table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="3"><dfn data-dfn-type="dfn" id="dfn-unsubscribesuccessresponse">unsubscribeSuccessResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-unsubscribeerrorresponse">unsubscribeErrorResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "unsubscribe",
                "subscriptionId": "12345",
                "requestId": "5786"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "unsubscribe",
                "requestId": "5786",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error response:
              <pre><code>
              {
                "action": "unsubscribe",
                "requestId": "6578",
                "error": {"number": "400", "reason": "invalid_data", "description": "Data present in the request is invalid."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>
        </section>
      </section>

      <section id="https">
        <h2>HTTPS</h2>
        <p>
          The message data components described in the [[CORE]] specification are primarily mapped to standard HTTP parameters.
          Only when no suitable mapping is available are they included in the payload.
          The most significant deviations are as follows:
        <ul>
          <li>The path is included as part of the URL.</li>
          <li>A filter expression is added to the URL as a query string.</li>
          <li>The HTTP methods GET and POST are used instead of the "action" field.</li>
        </ul>
        The subscribe/unsubscribe operations are not supported by this transport protocol.
        </p>

        <section id="https-life-time-mngmnt">
          <h2>Session Life Time Management</h2>

          <section id="https-initialisation">
            <h2>Initialization</h2>
            <p>Initialization involves setting up a secure HTTPS session between the client and the server.
               This ensures encrypted communication for data transmission.
               To initialize a secure session, the client sends a request to the server using the HTTPS protocol.
               This is achieved by connecting to the server's designated URL using the 'https://' scheme.
               The client can use a web browser, a native application, or a suitable library in the case of programmatically managed sessions.<br>
               While the client typically connects to the server using the specified hostname, which often includes the "www" prefix,
               it's important to note that this convention may not apply in situations where VISS operates within a local, in-vehicle network or if remote vehicle connections are allowed.
               The communication SHALL use port 443, the default port for secure HTTPS connections.
               Hostname resolution can be achieved using DNS or configured through local settings.
            </p>
          </section>

          <section id="https-closure">
            <h2>Closure</h2>
            <p>Closure entails ending the established HTTPS session when the communication is complete or when the client no longer requires the connection.
              Either the client or the server can initiate the session closure. The client can signal the end of the session by sending an appropriate request to the server,
              indicating the intent to close the connection.<br>
              Upon session closure, any allocated resources, such as server-side threads or memory, are released, improving overall system efficiency.
            </p>
          </section>
        </section>

        <section id="https-transport-messages">
          <h2>Transport Messages</h2>

          <section id="https-read">
            <h2>Read</h2>
            <p>
            The client MAY send a HTTPS GET request message to the server to get one or more value(s) of one or more vehicle signal(s).
            If the server can fulfill the request, it SHALL return a response containing the requested value(s).
            If the server is unable to fulfill the request, e.g. because the client is not authorized to retrieve one or more of the signals,
            then it SHALL respond with an appropriate error status code.
            </p>
            <p>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle/Cabin/SeatPosCount   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Successful response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "data":{"path":"Vehicle.Cabin.SeatPosCount",
                        "dp":{"value":["2", "3", "2"], "ts":"2020-04-15T13:37:00Z"}
                       },
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
              Error response:
              <pre><code>
              HTTP/1.1 404 Not Found
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "error": {"number": "404", "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>

          <section id="https-authorized-read">
            <h2>Authorized Read</h2>
            <p>
              JWT tokens MUST be included in the <code>Authorization</code> header, prefixed with <code>Bearer</code> and followed by a space character.
            </p>
            <p>
            The following example assumes
            <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds</code>
            is the actual token. A JWT token in the <code>Authorization</code> header can be combined with all types of read requests.
            <br>
            <b>Example:</b>
            Request:		
            <pre><code>
            GET /Vehicle/Powertrain/CombustionEngine/RPM   HTTP/1.1
            Host:127.0.0.1:1337
            Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds
            </code></pre>
            Successful response:
            <pre><code>
            HTTP/1.1 200 OK
            Content-Type: application/json; charset=utf-8
	    ...
            {
              "data":{"path":"Vehicle.Powertrain.CombustionEngine.RPM",
                      "dp":{"value":"2372", "ts":"2020-04-15T13:37:00Z"}
                     },
                "ts": "2020-04-15T13:37:00Z"
            }
            </code></pre>
            Error response:
            <pre><code>
            HTTP/1.1 401 Unauthorized
            WWW-Authenticate: Bearer realm="127.0.0.1:1337",
                                     error="invalid_token",
                                     error_description="The access token is invalid or expired"	
            Content-Type: application/json; charset=utf-8
	    ...
            {
              "error": {"number": "401", "reason": "invalid_token", "description": "Access token is invalid."},
              "ts": "2020-04-15T13:37:00Z"
            }
            </code></pre>
	    </p>
          </section>

          <section id="https-search-read">
            <h2>Search Read</h2>
            <p>
              The search read request uses the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#paths-filter-operation">section 7.1 Paths Filter Operation</a> 
              described in the [[CORE]] specification to define one or more path expressions, relative to the path in the GET URL.<br>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle/Cabin/Door?filter={"variant":"paths", "parameter":"*/*/IsOpen"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "data":[{"path":"Vehicle.Cabin.Door.Row1.Left.IsOpen", "dp":{"value":"false", "ts":"2020-04-15T13:37:00Z"}},
                        {...},…
                        {"path":"Vehicle.Cabin.Door.Row4.Right.IsOpen", "dp":{"value":"true", "ts":"2020-04-15T13:37:00Z"}}
                       ],
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
              Error response:
              <pre><code>
              HTTP/1.1 404 Not Found
              Content-Type: application/json; charset=utf-8
	      ...
              {
                        "error": {"number": "404", "reason": "unavailable_data", "description": "The requested data was not found."},
                        "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>		
            </p>
          </section>

          <section id="https-history-read">
            <h2>History Read</h2>
            <p>
              The history read request uses the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#history-filter-operation">section 7.2 History Filter Operation</a> 
              described in the [[CORE]] specification to read recorded values
              for a specific past duration.<br>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle.Acceleration.Longitudinal?filter={"variant":"history", "parameter":"P2DT12H"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "data":{"path":"Vehicle.Acceleration.Longitudinal", "dp":[{"value":"0.123", "ts":"2020-04-15T13:00:00Z"}, ..., {"value":"0.125", "ts":"2020-04-15T13:37:00Z"}]},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="https-service-discovery-read">
            <h2>Signal Discovery Read</h2>
            <p>
              The signal discovery request uses the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#metadata-request">section 7.7 Metadata Filter Operation</a> 
              described in the [[CORE]] specification to retrieve metadata from a specified subtree in the VSS tree.
              A successful response will contain the requested metadata from all nodes of the subtree defined by 
              the subtree root node addressed by the path. 
              The depth of metadata retrieval is controlled by the "parameter" value.<br><br>
              <b>Example:</b><br>
              Request:
              <pre><code>
              GET /Vehicle/Powertrain/FuelSystem?filter={"variant":"metadata", "parameter":"0"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "metadata": {"FuelSystem":{"type":"branch","description":"Fuel system data.","children":{"HybridType, ... }}},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>
        </section>

        <section id="https-update">
          <h2>Update</h2>
          <p>
          The client MAY send a request to update the value of a signal.
          If the server can fulfill the request, it SHALL return a
          <a href="#dfn-setsuccessresponse" class="internalDFN" data-link-type="dfn">setSuccessResponse</a> message.
          If an error occurs, e.g. because the client is not authorized to set the requested value, or the value is read-only,
          the server SHALL return a
          <a href="#dfn-seterrorresponse" class="internalDFN" data-link-type="dfn">setErrorResponse</a> message.
          </p>
          <p>
            <b>Example:</b>
            <pre><code>
            POST /Vehicle/Powertrain/Transmission/PerformanceMode   HTTP/1.1
            Host: 127.0.0.1:1337
            Accept: application/json
      ...
            {
              "value": "sport"
            }
            </code></pre>
            Successful response:
            <pre><code>
            HTTP/1.1 200 OK
            Content-Type: application/json; charset=utf-8
      ...
            {
              "ts": "2020-04-15T13:37:00Z"
            }
            </code></pre>
            Error response:
            <pre><code>
            HTTP/1.1 404 Not Found
            Content-Type: application/json; charset=utf-8
      ...
            {
              "error": {"number": "404", "reason": "unavailable_data", "description": "The requested data was not found."},
              "ts": "2020-04-15T13:37:00Z"
            }
            </code></pre>
          </p>

        <section id="https-authorized-update">
          <h2>Authorized Update</h2>
          <p>
            JWT tokens MUST be included in the <code>Authorization</code> header, prefixed with <code>Bearer</code> followed by a space character.
          </p>
          <p>
          The following example assumes
          <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds</code>
          is the actual token. A token header MAY be used with all types of update requests.
          </p>
          <pre><code>
          POST /Vehicle/Powertrain/Transmission/PerformanceMode   HTTP/1.1
          Host:127.0.0.1:1337
          Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds
          {
            "value": "sport"
          }
          </code></pre>
        </section>
        </section>
      </section>
    </section>

    <section id="mqtt">
      <h2>MQTT</h2>
      <p>
        The MQTT protocol operates on a publish-subscribe communication model, whereas the VISS is designed around a client-server interaction model.
        To reconcile these differences, a lightweight application-level protocol is introduced on top of MQTT.
        This protocol encapsulates VISS messages within MQTT messages and includes additional metadata required to support client-server semantics.
        Details of this abstraction mechanism are provided in the following sections.<br>
        The VISS messages transmitted over MQTT SHALL conform to the primary payload format without modification.
      </p>

      <section id="application-level-protocol">
        <h2>Application Level Protocol</h2>
        <p>
          For MQTT to support the full VISSv3 interface, as decribed in the <a data-link-type="dfn" href="https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html#interface">section 5. Interface</a> of the [[CORE]] specification,
          an application-level protocol that runs on top of MQTT is required.
          This protocol is described below and illustrated in the accompanying sequence diagram.
          To emulate the client-server pattern that is described in the [[CORE]] specification, 
          the vehicle server—via its vehicle-side client—MUST subscribe to the broker on a topic named VID/Vehicle, 
          where VID represents a unique identifier that links the vehicle to the access control ecosystem.
          This vehicle identifier is not necessarily the manufacturer's Vehicle Identification Number (VIN).<br>
          The cloud-side client is expected to have access to this vehicle identifier.
          How it obtains it is out of scope for this specification.
          When the cloud client intends to send a request to the vehicle server, 
          it first generates a unique topic name and subscribes to it via the broker. 
          The client then generates a JSON formatted payload with the following structure:
          <pre><code>
          {"topic":"aUniqueTopic", "request":"VISSv3Request"}
          </code></pre>
          Here, "aUniqueTopic" is the topic name just subscribed to, and "VISSv3Request" is the actual request directed to the vehicle server.
          This request MUST follow the primary payload format of this specification.
          This JSON message is then published to the broker under the VID/Vehicle topic.
          The broker forwards the message to the vehicle client, which extracts the value of the "request" field and forwards it 
          to the vehicle server. Upon receiving a response, the vehicle client publishes the response message to the topic specified 
          by the original "topic" field in the received message.
          The broker then forwards this response to the cloud client, completing the client-server request-response cycle
          as described in the [[CORE]] specification.<br>
          For subscription requests, the vehicle client MUST store the subscriptionId from the subscribe response,
          together with the topic name associated to the subscribe request. When the vehicle server later issues event messages,
          the vehicle client SHALL extract the subscriptionId from it, and retrieve the topic name associated to it.
          The vehicle client SHALL delete the saved topic name and subscriptionId when it receives
          an unsubscribe request in a message from the broker.<br>
          In subsequent requests from the cloud client, the unique topic name MAY be reused from the previous request-response cycle,
          or a new unique topic name MAY be generated. If a new topic name is used, the previous one SHOULD be unsubscribed.
          The vehicle client MAY continue using the topic name to which it initially subscribed.<br>
          The payload format of all response and event messages SHALL conform to the primary payload format defined in this specification.
          The access control model is also applicable to this transport mechanism.
          The Access Token Server SHOULD implement its own version of the application-level protocol described here,
          using the topic name "VID/ATS". Similarly, the Access Grant Token Server MAY implement the same mechanism using the topic "VID/AGTS",
          or if it is deployed in the cloud it MAY expose the HTTPS interface defined in this specification.

        <figure id="VISSv3-over-mqtt">
          <img src="images/mqtt_vissv3_protocol.jpg" alt="VISSv3 over MQTT">
          <figcaption> <span class="fig-title">Message flow of VISSv3 over MQTT </span></figcaption>
        </figure>
        </p>
      </section>

      <section id="security-aspects">
        <h2>Security Aspects</h2>
        <p>
          The MQTT architecture requires the use of a broker, which serves as an intermediary between the client and server endpoints 
          (referred to as the subscriber and publisher in MQTT terminology).
          Since each TLS channel terminates at the broker, it has full access to all plaintext communication 
          between these endpoints. 
          This security consideration SHALL be taken into account when selecting MQTT as a transport protocol.
        </p>
      </section>

      <section id="transport-messages">
        <h2>Transport Messages</h2>
        <p>
          As described in the "Application Level Protocol" section, each request message sent to the broker SHALL include 
          two JSON-formatted key-value pairs.
          The value of the request key MUST be a string containing the client request intended for the vehicle server.
          This request MUST strictly adhere to the primary payload format defined in this specification.
        </p>
      </section>
    </section>

    <section id="grpc">
      <h2>gRPC</h2>
      <p>
      The gRPC protocol uses Protocol Buffers (Protobuf) for message serialization.
      The Protobuf message definitions SHALL be specified in a .proto file.
      The .proto file that defines the encoding of the VISS primary payload format is provided in the [[PAYLOAD ENCODING]] specification.
      A Protobuf compiler (e.g., protoc) is used to generate source code from the .proto file.
      This generated code facilitates the encoding and decoding between Protobuf and JSON payload formats.
      This code can be implemented in different languages, and is out of scope for the VISS standardization.
      An example implementation in the Go programming language can be found
      <a href="https://github.com/COVESA/vissr/blob/master/utils/grcputils.go">here</a>.
      </p>
    </section>
      </section>

      <section id="Defs">
        <h2>Definitions</h2>

        <section id="term-def">
          <h2>Term Definitions</h2>
	<table class="parameters">
	  <tbody><tr>
	    <th>Attribute</th>
	    <th>Type</th>
	    <th>Description</th>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-action">action</dfn></td>
	    <td> <a href="#action-def">Action</a></td>
	    <td>The type of action requested by the client or delivered by the server.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-path">path</dfn></td>
	    <td>string</td>
	    <td>The path to a node in the VSS tree, as defined by the
	    <a href="https://github.com/COVESA/vehicle_signal_specification">Vehicle Signal Specification (VSS)</a>.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-requestid">requestId</dfn></td>
            <td>string</td>
	    <td> Unique id value assigned by the client. Returned by the server in
	    the response and used by the client to link the request and response
	    messages. The value <em class="rfc2119" title="MAY">MAY</em> be an integer or a Universally Unique Identifier (UUID).</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-subscriptionid">subscriptionId</dfn> </td>
            <td>string</td>
	    <td>Value returned by the server to uniquely identify each subscription session.</td>
	  </tr>
	  <tr>
	    <td><dfn data-dfn-type="dfn" id="dfn-authorization">authorization</dfn> </td>
	    <td>string</td>
	    <td>A JSON Web Token (JWT) formatted security token.</td>
	  </tr>
	  <tr>
	    <td><b>data</b> </td>
	    <td>object / array</td>
	    <td>Data contains one or more objects each consisting of a path and a dp (data point).</td>
	  </tr>
	  <tr>
	    <td><b>dp</b> </td>
	    <td>object / array</td>
	    <td>A data point contains one or more objects each consisting of a value and a ts (timestamp).</td>
	  </tr>
	  <tr>
	    <td><dfn data-dfn-type="dfn" id="dfn-ts">ts</dfn> </td>
	    <td>string</td>
	    <td>The Coordinated Universal Time (UTC) timestamp that represents the capture of the value.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-value">value</dfn> </td>
	    <td>string/ object / array</td>
	    <td> The actual value associated with the signal path.</td>
	  </tr>
    <tr>
      <td> <dfn data-dfn-type="dfn" id="dfn-filter">filter</dfn> </td>
      <td> string </td>
      <td>A query string defining a filter to optimize subscriptions. Refer to the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#filter-request">section 7. Filter Request</a> of the [[CORE]] specification.</td>
    </tr>
    <tr>
      <td><dfn data-dfn-type="dfn" id="dfn-data-compression">data compression</dfn> </td>
      <td> string </td>
      <td>Compression of path and/or timestamp data.</td>
    </tr>
    <tr>
      <td> <b>metadata</b> </td>
      <td> object </td>
      <td>Metadata describing the potentially available signal (sub)tree.</td>
    </tr>
	  <tr>
	    <td id="dfn-error"><strong>error</strong></td>
	    <td> <a href="#error-def">Error</a> </td>
	    <td> An object containing error code, reason, and description.</td>
	  </tr>
	</tbody></table>
        </section>

        <section id="action-def">
          <h2>Action Definitions</h2>
	<p>The Action enumeration is used to define the type of action requested by the client.
	All client messages <em class="rfc2119" title="MUST">MUST</em> contain a JSON structure that has an
	<a href="#dfn-action" class="internalDFN" data-link-type="dfn">action</a> name/value pair and the
	value of the <a href="#dfn-action" class="internalDFN" data-link-type="dfn">action</a> property
	<em class="rfc2119" title="MUST">MUST</em> be one of the values specified in the enumeration:</p>

	<dl title="enum Action" class="idl">
	  <dt><b>get</b></dt>
	  <dd>Enables the client to read one or more values.</dd>
	  <dt><b>set</b></dt>
	  <dd>Enables the client to update one value.</dd>
	  <dt><b>subscribe</b></dt>
	  <dd>Enables the client to request event messages containing a JSON data structure with values for one or more vehicle signal.</dd>
	  <dt><b>unsubscribe</b></dt>
	  <dd>Enables the client to request that it should no longer receive event messages based on that subscription.</dd>
	  <dt><b>subscription</b></dt>
	  <dd>Enables the server to send event messages to the client containing a JSON data structure with values for one or more vehicle signals.</dd>
	  </dl>
        </section>

        <section id="error-def">
          <h2>Error Definitions</h2>
          <p>The error number SHOULD be a status code defined in [[RFC2616]], c. f. section "Status codes".
          The error reason SHOULD be short. two or three words connected by underscore.
          It SHOULD relate to the reason-phrase from [[RFC2616]] for the corresponding status code.
          The error description is meant to give more precise information of the error.
          </p>
<table class="simple">
  <thead>
    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3"><b>Error</b></th>
      <td><a href="#status-codes">number</a></td><td>string</td><td>Yes</td></tr>
      <tr><td><a href="#status-codes">reason</a></td><td>string</td><td>Yes</td></tr>
      <tr><td><a href="#status-codes">description</a></td><td>string</td><td>Yes</td></tr>

  </tbody>
  </table>
        </section>

    <div id="tof" class="appendix"></div>
  </body>
</html>
