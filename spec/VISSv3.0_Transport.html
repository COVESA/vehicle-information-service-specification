<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>COVESA VISS version 3.0-Transport</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
    <script class='remove'>
      var respecConfig = {
        latestVersion: null,
        github: "https://github.com/COVESA/vehicle-information-service-specification",
        specStatus: "base",
	logos: [{
	  src: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/images/covesa.jpg",
          url: "https://covesa.global",
          alt: "COVESA",
          height: 50,
          id: "covesa-logo",
        },],
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Ford Motor Company",
          companyURL: "https://www.ford.com",
        },
        {
          name: "이원석(Wonsuk Lee)",
          company: "한국전자통신연구원(ETRI)",
          url: "mailto:wonsuk.lee@etri.re.kr",
          companyURL: "https://etri.re.kr/eng/main/main.etri",
          w3cid: 34457
        }],
        edDraftURI: "https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Transport.html",
        shortName: "viss3-transport",
        localBiblio: {
          "SemVer": {
            title: "Semantic Versioning 2.0.0",
            href: "https://semver.org/spec/v2.0.0.html",
            status: "published",
            publisher: "Tom Preston-Werner"
          },
          "PAYLOAD ENCODING": {
            title: "COVESA VISS version 3.0-Payload Encoding",
            href: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_PayloadEncoding.html",
            publisher: "Ulf Bjorkengren"
          },
          "CORE": {
            title: "COVESA VISS version 3.0-Core",
            href: "https://raw.githack.com/COVESA/vehicle-information-service-specification/main/spec/VISSv3.0_Core.html",
            publisher: "Ulf Bjorkengren"
          }
        }
      };
    </script>
    <style>
      table.parameters, table.exceptions {
          border-spacing: 0;
          border-collapse:    collapse;
          margin: 0.5em 0;
          width:  100%;
      }
      table.parameters { border-bottom:  1px solid #90b8de; }
      table.exceptions { border-bottom:  1px solid #deb890; }

      .parameters th, .exceptions th {
          color:  inherit;
          padding:    3px 5px;
          text-align: left;
          font-weight:    normal;
      }
      .parameters th { color: #fff; background: #005a9c; }
      .exceptions th { background: #deb890; }

      .parameters td, .exceptions td {
          padding:    3px 10px;
          border-top: 1px solid #ddd;
          vertical-align: top;
      }

      .parameters tr:first-child td, .exceptions tr:first-child td {
          border-top: none;
      }

      .parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
          width:  100px;
      }

      .parameters td.prmType {
          width:  120px;
      }

      table.exceptions table {
          border-spacing: 0;
          border-collapse:    collapse;
          width:  100%;
      }

      .simple {
        width:100%;
      }

      thead th{
        border-bottom: 1px solid black;
      }

      .simple tbody th{
        width:33%;
        background: white;
        color: black;
      }
      pre { white-space: pre-wrap;}
  </style>
  </head>
  <body>
    <p class="copyright">Copyright © 2024 COVESA®. This document includes material copied from or derived from <a href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html">W3C VISS version 2 - Core</a>.</p>
    <section id='abstract'>
      <p>The Vehicle Information Service Specification (VISS) is a
      service for accessing vehicle information, signals from sensors
      on control units within a vehicle's network. It exposes this
      information using a hierarchical tree like taxonomy defined in
      COVESA Vehicle Signal Specification (VSS). The service provides
      this information in JSON format. The service may reside in the
      vehicle, or on servers in the internet with information
      already brought off the vehicle.</p>

      <p>This specification describes a third version of VISS which
      has been implemented and deployed on production vehicles.
      The first version of VISS only supported WebSocket as a
      transport protocol, the second version is generalized to work
      across different protocols as some are better suited for
      different use cases.
      The second version added support for the HTTP and MQTT transport
      protocols, subscription capabilities was improved and an
      access control solution was added.</p>

      <p>
        There are three parts to this specification, [[CORE]], [[PAYLOAD ENCODING]], and TRANSPORT. This document, the VISS version 3.0 TRANSPORT specification,
        describes the VISSv3 transport protocols, and the mapping of the message layer on these transports.
        The companion specification [[CORE]] describes the messaging layer, and [[PAYLOAD ENCODING]] describes payload encodings to/from the primary JSON payload format.
      </p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>This document provides examples of how the message payloads defined in [[CORE]] are used together with different transport protocols.
      The Websocket ([[RFC6455]]) transport protocol is used to give an example of how the JSON primary payload format is directly used.
      This is followed by examples of other transport protocols where exceptions from the primary payload format are defined and exemplified.<br>
      The Vehicle Information Service Specification, version 3.0 permits any transport protocol to be used that can transport the unaltered primary payload format.
      Transport protocols that require modifications or transformations of the primary payload format MUST define this in either this document or in the [[PAYLOAD ENCODING]] document.
      The transport protocols that define deviations in this document are listed below.
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Protocol name</th>
	    <th>Reference</th>
	  </tr>
	  <tr>
	    <td>HTTP</td>
	    <td>[[RFC9112]]</td>
	  </tr>
	  <tr>
	    <td>MQTT</td>
	    <td>[[MQTT]]</td>
	  </tr>
	  <tr>
	    <td>gRPC</td>
	    <td><a href="https://grpc.io/">[gRPC]</a></td>
	  </tr>
	</tbody></table>
      The Websocket protocol is included to provide an example for protocols that does not introduce any deviations so therefore it is not shown on the list above.
      </p>
    </section>

    <section id="conformance"></section>

    <section id="terminology">
      <h2>Terminology</h2>
      <p>
      The acronym 'VISSv3.0' is used to refer to this document, the VISS version 3.0 specification.
      The acronym 'VSS' is used to refer to the <a href="https://github.com/COVESA/vehicle_signal_specification">'Vehicle Signal Specification'</a>
      which is hosted by COVESA.
      The term 'WebSocket' when used in this document, is as defined in the
      <a href="https://www.w3.org/TR/websockets/">W3C WebSocket API</a> and [[RFC6455]], the WebSocket Protocol.
      </p>
    </section>

    <section id="transport-common-defs">
      <h2>Transport Common Definitions</h2>
      <p>This chapter defines features that SHALL be common for all transport protocols.</p>

      <section id="status-codes">
        <h2>Status Codes</h2>
	<p>A server implementing this specification <em class="rfc2119" title="SHALL">SHALL</em> support the error codes,
	error reasons and error descriptions shown in the table below, for all supported transport protocols.
	The server may choose to dynamically replace the error description as described in the sub-chapters<br>
        The client <em class="rfc2119" title="MAY">MAY</em> support any status code defined in [[RFC2616]].</p>
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Error&nbsp;Number&nbsp;(Code)</th>
	    <th>Error Reason</th>
	    <th>Error Description</th>
	  </tr>
	  <tr>
	    <td>400 (Bad Request)</td>
	    <td>bad_request	</td>
	    <td>The request is malformed</td>
	  </tr>
	  <tr>
	    <td>400 (Bad Request)</td>
	    <td>invalid_data</td>
	    <td>Data in the request is invalid</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>invalid_token</td>
	    <td>Access token is invalid</td>
	  </tr>
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>forbidden_request</td>
	    <td>The server refuses to carry out the request</td>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>unavailable_data</td>
	    <td>The requested data was not found</td>
	  </tr>
	  <tr>
	    <td>408 (Request Timeout)</td>
	    <td>request_timeout</td>
	    <td>Subscribe duration limit exceeded</td>
	  </tr>
	  <tr>
	    <td>429 (Too Many Requests)</td>
	    <td>too_many_requests</td>
	    <td>Rate-limiting due to too many requests</td>
	  </tr>
	  <tr>
	    <td>502 (Bad Gateway)
	    <td>bad_gateway</td>
	    <td>The upsteam server response was invalid</td>
	  </tr>
	  <tr>
	    <td>503 (Service Unavailable)</td>
	    <td>service_unavailable</td>
	    <td>The server is temporarily unable to handle the request</td>
	  </tr>
	  <tr>
	    <td>504 (Gateway Timeout)</td>
	    <td>gateway_timeout</td>
	    <td>The upsteam server took too long to respond</td>
	  </tr>
	</tbody></table>

      <section id="400-bad-request">
        <h2>400 Bad Request Error Descriptions</h2>
        <p>
        This error code and reason shall be used for JSON schema related errors.
        The default error description is shown in the table above. The server may dynamically replace this by any of the error descriptions in the list below,
        or by any other relevant error description.
        </p>
        <ul>
            <li>Missing or invalid action</li>
            <li>Missing or invalid path</li>
            <li>Missing or invalid filter</li>
            <li>Missing or invalid value</li>
        </ul>
      </section>

      <section id="400-invalid-data">
        <h2>400 Invalid Data Error Descriptions</h2>
        <p>
        This error code and reason shall be used for errors that are not covered by the JSON schema but e. g. breaks a rule set by a VSS property.
        The default error description is shown in the table above. The server may dynamically replace this by any of the error descriptions in the list below,
        or by any other relevant error description.
        </p>
        <ul>
            <li>Update of a sensor is not supported</li>
            <li>Requested action on a branch is not supported</li>
            <li>Data value outside limit</li>
            <li>Incorrect data type</li>
        </ul>
      </section>

      <section id="401-unauthorized">
        <h2>401 Unauthorized Error Descriptions</h2>
        <p>
        This error code and reason shall be used for errors related to access control validation.
        The default error description is shown in the table above. The server may dynamically replace this by any of the error descriptions in the list below,
        or by any other relevant error description.
        </p>
        <ul>
            <li>Access token has expired</li>
            <li>Access token is missing</li>
        </ul>
      </section>

      <section id="404-not-found">
        <h2>404 Not Found Error Descriptions</h2>
        <p>
        This error code and reason shall be used when the server do not have access to the requested data.
        The default error description is shown in the table above. The server may dynamically replace this by any of the error descriptions in the list below,
        or by any other relevant error description.
        </p>
        <ul>
            <li>Data temporarily unaccessible</li>
            <li>Data is unknown</li>
        </ul>
      </section>
      </section>

      <section id="transport-payload">
        <h2>Transport Payload</h2>
        <p>The payload SHALL have JSON format.
        See the JSON Schema chapter in the CORE document for the primary payload format.
        </p>
      </section>

      <section id="authorization">
        <h2>Authorization</h2>
          <p>If authorization is enabled on a signal requested by the client,
          it MUST provide a token to the server in order to verify that it is correctly authorized for the service it requests
          (see [[CORE]] document).Tokens are integrated in HTTP requests in the <code>Authorization</code> header.
          For protocols using the primary payload format an optional <code>authorization</code> property in the payload SHALL be used.
          </p>
      </section>
    </section>

    <section id="transport-protocols">
      <h2>Transport Protocols</h2>
      <p>
      The VISSv3.0 specification lists the transport protocols HTTP, WebSocket, gRPC, and MQTT as supported.
      However, this is not necessarily a final list as says that any protocol that transport the primary payloads of this specification,
      or an encoded version of the primary payloads, can be included on this list.<br>
      The specification does not mandate any specific transport protocol,
      but at least one of the listed transport protocols MUST be supported.
      </p>

      <section id="secure-websocket">
        <h2>Secure WebSocket</h2>
        <p>
        The WebSocket protocol is used in this document to provide examples of a protocol that does not apply any deviations to the primary payload format.
        As it does not implicitly provide a logical association between the request and response messages
        a key-value pair with the keyname "requestId" is added to the data components as described in the [[CORE]] document.<br>
        As the WebSocket protocol neither specifies a set of explicit methods,
        another key-value pair with the keyname "action" is also added. See <a href='#action-def'></a> for the declaration of these key-value pairs.
        All data components are mapped to the payload.
        </p>

        <section id="wss-lifetime-mngmnt">
          <h2>Session Life Time Management</h2>

          <section id="wss-initialisation">
            <!--OddPage--><h2>Initialization</h2>

	<p>If the client application is an HTML Application running in a web
	runtime or is a web page running in a browser, the WebSocket
	instance may either be instantiated natively or be created using a
	'standards compliant' WebSocket JavaScript library.</p>
	<p>A WebSocket can also be initiated from a native (e.g. C++) Application
	or from an Application written using a 'Managed Runtime' language like
	Java or C#. It is assumed that native and managed clients use a
	suitable standards compliant WebSocket library to request that a
	WebSocket connection is opened on the server.</p>

	<p>Implementations that support additional devices or multiple VISSv3 services
        should provide discovery. Alternatively, the location of a particular VISSv3
        Server instance on the local vehicle network may be handled by
        configuration, either as part of a package manifest or by consulting a
        registry on application install. The 'wwwVISSv3' hostname in this
        specification is used an example.
	</p>
	
	<p>A client running on the vehicle is able to connect to the
	VISSv3 Server instance using the hostname e.g. 'wwwVISSv3' and uses the
	default port 6443. The hostname 'wwwVISSv3' may locally be mapped to the localhost
	IP address 127.0.0.1 e.g. by adding an entry to the /etc/hosts file.</p>

	<p>The sub-protocol name <em class="rfc2119" title="SHALL">SHALL</em> be 'VISSv3' with the digit 3 being the version number.
	The sub-protocol version will
	be associated with exactly one VISS Server Specification version so that the client and server can
	correctly validate and parse request and response message packets.</p>
        <pre><code>
	var vehicle  = new WebSocket("wss://wwwVISSv3:6443", "VISSv3");
        </code></pre>
	<p>The client <em class="rfc2119" title="SHALL">SHALL</em> connect to the server over HTTPS and request that
	the server opens a WebSocket. All WebSocket communications between
	the client and server <em class="rfc2119" title="MUST">MUST</em> be over ‘wss’. Non encrypted communication
	is not supported, hence the server <em class="rfc2119" title="MUST">MUST</em> refuse ‘ws’ connection requests.</p>
	
        <p>This specification assumes that a single WebSocket is used to enable communication between a client application
        and the server. The client MAY open more than one websocket.
        However, the server <em class="rfc2119" title="MAY">MAY</em> refuse to open a subsequent WebSocket connection and
        the client is responsible for handling this gracefully.
        </p>

        <p>If more than one WebSocket connection is established between a client application and the server then each connection
        <em class="rfc2119" title="MUST">MUST</em> be managed independently. For example, subscriptions created using a particular
        WebSocket connection shall only trigger event messages via that connection and the client
        <em class="rfc2119" title="MUST">MUST</em> use that WebSocket connection to unsubscribe.
        </p>

        <p>If more than one WebSocket connection has been established
        between one or more clients and a particular server instance, there
        is a risk that race conditions and concurrency issues could occur.
        An example of this would be where two or more WebSocket connections
        are used to update a particular setting at the same time.
        </p>

        <p>Unless explicitly stated otherwise, the client <em class="rfc2119" title="MAY">MAY</em> only assume
        that the server implements a simple concurrency model where lost
        updates and dirty reads could potentially occur if the server has
        more than one WebSocket connection open.
        </p>	
          </section>

          <section id="wss-closure">
            <!--OddPage--><h2>Closure</h2>
	<p>The WebSocket may be closed by either the client or the
	server by invoking the ‘close()’ method on the WebSocket
	instance.</p>

	<p>The following example shows the lifetime of a WebSocket on
	the client:</p>
        <pre><code>
	// Open the WebSocket</span>
	var vehicle  = new WebSocket("wss://wwwVISSv3:6443", "VISSv3");
	…
	// Close the WebSocket
	vehicle.close();
        </code></pre>
	<p>The VISSv3 Server may terminate the WebSocket connection if it has not received a request for a period determined by
	the server. It is the client’s responsibility to handle this gracefully and to recover and request new subscriptions, where required.
	</p>
        </section>
      </section>

      <section id="wss-transport-messages">
          <h2>Transport Messages</h2>

          <section id="wss-read-message">
            <h2>Read</h2>
            <p>The client <em class="rfc2119" title="MAY">MAY</em> send a <a href="#dfn-getrequest" class="internalDFN" data-link-type="dfn">getRequest</a>
            message to the server to get the value of one or more vehicle signals.
            If the server is able to satisfy the request it <em class="rfc2119" title="SHALL">SHALL</em> return a
            <a href="#dfn-getsuccessresponse" class="internalDFN" data-link-type="dfn">getSuccessResponse</a> message.
            If the server is unable to fulfil the request, e.g. because the client is not authorized to retrieve one or more of the signals,
            then the server <em class="rfc2119" title="SHALL">SHALL</em> return a
            <a href="#dfn-geterrorresponse" class="internalDFN" data-link-type="dfn">getErrorResponse</a> message.
            The structure of these message objects is defined below.
            </p><br>
            <table class="simple">
            <thead>
              <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
            </thead>
            <tbody>
                <tr><th rowspan="6"><dfn data-dfn-type="dfn" id="dfn-getrequest">getRequest</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
                <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
	        <tr><td><a href="#dfn-filter">filter</a></td><td>string</td><td>Optional</td></tr>		
                <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
                <tr><td><a href="#dfn-data-compression">data compression</a></td><td>string</td><td>Optional</td></tr>
                <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
            </tbody>
            </table>
            <br>
            <table class="simple">
            <thead>
              <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
            </thead>
            <tbody>
             <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-getsuccessresponse">getSuccessResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
             <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
             <tr><td><a href="#dfn-value">data</a></td><td>object/array</td><td>Yes</td></tr>
 	     <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
           </tbody>
           </table>
           <p>
           In the table above the "data" attribute is either an object containing "value" and "ts" name/value pairs, or an array of such objects.
           </p>
           <table class="simple">
           <thead>
             <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
           </thead>
           <tbody>
           <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-geterrorresponse">getErrorResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
           <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
           <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
           <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
           </tbody>
           </table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Drivetrain.InternalCombustionEngine.RPM",
                "requestId": "8756"
              }
              </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8756",
                "data":{"path":"Vehicle.Drivetrain.InternalCombustionEngine.RPM",
                        "dp":{"value":"2372", "ts":"2020-04-15T13:37:00Z"}
                },
                "ts":"2020-04-15T13:37:05Z"
              }
              </code></pre>
              Error response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8756",
                "error": {"number": 404, "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>

          <section id="wss-authorized-read">
            <h2>Authorized Read</h2>
            <p> If the operation on the VSS node that is addressed requires authorization,
               then the request must contain the field "authorization" with its value being a JWT token.
               The token validation must be successful for a
               <a href="#dfn-getsuccessresponse" class="internalDFN" data-link-type="dfn">getSuccessResponse</a>
	       to be returned, else a <a href="#dfn-geterrorresponse" class="internalDFN" data-link-type="dfn">getErrorResponse</a> is returned.
	       A token can be combined with all types of read requests.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Drivetrain.InternalCombustionEngine.RPM",
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds",
                "requestId": "8657"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8657",
                "data":{"path":"Vehicle.Drivetrain.InternalCombustionEngine.RPM",
                        "dp":{"value":"2372", "ts":"2020-04-15T13:37:00Z"}
                },
                "ts":"2020-04-15T13:37:01Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-search-read">
            <h2>Search Read</h2>
            <p>A client may issue a search read request to access multiple values in one request message.
               This is realized by adding a "filter" object following the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#paths-filter-operation">paths filter operation</a> described in the [[CORE]].
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Cabin",
                "filter": {"variant":"paths", "parameter":["Door.*.*.IsOpen", "DriverPosition"]},
                "requestId": "5688"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "data":[{"path":"Vehicle.Cabin.Door.Row1.Left.IsOpen", "dp":{"value":"false", "ts":"2020-04-15T13:37:00Z"}},
                        {...},…
                        {"path":"Vehicle.Cabin.Door.Row4.Right.IsOpen", "dp":{"value":"true", "ts":"2020-04-15T13:37:01Z"}},
                        {"path":"Vehicle.Cabin.DriverPosition", "dp":{"value":"1", "ts":"2020-04-15T07:00:01Z"}}
                       ],
                "requestId": "5688",
                "ts":"2020-04-15T07:00:02Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-history-read">
            <h2>History Read</h2>
            <p>A client may issue a history read request to access recorded data points.
               This is realized by adding a "filter" object following the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#history-filter-operation">history filter operation</a> described in the [[CORE]].
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Acceleration.Longitudinal",
                "filter": {"variant":"history", "parameter":"P2DT12H"},
                "requestId": "5688"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "data": {"path": "Vehicle.Acceleration.Longitudinal", "dp": [{"value": "0.123", "ts": "2020-04-15T13:00:00Z"}, {"value": "0.125", "ts": "2020-04-15T13:37:02Z"}]},
                "requestId": "5688",
                "ts": "2020-04-15T13:37:02Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-signal-discovery-read">
            <h2>Signal Discovery Read</h2>
            <p>
              The signal discovery request uses the metadata filtering type as described in the [[CORE]] document to retrieve metadata in the VSS tree.
               A successful response will contain the requested metadata from all nodes of the subtree defined by
               the node that is addressed by the path and the requested depth set by the "parameter" value.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Drivetrain.FuelSystem",
                "filter":{"variant":"metadata", "parameter":"2"},
                "requestId": "5687"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "requestId": "5687",
                "metadata": {"FuelSystem":{"type":"branch","children":["HybridType", ... ]}},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>
          </section>

          <section id="wss-update">
            <h2>Update</h2>
            <p>
            The client may request that the server sets the value of a signal.
            If the server is able to satisfy the request it <em class="rfc2119" title="SHALL">SHALL</em> return a
            <a href="#dfn-setsuccessresponse" class="internalDFN" data-link-type="dfn">setSuccessResponse</a> message.
            If an error occurs e.g. because the client is not authorized to set the requested value, or the value is read-only,
            the server <em class="rfc2119" title="SHALL">SHALL</em> return a
            <a href="#dfn-seterrorresponse" class="internalDFN" data-link-type="dfn">setErrorResponse</a> message.
            </p>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5">setRequest</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
          <tr><td><a href="#dfn-value">value</a></td><td>string/array/object</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="3"><dfn data-dfn-type="dfn" id="dfn-setsuccessresponse">setSuccessResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-seterrorresponse">setErrorResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "set",
                "path": "Vehicle.Drivetrain.Transmission.PerformanceMode",
                "value": "sport",
                "requestId": "5687"
              }
               </code></pre>
             Successful response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
             Error response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "error": {"number": 404, "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>

         <section id="wss-authorized-update">
            <h2>Authorized Update</h2>
            <p>If the operation on the VSS node that is addressed requires authorization,
               then the request must contain the field "authorization" with its value being a JWT token.
               The token validation must be successful for a
               <a href="#dfn-setsuccessresponse" class="internalDFN" data-link-type="dfn">setSuccessResponse</a>
	       to be returned, else a <a href="#dfn-seterrorresponse" class="internalDFN" data-link-type="dfn">setErrorResponse</a> is returned.
	       A token can be combined with all types of update requests.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "set",
                "path": "Vehicle.Drivetrain.Transmission.PerformanceMode",
                "value": "sport",
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds",
                "requestId": "5687"
              }
               </code></pre>
              Response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>
          </section>

          <section id="subscribe">
            <h2>Subscribe</h2>
            <p>
            The client may send a <a href="#dfn-subscriberequest" class="internalDFN" data-link-type="dfn">subscribeRequest</a> message
            to request a subscription to one or more signals,
            thereby requesting the server to repeatedly return subscription event messages, as specified by
	    the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#filter-request">filter request</a> described in the [[CORE]].
            The server <em class="rfc2119" title="MAY">MAY</em> reduce the number of
            <a href="#dfn-subscriptionevent" class="internalDFN" data-link-type="dfn">subcriptionEvent</a>
            messages sent to the client in order to reduce processing demands.<br>
            If the server is able to satisfy the request it SHALL return a
            <a href="#dfn-subscribesuccessresponse" class="internalDFN" data-link-type="dfn">subscribeSuccessResponse</a> message.
            If an error occurs e.g. because the client is not authorized to read the requested value, the server SHALL return a
            <a href="#dfn-subscribeerrorresponse" class="internalDFN" data-link-type="dfn">subscribeErrorResponse</a> message.
            If an error occurs during the subscription session, the server shall return an
            <a href="#dfn-subscriptionerrorevent" class="internalDFN" data-link-type="dfn">subscriptionErrorEvent</a> message.<br>
            The subscription variants are, as described in the [[CORE]] document:
	  <ul>
	  <li>timebased: event messages are issued at a regular time interval,</li>
	  <li>change: event messages are issued when the value has changed as specified,</li>
	  <li>range: event messages are issued when the value is in the specified range,</li>
	  <li>curvelog: event messages are issued when the buffer is full, and then processed according to the curve logging algorithm.</li>
	  </ul>

            </p>
	<table class="simple">
 	<thead>
	   <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	 </thead>
	 <tbody>
	   <tr><th rowspan="6"><dfn data-dfn-type="dfn" id="dfn-subscriberequest">subscribeRequest</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	   <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
	   <tr><td><a href="#dfn-filter">filter</a></td><td>string</td><td>Yes</td></tr>
	   <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
           <tr><td><a href="#dfn-data-compression">data compression</a></td><td>string</td><td>Optional</td></tr>
	   <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	 </tbody>
	 </table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-subscribesuccessresponse">subscribeSuccessResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-subscribeerrorresponse">subscribeErrorResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5"><dfn data-dfn-type="dfn" id="dfn-subscriptionevent">subscriptionEvent</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-value">data</a></td><td>object/array</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-subscriptionerrorevent">subscriptionErrorEvent</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Drivetrain.FuelSystem.Level",
                "filter": {"variant":"timebased", "parameter":{"period":"500"}},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error response:
              <pre><code>
              {
                "action": "subscribe",
                "requestId": "6578",
                "error": {"number": 404, "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data": {"path": "Vehicle.Drivetrain.FuelSystem.Level",
                        "dp": {"value": "50", "ts": "2020-04-15T13:37:00Z"}
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "error": {"number": 401, "reason": "expired_token", "description": "Access token has expired."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>

          <section id="authorized-subscribe">
            <h2>Authorized Subscribe</h2>
            <p>
            If the operation on the VSS node that is addressed requires authorization,
            then the request must contain the field "authorization" with its value being a JWT token.
            The token validation must be successful for a
            <a href="#dfn-subscribesuccessresponse" class="internalDFN" data-link-type="dfn">subscribeSuccessResponse</a>
            to be returned, else a
            <a href="#dfn-subscribeerrorresponse" class="internalDFN" data-link-type="dfn">subscribeErrorResponse</a> is returned.
            An "authorization" key-value pair can be combined with all types of subscription requests.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Drivetrain.FuelSystem.Level",
                "filter": {"variant":"range", "parameter":[{"logic-op":"gt", "boundary":"49"}, {"logic-op":"lt", "boundary":"51"}]},
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds",
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data": {"path": "Vehicle.Drivetrain.FuelSystem.Level",
                        "dp": {"value": "50", "ts": "2020-04-15T13:37:00Z"}
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>

          <section id="curve-logging-subscribe">
            <h2>Curve Logging Subscribe</h2>
            <p>
            Curve logging data compression by eliminating data points that are within a set error margin is activated via a subscription request.
            Event messages will be issued when the buffer becomes full, after insignificant data points have been eliminated,
            refer the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#curvelog-filter-operation">Curve logging Filter Operation</a> chapter in the [[CORE]] documentation.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Drivetrain.FuelSystem.Level",
                "filter": {"variant":"curvelog", "parameter":{"maxerr":"0.5", "bufsize":"100"}},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data":{"path": "Vehicle.Drivetrain.FuelSystem.Level",
                        "dp":[{"value": "50", "ts": "2020-04-15T13:38:00Z"}, ..., {"value": "25", "ts": "2020-04-15T13:39:30Z"}]
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>

          <section id="range-subscribe">
            <h2>Range Subscribe</h2>
            <p>
            Subscription to a range of values, that can have either a single boundary, or multipe boundaries as in the example below.
            For a more information how to use range of values, refer the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#range-filter-operation">Range Filter Operation</a> chapter in the [[CORE]] documentation.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Drivetrain.FuelSystem.Level",
                "filter": "filter":{"variant":"range","parameter":[{"logic-op":"lt","boundary":"50","combination-op":"OR"},{"logic-op":"gt","boundary":"55"}]},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data":{"path": "Vehicle.Drivetrain.FuelSystem.Level",
                        "dp":{"value": "51", "ts": "2020-04-15T14:00:00Z"}},
                "ts": "2020-04-15T14:00:00Z"
              }
               </code></pre>
            </p>
          </section>

          <section id="change-subscribe">
            <h2>Change Subscribe</h2>
            <p>
            Subscription to when a signal has changed between two sequential captures.
            For a more information how to use change of values, refer the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#change-filter-operation">Change Filter Operation</a> chapter in the [[CORE]] documentation.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle.Drivetrain.FuelSystem.Level",
                "filter":{"variant":"change","parameter":{"logic-op":"gt","diff":"10"}},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Event:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "data":{"path": "Vehicle.Drivetrain.FuelSystem.Level",
                        "dp":{"value": "101", "ts": "2020-04-15T14:00:00Z"}},
                "ts": "2020-04-15T14:00:00Z"
              }
               </code></pre>
            </p>
          </section>
          </section>

          <section id="unsubscribe">
            <h2>Unsubscribe</h2>
            <p>
            To unsubscribe from a subscription, the client <em class="rfc2119" title="SHALL">SHALL</em> send an
            <a href="#dfn-unsubscriberequest" class="internalDFN" data-link-type="dfn">unsubscribeRequest</a> message to the server.
            If the server is able to satisfy the request it returns an
            <a href="#dfn-unsubscribesuccessresponse" class="internalDFN" data-link-type="dfn">unsubscribeSuccessResponse</a> message.
            If an error occurs, for example because an invalid subscriptionId is passed to the server, an
            <a href="#dfn-unsubscribeerrorresponse" class="internalDFN" data-link-type="dfn">unsubscribeErrorResponse</a> message is returned.
            <br>
            If the client has created more than one WebSocket instance, it <em class="rfc2119" title="MUST">MUST</em> always unsubscribe
            using the same WebSocket instance that was originally used to create the subscription.
            </p>
	<table class="simple">
	  <thead>
	    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	  </thead>
	  <tbody>
	    <tr><th rowspan="3"><dfn data-dfn-type="dfn" id="dfn-unsubscriberequest">unsubscribeRequest</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	    <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  </tbody>
	  </table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="3"><dfn data-dfn-type="dfn" id="dfn-unsubscribesuccessresponse">unsubscribeSuccessResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-unsubscribeerrorresponse">unsubscribeErrorResponse</dfn></th><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "unsubscribe",
                "subscriptionId": "12345",
                "requestId": "5786"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "unsubscribe",
                "requestId": "5786",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error response:
              <pre><code>
              {
                "action": "unsubscribe",
                "requestId": "6578",
                "error": {"number": 400, "reason": "invalid_data", "description": "Data present in the request is invalid."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>
        </section>
      </section>

      <section id="https">
        <h2>HTTPS</h2>
        <p>The message data components described in the [[CORE]] document are in the first hand mapped to required HTTP parameters,
        and only when there is no appropriate mapping it is mapped to the payload.
        The most significant deviations are:
        <ul>
          <li>The path is part of the URL.</li>
          <li>A filter expression is appended to the URL as a query.</li>
          <li>The HTTP methods GET, POST replaces the use of "action".</li>
        </ul>
        The subscribe/unsubscribe messages are not supported by this transport protocol.
        </p>

        <section id="https-life-time-mngmnt">
          <h2>Session Life Time Management</h2>

          <section id="https-initialisation">
            <h2>Initialization</h2>
            <p>Initialization involves setting up a secure HTTPS session between the client and the server.
               This ensures encrypted communication for data transmission.
               To initialize a secure session, the client sends a request to the server using the HTTPS protocol.
               This is achieved by connecting to the server's designated URL using the 'https://' scheme.
               The client can use a web browser, a native application, or a suitable library in the case of programmatically managed sessions.<br>
               While the client typically connects to the server using the specified hostname, which often includes the "www" prefix,
               it's important to note that this convention may not apply in situations where VISS operates within a local, in-vehicle network or if remote vehicle connections are allowed.
               The communication SHALL use port 443, the default port for secure HTTPS connections.
               The hostname resolution can be done via DNS or configured through local settings.
            </p>
          </section>

          <section id="https-closure">
            <h2>Closure</h2>
            <p>Closure entails ending the established HTTPS session when the communication is complete or when the client no longer requires the connection.
              Either the client or the server can initiate the session closure. The client can signal the end of the session by sending an appropriate request to the server,
              indicating the intent to close the connection.<br>
              Upon session closure, any allocated resources, such as server-side threads or memory, are released, improving overall system efficiency.
            </p>
          </section>
        </section>

        <section id="https-transport-messages">
          <h2>Transport Messages</h2>

          <section id="https-read">
            <h2>Read</h2>
            <p>
            The client MAY send a HTTPS GET request message to the server to get one or more value(s) of one or more vehicle signal(s).
            If the server is able to satisfy the request it SHALL return a response containing the requested value(s).
            If the server is unable to fulfil the request, e.g. because the client is not authorized to retrieve one or more of the signals,
            then the server response SHALL have the status code set to indicate error.
            </p>
            <p>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle/Cabin/SeatPosCount   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Successful response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "data":{"path":"Vehicle.Cabin.SeatPosCount",
                        "dp":{"value":["2", "3", "2"], "ts":"2020-04-15T13:37:00Z"}
                       },
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
              Error response:
              <pre><code>
              HTTP/1.1 404 Not Found
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "error": {"number": 404, "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>

          <section id="https-authorized-read">
            <h2>Authorized Read</h2>
            <p>
            JWT tokens will be sent in the <code>Authorization</code> header, following with term <code>Bearer</code> and a space character.
            </p>
            <p>
            The following example assumes
            <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds</code>
            is the actual token. A token header can be combined with all types of read requests.
            <br>
            <b>Example:</b>
            Request:		
            <pre><code>
            GET /Vehicle/Drivetrain/InternalCombustionEngine/RPM   HTTP/1.1
            Host:127.0.0.1:1337
            Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds
            </code></pre>
            Successful response:
            <pre><code>
            HTTP/1.1 200 OK
            Content-Type: application/json; charset=utf-8
	    ...
            {
              "data":{"path":"Vehicle.Drivetrain.InternalCombustionEngine.RPM",
                      "dp":{"value":"2372", "ts":"2020-04-15T13:37:00Z"}
                     },
                "ts": "2020-04-15T13:37:00Z"
            }
            </code></pre>
            Error response:
            <pre><code>
            HTTP/1.1 401 Unauthorized
            WWW-Authenticate: Bearer realm="127.0.0.1:1337",
                                     error="invalid_token",
                                     error_description="The access token is invalid or expired"	
            Content-Type: application/json; charset=utf-8
	    ...
            {
              "error": {"number": 401, "reason": "invalid_token", "description": "Access token is invalid."},
              "ts": "2020-04-15T13:37:00Z"
            }
            </code></pre>
	    </p>
          </section>

          <section id="https-search-read">
            <h2>Search Read</h2>
            <p>
              The search read request uses the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#paths-filter-operation">paths filter operation</a> described in the [[CORE]] document to provide one or more path expressions,
              relative to the path in the GET URL.<br>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle/Cabin/Door?filter={"variant":"paths", "parameter":"*/*/IsOpen"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "data":[{"path":"Vehicle.Cabin.Door.Row1.Left.IsOpen", "dp":{"value":"false", "ts":"2020-04-15T13:37:00Z"}},
                        {...},…
                        {"path":"Vehicle.Cabin.Door.Row4.Right.IsOpen", "dp":{"value":"true", "ts":"2020-04-15T13:37:00Z"}}
                       ],
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
              Error response:
              <pre><code>
              HTTP/1.1 404 Not Found
              Content-Type: application/json; charset=utf-8
	      ...
              {
                        "error": {"number": 404, "reason": "unavailable_data", "description": "The requested data was not found."},
                        "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>		
            </p>
          </section>

          <section id="https-history-read">
            <h2>History Read</h2>
            <p>
              The history read request uses the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#history-filter-operation">history filter operation</a> described in the [[CORE]] document to read recorded values
              for a given period backwards in time.<br>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle.Acceleration.Longitudinal?filter={"variant":"history", "parameter":"P2DT12H"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "data":{"path":"Vehicle.Acceleration.Longitudinal", "dp":[{"value":"0.123", "ts":"2020-04-15T13:00:00Z"}, ..., {"value":"0.125", "ts":"2020-04-15T13:37:00Z"}]},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="https-service-discovery-read">
            <h2>Signal Discovery Read</h2>
            <p>
              The signal discovery request uses the metadata filtering type as described in the [[CORE]] document to retrieve metadata in the VSS tree.
              A successful response will contain the requested metadata from all nodes of the subtree defined by the subtree root node
              that is addressed by the path and the requested depth set by the "parameter" value.<br><br>
              <b>Example:</b><br>
              Request:
              <pre><code>
              GET /Vehicle/Drivetrain/FuelSystem?filter={"variant":"metadata", "parameter":"0"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "metadata": {"FuelSystem":{"type":"branch","description":"Fuel system data.","children":{"HybridType, ... }}},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="https-update">
            <h2>Update</h2>
            <p>
            The client may request that the server sets the value of a signal.
            If the server is able to satisfy the request it <em class="rfc2119" title="SHALL">SHALL</em> return a
            <a href="#dfn-setsuccessresponse" class="internalDFN" data-link-type="dfn">setSuccessResponse</a> message.
            If an error occurs e.g. because the client is not authorized to set the requested value, or the value is read-only,
            the server <em class="rfc2119" title="SHALL">SHALL</em> return a
            <a href="#dfn-seterrorresponse" class="internalDFN" data-link-type="dfn">setErrorResponse</a> message.
            </p>
            <p>
              <b>Example:</b>
              <pre><code>
              POST /Vehicle/Drivetrain/Transmission/PerformanceMode   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              {
                "value": "sport"
              }
              </code></pre>
              Successful response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
              Error response:
              <pre><code>
              HTTP/1.1 404 Not Found
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "error": {"number": 404, "reason": "unavailable_data", "description": "The requested data was not found."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>

          <section id="https-authorized-update">
            <h2>Authorized Update</h2>
            <p>
            JWT tokens will be sent in the <code>Authorization</code> header, following with term <code>Bearer</code> and a space character.
            </p>
            <p>
            The following example assumes
            <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds</code>
            is the actual token. A token header can be combined with all types of update requests.
            </p>
            <pre><code>
            POST /Vehicle/Drivetrain/Transmission/PerformanceMode   HTTP/1.1
            Host:127.0.0.1:1337
            Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds
            {
              "value": "sport"
            }
            </code></pre>
          </section>
          </section>
        </section>
      </section>

      <section id="mqtt">
        <h2>MQTT</h2>
        <p>
        As the MQTT protocol is based on a pub-sub model, while VISS is based on a client-server model, it is necessary to apply a thin application level protocol
        on top of MQTT to abstract the client-server specific behavior. This is done by embedding the VISS messages in the MQTT messages,
        together with supplementary information that makes this abstraction possible, see the next chapter.<br>
        The VISS messages are adhering to the primary payload format without any deviations.
        </p>

        <section id="application-level-protocol">
          <h2>Application Level Protocol</h2>
          <p>
            For MQTT to support the complete VISSv3 interface, as decribed in the <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#interface">interface</a> chapter of the [[CORE]] specification,
            an application level protocol that runs on top of MQTT is added.
            It is described in the following, please also see the sequence diagram below.
            To emulate the client-server pattern that is described in the [[CORE]] specification, the vehicle server, via its vehicle client,
            issues a subscribe request to the broker on a topic named VID/Vehicle,
            where VID is an identity that uniquely links to the vehicle in the access control ecosystem.
            This vehicle identity is not necessarily the manufacturer's Vehicle Identification Number (VIN).<br>
            The client on the "cloud side" of the broker is expected to have access to this vehicle identity.
            How it obtains it is out of scope for this specification.
            When the cloud client wants to issue a request to the vehicle server it first generates a unique topic name,
            which it subscribes to at the broker. It then generates a JSON formatted payload with the general structure
            <pre><code>
            {"topic":"aUniqueTopic", "request":"VISSv3Request"}
            </code></pre>
            where "aUniqueTopic" is the uniques topic name it just subscribed to, and "VISSv3Request" is the request for the vehicle server.
            This request MUST follow the primary payload format of this specification.
            This JSON message is then issued to the broker, associated to the topic VID/Vehicle.
            This message will then be forwarded by the broker to the vehicle client, which forwards the string being the value of the
            "request" key in the message to the vehicle server. When the vehicle client receives the response to this request,
            it publishes it to the broker associated with the topic name that was the string value of the "topic" key name in the
            message it previously received from the broker.<br>
            The broker will then forward this message to the cloud side client that earlier subscribed to this topic name,
            which concludes the client-server based request-response as described in the [[CORE]] specification.<br>
            In the case of subscription requests the vehicle client needs to save the subscriptionId found in the subscribe response,
            together with the topic name associated to the subscribe request. When the vehicle server later issues event messages,
            the vehicle client must parse the subscriptionId from it, and retrieve the topic name associated to it.
            The vehicle client shall delete the saved topic name and subscriptionId when it receives
            an unsubscribe request in a message from the broker.<br>
            In following requests from the cloud side client, the unique topic name may be reused from the previous request-response cycle,
            or a new unique topic name may be generated. If a new topic name is generated, an unsubscribe should be issued on the old topic name.
            The vehicle client can continue to use the topic name it subscribes to.<br>
            The payload format of the response/event messages SHALL follow the primary payload format of this specification.
            The access control model is applicable also over this transport alternative.
            The Access Token server should then implement its own version of the application level protocol described here,
            using the topic name "VID/ATS". The Access Grant Token server may also do the same, with the topic name "VID/AGTS",
            or if it is deployed in the cloud it may expose the HTTPS interface that is defined in this specification.

          <figure id="VISSv3-over-mqtt">
            <img src="images/mqtt_vissv3_protocol.jpg" alt="VISSv3 over MQTT">
            <figcaption> <span class="fig-title">Message flow of VISSv3 over MQTT </span></figcaption>
          </figure>
          </p>
        </section>

        <section id="security-aspects">
          <h2>Security Aspects</h2>
          <p>
            The MQTT architecture mandates a "broker" that acts as a middleman in between the client and server endpoints
            (the subscriber and the publisher in MQTT terminology).
            This broker has full access to the plaintext communication between the two endpoints as each of the endpoint's
            TLS channel terminates at the broker. This aspect should be considered when selecting to use the MQTT protocol.
          </p>
        </section>

        <section id="transport-messages">
          <h2>Transport Messages</h2>
          <p>
            As mentioned in the "Application Level Protocol" chapter, the "request" messages issued to the broker contains two
            JSON formatted key-value pairs, where the value of the "request" key is a string that contains the request the vehicle server
            will respond to.
            The format of this request MUST follow the primary payload format of this specification.
          </p>
        </section>
      </section>

      <section id="grpc">
        <h2>gRPC</h2>
        <p>
        The gRPC protocol uses protobuf for the serialization.
        The definition of protobuf messages shall be expressed in a .proto-file.
        The proto file defining the encoding of the VISS primary payload format is found in the [[PAYLOAD ENCODING]] document.
        A protobuf compiler is used to generate code from the .proto-file that can then be called by the code executing the actual encoding/decoding
        between the two payload formats.
        This code can be implemented in different languages, and is out-of-scope for VISS standardization.
        An example of it in Go language can be found 
        <a href="https://github.com/COVESA/vissr/blob/master/utils/grcputils.go">here</a>.
        </p>
      </section>
      </section>

      <section id="Defs">
        <h2>Definitions</h2>

        <section id="term-def">
          <h2>Term Definitions</h2>
	<table class="parameters">
	  <tbody><tr>
	    <th>Attribute</th>
	    <th>Type</th>
	    <th>Description</th>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-action">action</dfn></td>
	    <td> <a href="#action-def">Action</a></td>
	    <td>The type of action requested by the client or delivered by the server.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-path">path</dfn></td>
	    <td>string</td>
	    <td>The path to a node in the VSS tree, as defined by the
	    <a href="https://github.com/COVESA/vehicle_signal_specification">Vehicle Signal Specification (VSS)</a>.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-requestid">requestId</dfn></td>
            <td>string</td>
	    <td> Unique id value specified by the client. Returned by the server in
	    the response and used by the client to link the request and response
	    messages. The value <em class="rfc2119" title="MAY">MAY</em> be an integer or a Universally Unique Identifier (UUID).</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-subscriptionid">subscriptionId</dfn> </td>
            <td>string</td>
	    <td>Value returned by the server to uniquely identify each subscription.</td>
	  </tr>
	  <tr>
	    <td><dfn data-dfn-type="dfn" id="dfn-authorization">authorization</dfn> </td>
	    <td>string</td>
	    <td>A JWT formatted security token.</td>
	  </tr>
	  <tr>
	    <td><b>data</b> </td>
	    <td>object / array</td>
	    <td>Data contains one or more objects each consisting of a path and a data point.</td>
	  </tr>
	  <tr>
	    <td><b>dp</b> </td>
	    <td>object / array</td>
	    <td>A data point contains one or more objects each consisting of a value and a timestamp.</td>
	  </tr>
	  <tr>
	    <td><dfn data-dfn-type="dfn" id="dfn-ts">ts</dfn> </td>
	    <td>string</td>
	    <td>The Coordinated Universal Time (UTC) time stamp that represents the capture of the value.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-value">value</dfn> </td>
	    <td>string/ object / array</td>
	    <td> The data value associated with the path.</td>
	  </tr>
    <tr>
      <td> <dfn data-dfn-type="dfn" id="dfn-filter">filter</dfn> </td>
      <td> string </td>
      <td>Provides a filtering mechanism to reduce the demands of a subscription on the server. Query format, see [[CORE]], <a data-link-type="dfn" href="https://github.com/COVESA/vehicle-information-service-specification/blob/gh-pages/spec/VISSv3.0_Core.html#filter-request">Filter Request</a> chapter.</td>
    </tr>
    <tr>
      <td><dfn data-dfn-type="dfn" id="dfn-data-compression">data compression</dfn> </td>
      <td> string </td>
      <td>Compression of path and/or timestamp data.</td>
    </tr>
    <tr>
      <td> <b>metadata</b> </td>
      <td> object </td>
      <td>Metadata describing the potentially available signal (sub)tree.</td>
    </tr>
	  <tr>
	    <td id="dfn-error"><strong>error</strong></td>
	    <td> <a href="#error-def">Error</a> </td>
	    <td> Returns an error code, reason and description.</td>
	  </tr>
	</tbody></table>
        </section>

        <section id="action-def">
          <h2>Action Definitions</h2>
	<p>The Action enumeration is used to define the type of action requested by the client.
	All client messages <em class="rfc2119" title="MUST">MUST</em> contain a JSON structure that has an
	<a href="#dfn-action" class="internalDFN" data-link-type="dfn">action</a> name/value pair and the
	value of the <a href="#dfn-action" class="internalDFN" data-link-type="dfn">action</a> property
	<em class="rfc2119" title="MUST">MUST</em> be one of the values specified in the enumeration:</p>

	<dl title="enum Action" class="idl">
	  <dt><b>get</b></dt>
	  <dd>Enables the client to read one or more values.</dd>
	  <dt><b>set</b></dt>
	  <dd>Enables the client to update one value.</dd>
	  <dt><b>subscribe</b></dt>
	  <dd>Enables the client to request event messages containing a JSON data structure with values for one or more vehicle signal.</dd>
	  <dt><b>unsubscribe</b></dt>
	  <dd>Enables the client to request that it should no longer receive event messages based on that subscription.</dd>
	  <dt><b>subscription</b></dt>
	  <dd>Enables the server to send event messages to the client containing a JSON data structure with values for one or more vehicle signals.</dd>
	  </dl>
        </section>

        <section id="error-def">
          <h2>Error Definitions</h2>
          <p>The error number SHOULD be a status code defined in [[RFC2616]], c. f. chapter "Status codes".
          The error reason SHOULD be short. two or three words connected by underscore.
          It SHOULD relate to the reason-phrase from [[RFC2616]] for the corresponding status code.
          The error description is meant to give more precise information of the error.
          </p>
<table class="simple">
  <thead>
    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3"><b>Error</b></th>
      <td><a href="#status-codes">number</a></td><td>string</td><td>Yes</td></tr>
      <tr><td><a href="#status-codes">reason</a></td><td>string</td><td>No</td></tr>
      <tr><td><a href="#status-codes">description</a></td><td>string</td><td>No</td></tr>

  </tbody>
  </table>
        </section>

    <div id="tof" class="appendix"></div>
  </body>
</html>
